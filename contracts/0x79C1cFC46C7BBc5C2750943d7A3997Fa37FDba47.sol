contract main {




// =====================  Runtime code  =====================


#
#  - unstakeQuery(uint256 arg1)
#  - unstake(uint256 arg1, bytes arg2)
#
const supportsHistory = 0

const BONUS_DECIMALS = 2


address owner;
address stor1;
address stor2;
address stor3;
uint256 startBonus;
uint256 bonusPeriodSec;
uint256 totalLockedShares;
uint256 totalStakingShares;
uint256 stor8;
uint256 stor9;
uint256 stor10;
uint256 stor11;
mapping of struct stor12;
array of struct stor13;
array of struct unlockSchedules;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896574;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896575;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896576;
array of uint256 stor84800337471693920904250232874319843718400766719524250287777680170677855896577;

function startBonus() {
    return startBonus
}

function unlockSchedules(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 < unlockSchedules.length
    return unlockSchedules[arg1].field_0, 
           unlockSchedules[arg1].field_256,
           unlockSchedules[arg1].field_512,
           unlockSchedules[arg1].field_768,
           unlockSchedules[arg1].field_1024
}

function totalStakingShares() {
    return totalStakingShares
}

function bonusPeriodSec() {
    return bonusPeriodSec
}

function totalLockedShares() {
    return totalLockedShares
}

function owner() {
    return owner
}

function unlockScheduleCount() {
    return unlockSchedules.length
}

function _fallback() payable {
    revert
}

function isOwner() {
    return (msg.sender == owner)
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function totalLocked() {
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function totalStaked() {
    require ext_code.size(stor1)
    staticcall stor1.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function totalUnlocked() {
    require ext_code.size(stor2)
    staticcall stor2.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function token() {
    require ext_code.size(stor1)
    staticcall stor1.0xfc0c546a with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[12 len 20]
}

function getStakingToken() {
    require ext_code.size(stor1)
    staticcall stor1.0xfc0c546a with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[12 len 20]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function rescueFundsFromStakingPool(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    require ext_code.size(stor1)
    call stor1.rescueFunds(address rg1, address rg2, uint256 rg3) with:
         gas gas_remaining wei
        args address(arg1), address(arg2), arg3
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return bool(ext_call.return_data[0])
}

function getDistributionToken() {
    require ext_code.size(stor3)
    staticcall stor3.0xfc0c546a with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor2)
    staticcall stor2.0xfc0c546a with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[12 len 20] == address(ext_call.return_data[0])
    require ext_code.size(stor2)
    staticcall stor2.0xfc0c546a with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[12 len 20]
}

function totalStakedFor(address arg1) {
    require calldata.size - 4 >= 32
    if totalStakingShares <= 0:
        return 0
    require ext_code.size(stor1)
    staticcall stor1.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        if totalStakingShares <= 0:
            revert with 0, 'SafeMath: division by zero'
        if totalStakingShares:
            return (0 / totalStakingShares)
    else:
        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        if totalStakingShares <= 0:
            revert with 0, 'SafeMath: division by zero'
        if totalStakingShares:
            return (stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares)
    ('iszero', ('stor', ('name', 'totalStakingShares', 7)))
    revert
}

function unlockTokens() payable {
    mem[64] = 96
    require not msg.value
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 0 == totalLockedShares:
        if ext_call.return_data[0] > 0:
            require ext_code.size(stor3)
            call stor3.0xa9059cbb with:
                 gas gas_remaining wei
                args stor2, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: transfer out of locked pool failed'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
        return ext_call.return_data[0]
    idx = 0
    while idx < unlockSchedules.length:
        mem[0] = 14
        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
            idx = idx + 1
            continue 
        if block.timestamp >= unlockSchedules[idx].field_768:
            _115 = mem[64]
            mem[64] = mem[64] + 64
            mem[_115] = 30
            mem[_115 + 32] = 'SafeMath: subtraction overflow'
            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                    revert with 0, 'SafeMath: addition overflow'
                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                continue 
            _122 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _122 + 68] = mem[idx + _115 + 32]
                idx = idx + 32
                continue 
            mem[_122 + 68] = mem[_122 + 70 len 30]
            revert with memory
              from mem[64]
               len _122 + -mem[64] + 100
        _114 = mem[64]
        mem[64] = mem[64] + 64
        mem[_114] = 30
        mem[_114 + 32] = 'SafeMath: subtraction overflow'
        if unlockSchedules[idx].field_512 > block.timestamp:
            _119 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _119 + 68] = mem[idx + _114 + 32]
                idx = idx + 32
                continue 
            mem[_119 + 68] = mem[_119 + 70 len 30]
            revert with memory
              from mem[64]
               len _119 + -mem[64] + 100
        if not block.timestamp - unlockSchedules[idx].field_512:
            _149 = mem[64]
            mem[64] = mem[64] + 64
            mem[_149] = 26
            mem[_149 + 32] = 'SafeMath: division by zero'
            if unlockSchedules[idx].field_1024 > 0:
                require unlockSchedules[idx].field_1024
                unlockSchedules[idx].field_512 = block.timestamp
                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                    revert with 0, 'SafeMath: addition overflow'
                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                if 0 / unlockSchedules[idx].field_1024 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                continue 
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            mem[mem[64] + 68] = 'SafeMath: division by zero'
            idx = 32
            while idx < 26:
                mem[idx + mem[64] + 68] = mem[idx + _149 + 32]
                idx = idx + 32
                continue 
        else:
            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                revert with 0, 'SafeMath: multiplication overflow'
            _153 = mem[64]
            mem[64] = mem[64] + 64
            mem[_153] = 26
            mem[_153 + 32] = 'SafeMath: division by zero'
            if unlockSchedules[idx].field_1024 > 0:
                require unlockSchedules[idx].field_1024
                unlockSchedules[idx].field_512 = block.timestamp
                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                    revert with 0, 'SafeMath: addition overflow'
                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                continue 
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            mem[mem[64] + 68] = 'SafeMath: division by zero'
            idx = 32
            while idx < 26:
                mem[idx + mem[64] + 68] = mem[idx + _153 + 32]
                idx = idx + 32
                continue 
        revert with 0, 'SafeMath: division by zero'
    if totalLockedShares <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totalLockedShares
    if 0 > totalLockedShares:
        revert with 0, 'SafeMath: subtraction overflow'
    if 0 / totalLockedShares > 0:
        require ext_code.size(stor3)
        call stor3.0xa9059cbb with:
             gas gas_remaining wei
            args stor2, 0 / totalLockedShares
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
        require ext_code.size(stor3)
        staticcall stor3.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
    return (0 / totalLockedShares)
}

function updateAccounting() payable {
    mem[64] = 96
    require not msg.value
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 0 == totalLockedShares:
        if ext_call.return_data[0] > 0:
            require ext_code.size(stor3)
            call stor3.0xa9059cbb with:
                 gas gas_remaining wei
                args stor2, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: transfer out of locked pool failed'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
    else:
        idx = 0
        while idx < unlockSchedules.length:
            mem[0] = 14
            if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                idx = idx + 1
                continue 
            if block.timestamp >= unlockSchedules[idx].field_768:
                _1331 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1331] = 30
                mem[_1331 + 32] = 'SafeMath: subtraction overflow'
                if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                    unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                    if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                    if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    continue 
                _1338 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1338 + 68] = mem[idx + _1331 + 32]
                    idx = idx + 32
                    continue 
                mem[_1338 + 68] = mem[_1338 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1338 + -mem[64] + 100
            _1330 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1330] = 30
            mem[_1330 + 32] = 'SafeMath: subtraction overflow'
            if unlockSchedules[idx].field_512 > block.timestamp:
                _1335 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1335 + 68] = mem[idx + _1330 + 32]
                    idx = idx + 32
                    continue 
                mem[_1335 + 68] = mem[_1335 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1335 + -mem[64] + 100
            if not block.timestamp - unlockSchedules[idx].field_512:
                _1365 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1365] = 26
                mem[_1365 + 32] = 'SafeMath: division by zero'
                if unlockSchedules[idx].field_1024 > 0:
                    require unlockSchedules[idx].field_1024
                    unlockSchedules[idx].field_512 = block.timestamp
                    if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                    if 0 / unlockSchedules[idx].field_1024 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    continue 
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _1365 + 32]
                    idx = idx + 32
                    continue 
            else:
                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1369 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1369] = 26
                mem[_1369 + 32] = 'SafeMath: division by zero'
                if unlockSchedules[idx].field_1024 > 0:
                    require unlockSchedules[idx].field_1024
                    unlockSchedules[idx].field_512 = block.timestamp
                    if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                    if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    continue 
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _1369 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        if totalLockedShares <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalLockedShares
        if 0 > totalLockedShares:
            revert with 0, 'SafeMath: subtraction overflow'
        if 0 / totalLockedShares > 0:
            require ext_code.size(stor3)
            call stor3.0xa9059cbb with:
                 gas gas_remaining wei
                args stor2, 0 / totalLockedShares
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'TokenGeyser: transfer out of locked pool failed'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
    if stor9 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - stor9:
        if stor8 < stor8:
            revert with 0, 'SafeMath: addition overflow'
    else:
        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
            revert with 0, 'SafeMath: multiplication overflow'
        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
            revert with 0, 'SafeMath: addition overflow'
        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
    stor9 = block.timestamp
    if stor12[msg.sender].field_512 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - stor12[msg.sender].field_512:
        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
            revert with 0, 'SafeMath: addition overflow'
    else:
        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
            revert with 0, 'SafeMath: multiplication overflow'
        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
            revert with 0, 'SafeMath: addition overflow'
        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
    stor12[msg.sender].field_512 = block.timestamp
    if 0 >= stor8:
        require ext_code.size(stor3)
        staticcall stor3.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(stor2)
        staticcall stor2.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        return ext_call.return_data[0], ext_call.return_data[0], stor12[msg.sender].field_256, stor8, 0, block.timestamp
    require ext_code.size(stor2)
    staticcall stor2.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        if stor8 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require stor8
        require ext_code.size(stor3)
        staticcall stor3.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(stor2)
        staticcall stor2.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        return ext_call.return_data[0], ext_call.return_data[0], stor12[msg.sender].field_256, stor8, 0 / stor8, block.timestamp
    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
        revert with 0, 'SafeMath: multiplication overflow'
    if stor8 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require stor8
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor2)
    staticcall stor2.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0], 
           ext_call.return_data[0],
           stor12[msg.sender].field_256,
           stor8,
           stor12[msg.sender].field_256 * ext_call.return_data[0] / stor8,
           block.timestamp
}

function lockTokens(uint256 arg1, uint256 arg2) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if unlockSchedules.length >= stor10:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: reached maximum unlock schedules'
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 0 == totalLockedShares:
        if ext_call.return_data[0] > 0:
            require ext_code.size(stor3)
            call stor3.0xa9059cbb with:
                 gas gas_remaining wei
                args stor2, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: transfer out of locked pool failed'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
    else:
        idx = 0
        while idx < unlockSchedules.length:
            mem[0] = 14
            if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                idx = idx + 1
                continue 
            if block.timestamp >= unlockSchedules[idx].field_768:
                _7961 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7961] = 30
                mem[_7961 + 32] = 'SafeMath: subtraction overflow'
                if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                    unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                    if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                    if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    continue 
                _7968 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _7968 + 68] = mem[idx + _7961 + 32]
                    idx = idx + 32
                    continue 
                mem[_7968 + 68] = mem[_7968 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _7968 + -mem[64] + 100
            _7960 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7960] = 30
            mem[_7960 + 32] = 'SafeMath: subtraction overflow'
            if unlockSchedules[idx].field_512 > block.timestamp:
                _7965 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _7965 + 68] = mem[idx + _7960 + 32]
                    idx = idx + 32
                    continue 
                mem[_7965 + 68] = mem[_7965 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _7965 + -mem[64] + 100
            if not block.timestamp - unlockSchedules[idx].field_512:
                _7995 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7995] = 26
                mem[_7995 + 32] = 'SafeMath: division by zero'
                if unlockSchedules[idx].field_1024 > 0:
                    require unlockSchedules[idx].field_1024
                    unlockSchedules[idx].field_512 = block.timestamp
                    if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                    if 0 / unlockSchedules[idx].field_1024 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    continue 
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _7995 + 32]
                    idx = idx + 32
                    continue 
            else:
                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                    revert with 0, 'SafeMath: multiplication overflow'
                _7999 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7999] = 26
                mem[_7999 + 32] = 'SafeMath: division by zero'
                if unlockSchedules[idx].field_1024 > 0:
                    require unlockSchedules[idx].field_1024
                    unlockSchedules[idx].field_512 = block.timestamp
                    if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                    if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    continue 
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _7999 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        if totalLockedShares <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalLockedShares
        if 0 > totalLockedShares:
            revert with 0, 'SafeMath: subtraction overflow'
        if 0 / totalLockedShares > 0:
            require ext_code.size(stor3)
            call stor3.0xa9059cbb with:
                 gas gas_remaining wei
                args stor2, 0 / totalLockedShares
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'TokenGeyser: transfer out of locked pool failed'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
    if stor9 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - stor9:
        if stor8 < stor8:
            revert with 0, 'SafeMath: addition overflow'
    else:
        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
            revert with 0, 'SafeMath: multiplication overflow'
        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
            revert with 0, 'SafeMath: addition overflow'
        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
    stor9 = block.timestamp
    if stor12[msg.sender].field_512 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not block.timestamp - stor12[msg.sender].field_512:
        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
            revert with 0, 'SafeMath: addition overflow'
    else:
        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
            revert with 0, 'SafeMath: multiplication overflow'
        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
            revert with 0, 'SafeMath: addition overflow'
        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
    stor12[msg.sender].field_512 = block.timestamp
    if 0 < stor8:
        require ext_code.size(stor2)
        staticcall stor2.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
        if stor8 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require stor8
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor2)
    staticcall stor2.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= 0:
        if not arg1:
            if arg2 + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            unlockSchedules.length++
            unlockSchedules[unlockSchedules.length].field_0 = 0
            storBB7B[stor14.length] = 0
            storBB7B[stor14.length] = block.timestamp
            storBB7B[stor14.length] = arg2 + block.timestamp
            storBB7B[stor14.length] = arg2
            if totalLockedShares < totalLockedShares:
                revert with 0, 'SafeMath: addition overflow'
        else:
            if stor11 * arg1 / arg1 != stor11:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg2 + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            unlockSchedules.length++
            unlockSchedules[unlockSchedules.length].field_0 = stor11 * arg1
            storBB7B[stor14.length] = 0
            storBB7B[stor14.length] = block.timestamp
            storBB7B[stor14.length] = arg2 + block.timestamp
            storBB7B[stor14.length] = arg2
            if (stor11 * arg1) + totalLockedShares < totalLockedShares:
                revert with 0, 'SafeMath: addition overflow'
            totalLockedShares += stor11 * arg1
    else:
        if not totalLockedShares:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if arg2 + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            unlockSchedules.length++
            unlockSchedules[unlockSchedules.length].field_0 = 0 / ext_call.return_data[0]
            storBB7B[stor14.length] = 0
            storBB7B[stor14.length] = block.timestamp
            storBB7B[stor14.length] = arg2 + block.timestamp
            storBB7B[stor14.length] = arg2
            if (0 / ext_call.return_data[0]) + totalLockedShares < totalLockedShares:
                revert with 0, 'SafeMath: addition overflow'
            totalLockedShares += 0 / ext_call.return_data[0]
        else:
            if arg1 * totalLockedShares / totalLockedShares != arg1:
                revert with 0, 'SafeMath: multiplication overflow'
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if arg2 + block.timestamp < block.timestamp:
                revert with 0, 'SafeMath: addition overflow'
            unlockSchedules.length++
            unlockSchedules[unlockSchedules.length].field_0 = arg1 * totalLockedShares / ext_call.return_data[0]
            storBB7B[stor14.length] = 0
            storBB7B[stor14.length] = block.timestamp
            storBB7B[stor14.length] = arg2 + block.timestamp
            storBB7B[stor14.length] = arg2
            if (arg1 * totalLockedShares / ext_call.return_data[0]) + totalLockedShares < totalLockedShares:
                revert with 0, 'SafeMath: addition overflow'
            totalLockedShares += arg1 * totalLockedShares / ext_call.return_data[0]
    require ext_code.size(stor3)
    staticcall stor3.0xfc0c546a with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, stor3, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        revert with 0, 'TokenGeyser: transfer into locked pool failed'
    require ext_code.size(stor3)
    staticcall stor3.balance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    emit TokensLocked(arg1, arg2, ext_call.return_data[0]);
}

function stakeFor(address arg1, uint256 arg2, bytes arg3) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 96
    require arg3 <= 4294967296
    require arg3 + 36 <= calldata.size
    require arg3.length <= 4294967296 and arg3 + arg3.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 32, 32, 0xfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: stake amount is zero'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: beneficiary is zero address'
    if not totalStakingShares:
        if totalStakingShares <= 0:
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            if stor11 * arg2 / arg2 != stor11:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
            if stor11 * arg2 <= 0:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 0 == totalLockedShares:
                if ext_call.return_data[0] > 0:
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                if stor9 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor9:
                    if stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                    stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                stor9 = block.timestamp
                if stor12[msg.sender].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor12[msg.sender].field_512:
                    if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                stor12[msg.sender].field_512 = block.timestamp
                if 0 >= stor8:
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(arg1)].field_0 += stor11 * arg2
                    stor12[address(arg1)].field_512 = block.timestamp
                    stor13[address(arg1)].field_0++
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg2
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg2,
                                    0,
                                    96,
                                    0,
                                    mem[480],
                                    arg1,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                        else:
                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                else:
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                    if stor8 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require stor8
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(arg1)].field_0 += stor11 * arg2
                    stor12[address(arg1)].field_512 = block.timestamp
                    stor13[address(arg1)].field_0++
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg2
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg2,
                                    0,
                                    96,
                                    0,
                                    mem[544],
                                    arg1,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
                        else:
                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
            else:
                idx = 0
                while idx < unlockSchedules.length:
                    mem[0] = 14
                    if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                        idx = idx + 1
                        continue 
                    if block.timestamp >= unlockSchedules[idx].field_768:
                        _25367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25367] = 30
                        mem[_25367 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                            unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                            if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                            if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        _25401 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25401 + 68] = mem[idx + _25367 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25401 + 68] = mem[_25401 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25401 + -mem[64] + 100
                    _25366 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25366] = 30
                    mem[_25366 + 32] = 'SafeMath: subtraction overflow'
                    if unlockSchedules[idx].field_512 > block.timestamp:
                        _25398 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25398 + 68] = mem[idx + _25366 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25398 + 68] = mem[_25398 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25398 + -mem[64] + 100
                    if not block.timestamp - unlockSchedules[idx].field_512:
                        _25577 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25577] = 26
                        mem[_25577 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                            if 0 / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25577 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25601 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25601] = 26
                        mem[_25601 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25601 + 32]
                            idx = idx + 32
                            continue 
                    revert with 0, 'SafeMath: division by zero'
                _25365 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25365] = 26
                mem[_25365 + 32] = 'SafeMath: division by zero'
                if totalLockedShares <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalLockedShares
                _25525 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25525] = 30
                mem[_25525 + 32] = 'SafeMath: subtraction overflow'
                if 0 > totalLockedShares:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 / totalLockedShares <= 0:
                    _25719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25719] = 30
                    mem[_25719 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _25991 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25991] = 30
                        mem[_25991 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27370] = 0
                                mem[_27370 + 32] = 0
                                _27504 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27504] = stor11 * arg2
                                mem[_27504 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _30802 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30802] = 26
                                        mem[_30802 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31065 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31065] = 26
                                        mem[_31065 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26641 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26641] = 26
                                    mem[_26641 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29587] = 0
                                    mem[_29587 + 32] = 0
                                    _29734 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29734] = stor11 * arg2
                                    mem[_29734 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33491 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33491] = 26
                                            mem[_33491 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33798 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33798] = 26
                                            mem[_33798 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26745 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26745] = 26
                                    mem[_26745 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29854] = 0
                                    mem[_29854 + 32] = 0
                                    _30015 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30015] = stor11 * arg2
                                    mem[_30015 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33797 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33797] = 26
                                            mem[_33797 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34190 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34190] = 26
                                            mem[_34190 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27630] = 0
                                mem[_27630 + 32] = 0
                                _27767 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27767] = stor11 * arg2
                                mem[_27767 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31063 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31063] = 26
                                        mem[_31063 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31395] = 26
                                        mem[_31395 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26743 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26743] = 26
                                    mem[_26743 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29853] = 0
                                    mem[_29853 + 32] = 0
                                    _30007 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30007] = stor11 * arg2
                                    mem[_30007 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33796 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33796] = 26
                                            mem[_33796 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34186 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34186] = 26
                                            mem[_34186 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26889 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26889] = 26
                                    mem[_26889 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30162 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30162] = 0
                                    mem[_30162 + 32] = 0
                                    _30318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30318] = stor11 * arg2
                                    mem[_30318 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34185 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34185] = 26
                                            mem[_34185 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34641 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34641] = 26
                                            mem[_34641 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26019 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26019] = 30
                        mem[_26019 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27627] = 0
                                mem[_27627 + 32] = 0
                                _27758 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27758] = stor11 * arg2
                                mem[_27758 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31061] = 26
                                        mem[_31061 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31390 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31390] = 26
                                        mem[_31390 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26741] = 26
                                    mem[_26741 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29852 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29852] = 0
                                    mem[_29852 + 32] = 0
                                    _29999 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29999] = stor11 * arg2
                                    mem[_29999 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33795 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33795] = 26
                                            mem[_33795 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34181] = 26
                                            mem[_34181 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26885] = 26
                                    mem[_26885 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30160] = 0
                                    mem[_30160 + 32] = 0
                                    _30311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30311] = stor11 * arg2
                                    mem[_30311 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34180 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34180] = 26
                                            mem[_34180 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34632 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34632] = 26
                                            mem[_34632 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27891 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27891] = 0
                                mem[_27891 + 32] = 0
                                _28003 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28003] = stor11 * arg2
                                mem[_28003 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31388 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31388] = 26
                                        mem[_31388 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31806 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31806] = 26
                                        mem[_31806 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26883 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26883] = 26
                                    mem[_26883 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30159 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30159] = 0
                                    mem[_30159 + 32] = 0
                                    _30303 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30303] = stor11 * arg2
                                    mem[_30303 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34179 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34179] = 26
                                            mem[_34179 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34628 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34628] = 26
                                            mem[_34628 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _27099 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27099] = 26
                                    mem[_27099 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30467 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30467] = 0
                                    mem[_30467 + 32] = 0
                                    _30563 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30563] = stor11 * arg2
                                    mem[_30563 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34627 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34627] = 26
                                            mem[_34627 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35073 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35073] = 26
                                            mem[_35073 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                else:
                    mem[mem[64] + 36] = 0 / totalLockedShares
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, 0 / totalLockedShares
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 32] = ext_call.return_data[0]
                    emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                    _25943 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25943] = 30
                    mem[_25943 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26183 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26183] = 30
                        mem[_26183 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _28838 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28838] = 0
                                mem[_28838 + 32] = 0
                                _29008 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29008] = stor11 * arg2
                                mem[_29008 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _32837 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32837] = 26
                                        mem[_32837 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33143] = 26
                                        mem[_33143 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _27775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27775] = 26
                                    mem[_27775 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31073 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31073] = 0
                                    mem[_31073 + 32] = 0
                                    _31225 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31225] = stor11 * arg2
                                    mem[_31225 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35630 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35630] = 26
                                            mem[_35630 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35882 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35882] = 26
                                            mem[_35882 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28022 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28022] = 26
                                    mem[_28022 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31408] = 0
                                    mem[_31408 + 32] = 0
                                    _31607 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31607] = stor11 * arg2
                                    mem[_31607 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35881 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35881] = 26
                                            mem[_35881 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36081 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36081] = 26
                                            mem[_36081 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _29170 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29170] = 0
                                mem[_29170 + 32] = 0
                                _29320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29320] = stor11 * arg2
                                mem[_29320 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33141 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33141] = 26
                                        mem[_33141 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33380] = 26
                                        mem[_33380 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28020] = 26
                                    mem[_28020 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31407] = 0
                                    mem[_31407 + 32] = 0
                                    _31599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31599] = stor11 * arg2
                                    mem[_31599 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35880 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35880] = 26
                                            mem[_35880 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36077 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36077] = 26
                                            mem[_36077 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28236 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28236] = 26
                                    mem[_28236 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31831 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31831] = 0
                                    mem[_31831 + 32] = 0
                                    _32044 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32044] = stor11 * arg2
                                    mem[_32044 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36076 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36076] = 26
                                            mem[_36076 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36291 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36291] = 26
                                            mem[_36291 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26225 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26225] = 30
                        mem[_26225 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _29167 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29167] = 0
                                mem[_29167 + 32] = 0
                                _29311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29311] = stor11 * arg2
                                mem[_29311 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33139 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33139] = 26
                                        mem[_33139 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33375 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33375] = 26
                                        mem[_33375 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28018 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28018] = 26
                                    mem[_28018 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31406] = 0
                                    mem[_31406 + 32] = 0
                                    _31591 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31591] = stor11 * arg2
                                    mem[_31591 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35879 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35879] = 26
                                            mem[_35879 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36072 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36072] = 26
                                            mem[_36072 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28232 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28232] = 26
                                    mem[_28232 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31829 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31829] = 0
                                    mem[_31829 + 32] = 0
                                    _32037 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32037] = stor11 * arg2
                                    mem[_32037 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36071 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36071] = 26
                                            mem[_36071 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36282 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36282] = 26
                                            mem[_36282 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _29477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29477] = 0
                                mem[_29477 + 32] = 0
                                _29592 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29592] = stor11 * arg2
                                mem[_29592 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33373] = 26
                                        mem[_33373 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33632 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33632] = 26
                                        mem[_33632 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28230 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28230] = 26
                                    mem[_28230 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31828 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31828] = 0
                                    mem[_31828 + 32] = 0
                                    _32029 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32029] = stor11 * arg2
                                    mem[_32029 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36070 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36070] = 26
                                            mem[_36070 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36278 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36278] = 26
                                            mem[_36278 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28494 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28494] = 26
                                    mem[_28494 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _32278 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32278] = 0
                                    mem[_32278 + 32] = 0
                                    _32451 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32451] = stor11 * arg2
                                    mem[_32451 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36277 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36277] = 26
                                            mem[_36277 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36565 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36565] = 26
                                            mem[_36565 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
        else:
            require ext_code.size(stor1)
            staticcall stor1.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not totalStakingShares:
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if 0 / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25364 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25364] = 30
                            mem[_25364 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25392 + 68] = mem[idx + _25364 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25392 + 68] = mem[_25392 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25392 + -mem[64] + 100
                        _25363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25363] = 30
                        mem[_25363 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25389 + 68] = mem[idx + _25363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25389 + 68] = mem[_25389 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25389 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25576] = 26
                            mem[_25576 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25576 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25595] = 26
                            mem[_25595 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25595 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25362 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25362] = 26
                    mem[_25362 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25523 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25523] = 30
                    mem[_25523 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25713] = 30
                        mem[_25713 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25990 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25990] = 30
                            mem[_25990 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27350] = 0
                                    mem[_27350 + 32] = 0
                                    _27479 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27479] = 0 / ext_call.return_data[0]
                                    mem[_27479 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30783 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30783] = 26
                                            mem[_30783 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31048 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31048] = 26
                                            mem[_31048 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26639 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26639] = 26
                                        mem[_26639 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29563 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29563] = 0
                                        mem[_29563 + 32] = 0
                                        _29712 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29712] = 0 / ext_call.return_data[0]
                                        mem[_29712 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33472 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33472] = 26
                                                mem[_33472 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33771 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33771] = 26
                                                mem[_33771 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26735 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26735] = 26
                                        mem[_26735 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29834 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29834] = 0
                                        mem[_29834 + 32] = 0
                                        _29983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29983] = 0 / ext_call.return_data[0]
                                        mem[_29983 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33770 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33770] = 26
                                                mem[_33770 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34154 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34154] = 26
                                                mem[_34154 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27612 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27612] = 0
                                    mem[_27612 + 32] = 0
                                    _27739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27739] = 0 / ext_call.return_data[0]
                                    mem[_27739 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31046 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31046] = 26
                                            mem[_31046 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31372 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31372] = 26
                                            mem[_31372 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26733 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26733] = 26
                                        mem[_26733 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29833 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29833] = 0
                                        mem[_29833 + 32] = 0
                                        _29975 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29975] = 0 / ext_call.return_data[0]
                                        mem[_29975 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33769 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33769] = 26
                                                mem[_33769 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34150 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34150] = 26
                                                mem[_34150 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26868 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26868] = 26
                                        mem[_26868 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30144 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30144] = 0
                                        mem[_30144 + 32] = 0
                                        _30282 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30282] = 0 / ext_call.return_data[0]
                                        mem[_30282 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34149 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34149] = 26
                                                mem[_34149 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34600 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34600] = 26
                                                mem[_34600 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26013 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26013] = 30
                            mem[_26013 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27609 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27609] = 0
                                    mem[_27609 + 32] = 0
                                    _27730 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27730] = 0 / ext_call.return_data[0]
                                    mem[_27730 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31044 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31044] = 26
                                            mem[_31044 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31367 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31367] = 26
                                            mem[_31367 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26731] = 26
                                        mem[_26731 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29832] = 0
                                        mem[_29832 + 32] = 0
                                        _29967 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29967] = 0 / ext_call.return_data[0]
                                        mem[_29967 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33768 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33768] = 26
                                                mem[_33768 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34145 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34145] = 26
                                                mem[_34145 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26864 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26864] = 26
                                        mem[_26864 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30142 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30142] = 0
                                        mem[_30142 + 32] = 0
                                        _30275 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30275] = 0 / ext_call.return_data[0]
                                        mem[_30275 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34144 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34144] = 26
                                                mem[_34144 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34591 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34591] = 26
                                                mem[_34591 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27877 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27877] = 0
                                    mem[_27877 + 32] = 0
                                    _27976 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27976] = 0 / ext_call.return_data[0]
                                    mem[_27976 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31365 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31365] = 26
                                            mem[_31365 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31778 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31778] = 26
                                            mem[_31778 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26862 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26862] = 26
                                        mem[_26862 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30141 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30141] = 0
                                        mem[_30141 + 32] = 0
                                        _30267 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30267] = 0 / ext_call.return_data[0]
                                        mem[_30267 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34143 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34143] = 26
                                                mem[_34143 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34587 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34587] = 26
                                                mem[_34587 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27075 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27075] = 26
                                        mem[_27075 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30457] = 0
                                        mem[_30457 + 32] = 0
                                        _30535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30535] = 0 / ext_call.return_data[0]
                                        mem[_30535 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34586 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34586] = 26
                                                mem[_34586 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35034 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35034] = 26
                                                mem[_35034 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25940 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25940] = 30
                        mem[_25940 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26178] = 30
                            mem[_26178 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _28814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28814] = 0
                                    mem[_28814 + 32] = 0
                                    _28974 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28974] = 0 / ext_call.return_data[0]
                                    mem[_28974 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32816 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32816] = 26
                                            mem[_32816 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33127 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33127] = 26
                                            mem[_33127 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27747 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27747] = 26
                                        mem[_27747 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31056 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31056] = 0
                                        mem[_31056 + 32] = 0
                                        _31189 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31189] = 0 / ext_call.return_data[0]
                                        mem[_31189 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35614 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35614] = 26
                                                mem[_35614 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35869 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35869] = 26
                                                mem[_35869 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27995 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27995] = 26
                                        mem[_27995 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31385] = 0
                                        mem[_31385 + 32] = 0
                                        _31562 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31562] = 0 / ext_call.return_data[0]
                                        mem[_31562 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35868 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35868] = 26
                                                mem[_35868 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36060 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36060] = 26
                                                mem[_36060 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29151 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29151] = 0
                                    mem[_29151 + 32] = 0
                                    _29287 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29287] = 0 / ext_call.return_data[0]
                                    mem[_29287 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33125 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33125] = 26
                                            mem[_33125 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33359 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33359] = 26
                                            mem[_33359 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27993 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27993] = 26
                                        mem[_27993 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31384] = 0
                                        mem[_31384 + 32] = 0
                                        _31554 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31554] = 0 / ext_call.return_data[0]
                                        mem[_31554 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35867 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35867] = 26
                                                mem[_35867 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36056 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36056] = 26
                                                mem[_36056 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28206 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28206] = 26
                                        mem[_28206 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31803 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31803] = 0
                                        mem[_31803 + 32] = 0
                                        _31998 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31998] = 0 / ext_call.return_data[0]
                                        mem[_31998 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36055 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36055] = 26
                                                mem[_36055 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36259 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36259] = 26
                                                mem[_36259 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26217] = 30
                            mem[_26217 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29148 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29148] = 0
                                    mem[_29148 + 32] = 0
                                    _29278 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29278] = 0 / ext_call.return_data[0]
                                    mem[_29278 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33123 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33123] = 26
                                            mem[_33123 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33354 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33354] = 26
                                            mem[_33354 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27991 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27991] = 26
                                        mem[_27991 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31383] = 0
                                        mem[_31383 + 32] = 0
                                        _31546 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31546] = 0 / ext_call.return_data[0]
                                        mem[_31546 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35866 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35866] = 26
                                                mem[_35866 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36051 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36051] = 26
                                                mem[_36051 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28202 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28202] = 26
                                        mem[_28202 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31801 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31801] = 0
                                        mem[_31801 + 32] = 0
                                        _31991 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31991] = 0 / ext_call.return_data[0]
                                        mem[_31991 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36050 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36050] = 26
                                                mem[_36050 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36250 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36250] = 26
                                                mem[_36250 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29459 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29459] = 0
                                    mem[_29459 + 32] = 0
                                    _29568 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29568] = 0 / ext_call.return_data[0]
                                    mem[_29568 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33352 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33352] = 26
                                            mem[_33352 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33603 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33603] = 26
                                            mem[_33603 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28200 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28200] = 26
                                        mem[_28200 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31800 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31800] = 0
                                        mem[_31800 + 32] = 0
                                        _31983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31983] = 0 / ext_call.return_data[0]
                                        mem[_31983 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36049 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36049] = 26
                                                mem[_36049 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36246 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36246] = 26
                                                mem[_36246 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28463 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28463] = 26
                                        mem[_28463 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _32249 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32249] = 0
                                        mem[_32249 + 32] = 0
                                        _32417 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32417] = 0 / ext_call.return_data[0]
                                        mem[_32417 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36245 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36245] = 26
                                                mem[_36245 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36530 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36530] = 26
                                                mem[_36530 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
            else:
                if arg2 * totalStakingShares / totalStakingShares != arg2:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if arg2 * totalStakingShares / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25361 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25361] = 30
                            mem[_25361 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25383 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25383 + 68] = mem[idx + _25361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25383 + 68] = mem[_25383 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25383 + -mem[64] + 100
                        _25360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25360] = 30
                        mem[_25360 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25380 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25380 + 68] = mem[idx + _25360 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25380 + 68] = mem[_25380 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25380 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25575] = 26
                            mem[_25575 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25575 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25589 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25589] = 26
                            mem[_25589 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25589 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25359 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25359] = 26
                    mem[_25359 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25521 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25521] = 30
                    mem[_25521 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25707 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25707] = 30
                        mem[_25707 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25989] = 30
                            mem[_25989 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27330] = 0
                                    mem[_27330 + 32] = 0
                                    _27454 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27454] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27454 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30764 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30764] = 26
                                            mem[_30764 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31031 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31031] = 26
                                            mem[_31031 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26637 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26637] = 26
                                        mem[_26637 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29539 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29539] = 0
                                        mem[_29539 + 32] = 0
                                        _29690 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29690] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29690 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33453 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33453] = 26
                                                mem[_33453 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33744 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33744] = 26
                                                mem[_33744 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26725 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26725] = 26
                                        mem[_26725 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29814] = 0
                                        mem[_29814 + 32] = 0
                                        _29951 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29951] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29951 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33743 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33743] = 26
                                                mem[_33743 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34118 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34118] = 26
                                                mem[_34118 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27594 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27594] = 0
                                    mem[_27594 + 32] = 0
                                    _27711 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27711] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27711 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31029 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31029] = 26
                                            mem[_31029 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31349 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31349] = 26
                                            mem[_31349 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26723 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26723] = 26
                                        mem[_26723 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29813 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29813] = 0
                                        mem[_29813 + 32] = 0
                                        _29943 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29943] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29943 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33742 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33742] = 26
                                                mem[_33742 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34114 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34114] = 26
                                                mem[_34114 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26847 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26847] = 26
                                        mem[_26847 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30126 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30126] = 0
                                        mem[_30126 + 32] = 0
                                        _30246 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30246] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30246 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34113 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34113] = 26
                                                mem[_34113 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34559 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34559] = 26
                                                mem[_34559 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26007 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26007] = 30
                            mem[_26007 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27591 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27591] = 0
                                    mem[_27591 + 32] = 0
                                    _27702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27702] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27702 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31027 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31027] = 26
                                            mem[_31027 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31344 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31344] = 26
                                            mem[_31344 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26721 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26721] = 26
                                        mem[_26721 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29812 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29812] = 0
                                        mem[_29812 + 32] = 0
                                        _29935 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29935] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29935 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33741 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33741] = 26
                                                mem[_33741 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34109 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34109] = 26
                                                mem[_34109 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26843] = 26
                                        mem[_26843 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30124 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30124] = 0
                                        mem[_30124 + 32] = 0
                                        _30239 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30239] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30239 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34108 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34108] = 26
                                                mem[_34108 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34550 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34550] = 26
                                                mem[_34550 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27863 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27863] = 0
                                    mem[_27863 + 32] = 0
                                    _27949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27949] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27949 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31342 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31342] = 26
                                            mem[_31342 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31750 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31750] = 26
                                            mem[_31750 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26841 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26841] = 26
                                        mem[_26841 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30123 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30123] = 0
                                        mem[_30123 + 32] = 0
                                        _30231 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30231] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30231 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34107 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34107] = 26
                                                mem[_34107 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34546 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34546] = 26
                                                mem[_34546 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27051 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27051] = 26
                                        mem[_27051 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30447 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30447] = 0
                                        mem[_30447 + 32] = 0
                                        _30507 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30507] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30507 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34545 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34545] = 26
                                                mem[_34545 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34995 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34995] = 26
                                                mem[_34995 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25937 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25937] = 30
                        mem[_25937 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26173 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26173] = 30
                            mem[_26173 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _28790 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28790] = 0
                                    mem[_28790 + 32] = 0
                                    _28940 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28940] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_28940 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32795 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32795] = 26
                                            mem[_32795 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33111 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33111] = 26
                                            mem[_33111 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27719 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27719] = 26
                                        mem[_27719 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31039 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31039] = 0
                                        mem[_31039 + 32] = 0
                                        _31153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31153] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31153 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35598 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35598] = 26
                                                mem[_35598 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35856 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35856] = 26
                                                mem[_35856 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27968 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27968] = 26
                                        mem[_27968 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31362] = 0
                                        mem[_31362 + 32] = 0
                                        _31517 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31517] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31517 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35855 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35855] = 26
                                                mem[_35855 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36039 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36039] = 26
                                                mem[_36039 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29132 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29132] = 0
                                    mem[_29132 + 32] = 0
                                    _29254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29254] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29254 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33109] = 26
                                            mem[_33109 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33338] = 26
                                            mem[_33338 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27966] = 26
                                        mem[_27966 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31361] = 0
                                        mem[_31361 + 32] = 0
                                        _31509 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31509] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31509 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35854 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35854] = 26
                                                mem[_35854 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36035 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36035] = 26
                                                mem[_36035 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28176] = 26
                                        mem[_28176 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31775 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31775] = 0
                                        mem[_31775 + 32] = 0
                                        _31952 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31952] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31952 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36034 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36034] = 26
                                                mem[_36034 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36227 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36227] = 26
                                                mem[_36227 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26209 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26209] = 30
                            mem[_26209 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29129 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29129] = 0
                                    mem[_29129 + 32] = 0
                                    _29245 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29245] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29245 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33107 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33107] = 26
                                            mem[_33107 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33333 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33333] = 26
                                            mem[_33333 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27964 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27964] = 26
                                        mem[_27964 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31360] = 0
                                        mem[_31360 + 32] = 0
                                        _31501 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31501] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31501 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35853 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35853] = 26
                                                mem[_35853 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36030 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36030] = 26
                                                mem[_36030 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28172 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28172] = 26
                                        mem[_28172 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31773 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31773] = 0
                                        mem[_31773 + 32] = 0
                                        _31945 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31945] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31945 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36029 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36029] = 26
                                                mem[_36029 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36218 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36218] = 26
                                                mem[_36218 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29441] = 0
                                    mem[_29441 + 32] = 0
                                    _29544 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29544] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29544 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33331 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33331] = 26
                                            mem[_33331 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33574 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33574] = 26
                                            mem[_33574 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28170 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28170] = 26
                                        mem[_28170 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31772 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31772] = 0
                                        mem[_31772 + 32] = 0
                                        _31937 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31937] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31937 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36028 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36028] = 26
                                                mem[_36028 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36214 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36214] = 26
                                                mem[_36214 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28432 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28432] = 26
                                        mem[_28432 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _32220 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32220] = 0
                                        mem[_32220 + 32] = 0
                                        _32383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32383] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32383 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36213 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36213] = 26
                                                mem[_36213 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36495 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36495] = 26
                                                mem[_36495 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
    else:
        require ext_code.size(stor1)
        staticcall stor1.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'TokenGeyser: Invalid state. Staking shares exist, but no staking tokens do'
        if totalStakingShares <= 0:
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            if stor11 * arg2 / arg2 != stor11:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
            if stor11 * arg2 <= 0:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 0 == totalLockedShares:
                if ext_call.return_data[0] > 0:
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                if stor9 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor9:
                    if stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                    stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                stor9 = block.timestamp
                if stor12[msg.sender].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor12[msg.sender].field_512:
                    if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                stor12[msg.sender].field_512 = block.timestamp
                if 0 >= stor8:
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(arg1)].field_0 += stor11 * arg2
                    stor12[address(arg1)].field_512 = block.timestamp
                    stor13[address(arg1)].field_0++
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg2
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg2,
                                    0,
                                    96,
                                    0,
                                    mem[480],
                                    arg1,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                        else:
                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                else:
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                    if stor8 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require stor8
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(arg1)].field_0 += stor11 * arg2
                    stor12[address(arg1)].field_512 = block.timestamp
                    stor13[address(arg1)].field_0++
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg2
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg2,
                                    0,
                                    96,
                                    0,
                                    mem[544],
                                    arg1,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
                        else:
                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
            else:
                idx = 0
                while idx < unlockSchedules.length:
                    mem[0] = 14
                    if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                        idx = idx + 1
                        continue 
                    if block.timestamp >= unlockSchedules[idx].field_768:
                        _25376 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25376] = 30
                        mem[_25376 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                            unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                            if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                            if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        _25428 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25428 + 68] = mem[idx + _25376 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25428 + 68] = mem[_25428 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25428 + -mem[64] + 100
                    _25375 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25375] = 30
                    mem[_25375 + 32] = 'SafeMath: subtraction overflow'
                    if unlockSchedules[idx].field_512 > block.timestamp:
                        _25425 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25425 + 68] = mem[idx + _25375 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25425 + 68] = mem[_25425 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25425 + -mem[64] + 100
                    if not block.timestamp - unlockSchedules[idx].field_512:
                        _25580 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25580] = 26
                        mem[_25580 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                            if 0 / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25580 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25619 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25619] = 26
                        mem[_25619 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25619 + 32]
                            idx = idx + 32
                            continue 
                    revert with 0, 'SafeMath: division by zero'
                _25374 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25374] = 26
                mem[_25374 + 32] = 'SafeMath: division by zero'
                if totalLockedShares <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalLockedShares
                _25531 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25531] = 30
                mem[_25531 + 32] = 'SafeMath: subtraction overflow'
                if 0 > totalLockedShares:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 / totalLockedShares <= 0:
                    _25737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25737] = 30
                    mem[_25737 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _25994 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25994] = 30
                        mem[_25994 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27430 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27430] = 0
                                mem[_27430 + 32] = 0
                                _27579 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27579] = stor11 * arg2
                                mem[_27579 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _30859 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30859] = 26
                                        mem[_30859 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31116 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31116] = 26
                                        mem[_31116 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26647 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26647] = 26
                                    mem[_26647 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29659] = 0
                                    mem[_29659 + 32] = 0
                                    _29800 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29800] = stor11 * arg2
                                    mem[_29800 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33548 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33548] = 26
                                            mem[_33548 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33879 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33879] = 26
                                            mem[_33879 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26775] = 26
                                    mem[_26775 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29914] = 0
                                    mem[_29914 + 32] = 0
                                    _30111 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30111] = stor11 * arg2
                                    mem[_30111 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33878 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33878] = 26
                                            mem[_33878 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34298 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34298] = 26
                                            mem[_34298 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27684 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27684] = 0
                                mem[_27684 + 32] = 0
                                _27851 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27851] = stor11 * arg2
                                mem[_27851 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31114 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31114] = 26
                                        mem[_31114 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31464 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31464] = 26
                                        mem[_31464 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26773 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26773] = 26
                                    mem[_26773 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29913 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29913] = 0
                                    mem[_29913 + 32] = 0
                                    _30103 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30103] = stor11 * arg2
                                    mem[_30103 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33877 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33877] = 26
                                            mem[_33877 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34294 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34294] = 26
                                            mem[_34294 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26952] = 26
                                    mem[_26952 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30216 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30216] = 0
                                    mem[_30216 + 32] = 0
                                    _30426 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30426] = stor11 * arg2
                                    mem[_30426 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34293 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34293] = 26
                                            mem[_34293 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34764 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34764] = 26
                                            mem[_34764 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26037] = 30
                        mem[_26037 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27681 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27681] = 0
                                mem[_27681 + 32] = 0
                                _27842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27842] = stor11 * arg2
                                mem[_27842 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31112 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31112] = 26
                                        mem[_31112 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31459 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31459] = 26
                                        mem[_31459 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26771] = 26
                                    mem[_26771 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29912 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29912] = 0
                                    mem[_29912 + 32] = 0
                                    _30095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30095] = stor11 * arg2
                                    mem[_30095 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33876 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33876] = 26
                                            mem[_33876 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34289 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34289] = 26
                                            mem[_34289 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26948 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26948] = 26
                                    mem[_26948 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30214 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30214] = 0
                                    mem[_30214 + 32] = 0
                                    _30419 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30419] = stor11 * arg2
                                    mem[_30419 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34288] = 26
                                            mem[_34288 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34755 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34755] = 26
                                            mem[_34755 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _27933 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27933] = 0
                                mem[_27933 + 32] = 0
                                _28084 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28084] = stor11 * arg2
                                mem[_28084 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31457] = 26
                                        mem[_31457 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31890] = 26
                                        mem[_31890 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26946] = 26
                                    mem[_26946 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30213] = 0
                                    mem[_30213 + 32] = 0
                                    _30411 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30411] = stor11 * arg2
                                    mem[_30411 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34287 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34287] = 26
                                            mem[_34287 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34751 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34751] = 26
                                            mem[_34751 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _27171 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27171] = 26
                                    mem[_27171 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _30497 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30497] = 0
                                    mem[_30497 + 32] = 0
                                    _30647 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30647] = stor11 * arg2
                                    mem[_30647 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34750 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34750] = 26
                                            mem[_34750 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35190 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35190] = 26
                                            mem[_35190 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                else:
                    mem[mem[64] + 36] = 0 / totalLockedShares
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, 0 / totalLockedShares
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 32] = ext_call.return_data[0]
                    emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                    _25952 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25952] = 30
                    mem[_25952 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26198 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26198] = 30
                        mem[_26198 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _28910 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28910] = 0
                                mem[_28910 + 32] = 0
                                _29110 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29110] = stor11 * arg2
                                mem[_29110 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _32900 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32900] = 26
                                        mem[_32900 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33191 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33191] = 26
                                        mem[_33191 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _27859 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27859] = 26
                                    mem[_27859 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31124 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31124] = 0
                                    mem[_31124 + 32] = 0
                                    _31333 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31333] = stor11 * arg2
                                    mem[_31333 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35678 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35678] = 26
                                            mem[_35678 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35921 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35921] = 26
                                            mem[_35921 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28103 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28103] = 26
                                    mem[_28103 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31477 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31477] = 0
                                    mem[_31477 + 32] = 0
                                    _31742 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31742] = stor11 * arg2
                                    mem[_31742 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35920] = 26
                                            mem[_35920 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36144 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36144] = 26
                                            mem[_36144 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _29227 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29227] = 0
                                mem[_29227 + 32] = 0
                                _29419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29419] = stor11 * arg2
                                mem[_29419 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33189 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33189] = 26
                                        mem[_33189 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33443 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33443] = 26
                                        mem[_33443 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28101 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28101] = 26
                                    mem[_28101 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31476 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31476] = 0
                                    mem[_31476 + 32] = 0
                                    _31734 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31734] = stor11 * arg2
                                    mem[_31734 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35919 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35919] = 26
                                            mem[_35919 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36140 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36140] = 26
                                            mem[_36140 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28326 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28326] = 26
                                    mem[_28326 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31915 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31915] = 0
                                    mem[_31915 + 32] = 0
                                    _32182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32182] = stor11 * arg2
                                    mem[_32182 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36139 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36139] = 26
                                            mem[_36139 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36387 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36387] = 26
                                            mem[_36387 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26249 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26249] = 30
                        mem[_26249 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _29224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29224] = 0
                                mem[_29224 + 32] = 0
                                _29410 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29410] = stor11 * arg2
                                mem[_29410 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33187 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33187] = 26
                                        mem[_33187 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33438 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33438] = 26
                                        mem[_33438 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28099 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28099] = 26
                                    mem[_28099 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31475 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31475] = 0
                                    mem[_31475 + 32] = 0
                                    _31726 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31726] = stor11 * arg2
                                    mem[_31726 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35918 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35918] = 26
                                            mem[_35918 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36135 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36135] = 26
                                            mem[_36135 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28322] = 26
                                    mem[_28322 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31913 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31913] = 0
                                    mem[_31913 + 32] = 0
                                    _32175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32175] = stor11 * arg2
                                    mem[_32175 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36134 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36134] = 26
                                            mem[_36134 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36378 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36378] = 26
                                            mem[_36378 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = arg1
                                mem[32] = 12
                                if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(arg1)].field_0 += stor11 * arg2
                                stor12[address(arg1)].field_512 = block.timestamp
                                _29531 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29531] = 0
                                mem[_29531 + 32] = 0
                                _29664 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29664] = stor11 * arg2
                                mem[_29664 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(arg1)].field_0++
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg2
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg2
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg2,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                arg1,
                                else:
                                    mem[0] = arg1
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33436 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33436] = 26
                                        mem[_33436 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33719 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33719] = 26
                                        mem[_33719 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28320] = 26
                                    mem[_28320 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _31912 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31912] = 0
                                    mem[_31912 + 32] = 0
                                    _32167 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32167] = stor11 * arg2
                                    mem[_32167 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36133 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36133] = 26
                                            mem[_36133 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36374] = 26
                                            mem[_36374 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28587] = 26
                                    mem[_28587 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (stor11 * arg2) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += stor11 * arg2
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _32365 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32365] = 0
                                    mem[_32365 + 32] = 0
                                    _32553 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32553] = stor11 * arg2
                                    mem[_32553 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = stor11 * arg2
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg2) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg2
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36373 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36373] = 26
                                            mem[_36373 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36670 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36670] = 26
                                            mem[_36670 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
        else:
            require ext_code.size(stor1)
            staticcall stor1.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not totalStakingShares:
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if 0 / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25373 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25373] = 30
                            mem[_25373 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25419 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25419 + 68] = mem[idx + _25373 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25419 + 68] = mem[_25419 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25419 + -mem[64] + 100
                        _25372 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25372] = 30
                        mem[_25372 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25416 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25416 + 68] = mem[idx + _25372 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25416 + 68] = mem[_25416 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25416 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25579 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25579] = 26
                            mem[_25579 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25579 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25613 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25613] = 26
                            mem[_25613 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25613 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25371 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25371] = 26
                    mem[_25371 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25529 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25529] = 30
                    mem[_25529 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25731 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25731] = 30
                        mem[_25731 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25993 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25993] = 30
                            mem[_25993 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27410] = 0
                                    mem[_27410 + 32] = 0
                                    _27554 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27554] = 0 / ext_call.return_data[0]
                                    mem[_27554 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30840 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30840] = 26
                                            mem[_30840 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31099 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31099] = 26
                                            mem[_31099 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26645 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26645] = 26
                                        mem[_26645 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29635 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29635] = 0
                                        mem[_29635 + 32] = 0
                                        _29778 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29778] = 0 / ext_call.return_data[0]
                                        mem[_29778 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33529 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33529] = 26
                                                mem[_33529 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33852 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33852] = 26
                                                mem[_33852 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26765 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26765] = 26
                                        mem[_26765 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29894 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29894] = 0
                                        mem[_29894 + 32] = 0
                                        _30079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30079] = 0 / ext_call.return_data[0]
                                        mem[_30079 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33851 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33851] = 26
                                                mem[_33851 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34262 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34262] = 26
                                                mem[_34262 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27666 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27666] = 0
                                    mem[_27666 + 32] = 0
                                    _27823 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27823] = 0 / ext_call.return_data[0]
                                    mem[_27823 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31097 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31097] = 26
                                            mem[_31097 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31441 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31441] = 26
                                            mem[_31441 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26763 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26763] = 26
                                        mem[_26763 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29893 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29893] = 0
                                        mem[_29893 + 32] = 0
                                        _30071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30071] = 0 / ext_call.return_data[0]
                                        mem[_30071 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33850 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33850] = 26
                                                mem[_33850 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34258 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34258] = 26
                                                mem[_34258 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26931 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26931] = 26
                                        mem[_26931 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30198 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30198] = 0
                                        mem[_30198 + 32] = 0
                                        _30390 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30390] = 0 / ext_call.return_data[0]
                                        mem[_30390 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34257 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34257] = 26
                                                mem[_34257 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34723 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34723] = 26
                                                mem[_34723 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26031] = 30
                            mem[_26031 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27663 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27663] = 0
                                    mem[_27663 + 32] = 0
                                    _27814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27814] = 0 / ext_call.return_data[0]
                                    mem[_27814 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31095 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31095] = 26
                                            mem[_31095 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31436 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31436] = 26
                                            mem[_31436 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26761 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26761] = 26
                                        mem[_26761 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29892 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29892] = 0
                                        mem[_29892 + 32] = 0
                                        _30063 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30063] = 0 / ext_call.return_data[0]
                                        mem[_30063 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33849 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33849] = 26
                                                mem[_33849 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34253 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34253] = 26
                                                mem[_34253 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26927 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26927] = 26
                                        mem[_26927 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30196 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30196] = 0
                                        mem[_30196 + 32] = 0
                                        _30383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30383] = 0 / ext_call.return_data[0]
                                        mem[_30383 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34252 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34252] = 26
                                                mem[_34252 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34714 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34714] = 26
                                                mem[_34714 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27919] = 0
                                    mem[_27919 + 32] = 0
                                    _28057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28057] = 0 / ext_call.return_data[0]
                                    mem[_28057 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31434 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31434] = 26
                                            mem[_31434 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31862 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31862] = 26
                                            mem[_31862 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26925 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26925] = 26
                                        mem[_26925 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30195 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30195] = 0
                                        mem[_30195 + 32] = 0
                                        _30375 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30375] = 0 / ext_call.return_data[0]
                                        mem[_30375 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34251 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34251] = 26
                                                mem[_34251 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34710 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34710] = 26
                                                mem[_34710 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27147 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27147] = 26
                                        mem[_27147 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30487 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30487] = 0
                                        mem[_30487 + 32] = 0
                                        _30619 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30619] = 0 / ext_call.return_data[0]
                                        mem[_30619 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34709 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34709] = 26
                                                mem[_34709 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35151 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35151] = 26
                                                mem[_35151 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25949 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25949] = 30
                        mem[_25949 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26193 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26193] = 30
                            mem[_26193 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _28886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28886] = 0
                                    mem[_28886 + 32] = 0
                                    _29076 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29076] = 0 / ext_call.return_data[0]
                                    mem[_29076 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32879 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32879] = 26
                                            mem[_32879 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33175 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33175] = 26
                                            mem[_33175 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27831] = 26
                                        mem[_27831 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31107 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31107] = 0
                                        mem[_31107 + 32] = 0
                                        _31297 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31297] = 0 / ext_call.return_data[0]
                                        mem[_31297 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35662 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35662] = 26
                                                mem[_35662 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35908 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35908] = 26
                                                mem[_35908 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28076 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28076] = 26
                                        mem[_28076 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31454 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31454] = 0
                                        mem[_31454 + 32] = 0
                                        _31697 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31697] = 0 / ext_call.return_data[0]
                                        mem[_31697 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35907 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35907] = 26
                                                mem[_35907 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36123 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36123] = 26
                                                mem[_36123 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29208] = 0
                                    mem[_29208 + 32] = 0
                                    _29386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29386] = 0 / ext_call.return_data[0]
                                    mem[_29386 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33173 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33173] = 26
                                            mem[_33173 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33422 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33422] = 26
                                            mem[_33422 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28074] = 26
                                        mem[_28074 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31453 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31453] = 0
                                        mem[_31453 + 32] = 0
                                        _31689 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31689] = 0 / ext_call.return_data[0]
                                        mem[_31689 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35906 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35906] = 26
                                                mem[_35906 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36119 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36119] = 26
                                                mem[_36119 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28296 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28296] = 26
                                        mem[_28296 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31887 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31887] = 0
                                        mem[_31887 + 32] = 0
                                        _32136 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32136] = 0 / ext_call.return_data[0]
                                        mem[_32136 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36118 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36118] = 26
                                                mem[_36118 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36355 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36355] = 26
                                                mem[_36355 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26241 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26241] = 30
                            mem[_26241 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29205 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29205] = 0
                                    mem[_29205 + 32] = 0
                                    _29377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29377] = 0 / ext_call.return_data[0]
                                    mem[_29377 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33171] = 26
                                            mem[_33171 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33417 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33417] = 26
                                            mem[_33417 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28072 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28072] = 26
                                        mem[_28072 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31452 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31452] = 0
                                        mem[_31452 + 32] = 0
                                        _31681 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31681] = 0 / ext_call.return_data[0]
                                        mem[_31681 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35905 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35905] = 26
                                                mem[_35905 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36114 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36114] = 26
                                                mem[_36114 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28292 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28292] = 26
                                        mem[_28292 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31885 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31885] = 0
                                        mem[_31885 + 32] = 0
                                        _32129 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32129] = 0 / ext_call.return_data[0]
                                        mem[_32129 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36113 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36113] = 26
                                                mem[_36113 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36346 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36346] = 26
                                                mem[_36346 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29513 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29513] = 0
                                    mem[_29513 + 32] = 0
                                    _29640 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29640] = 0 / ext_call.return_data[0]
                                    mem[_29640 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33415 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33415] = 26
                                            mem[_33415 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33690 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33690] = 26
                                            mem[_33690 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28290] = 26
                                        mem[_28290 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31884 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31884] = 0
                                        mem[_31884 + 32] = 0
                                        _32121 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32121] = 0 / ext_call.return_data[0]
                                        mem[_32121 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36112 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36112] = 26
                                                mem[_36112 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36342 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36342] = 26
                                                mem[_36342 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28556] = 26
                                        mem[_28556 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _32336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32336] = 0
                                        mem[_32336 + 32] = 0
                                        _32519 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32519] = 0 / ext_call.return_data[0]
                                        mem[_32519 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36341 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36341] = 26
                                                mem[_36341 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36635 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36635] = 26
                                                mem[_36635 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
            else:
                if arg2 * totalStakingShares / totalStakingShares != arg2:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if arg2 * totalStakingShares / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            arg1,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(arg1)].field_512 = block.timestamp
                        stor13[address(arg1)].field_0++
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg2
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg2,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        arg1,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                            else:
                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg2,
                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            arg1,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25370 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25370] = 30
                            mem[_25370 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25410 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25410 + 68] = mem[idx + _25370 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25410 + 68] = mem[_25410 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25410 + -mem[64] + 100
                        _25369 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25369] = 30
                        mem[_25369 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25407 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25407 + 68] = mem[idx + _25369 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25407 + 68] = mem[_25407 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25407 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25578 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25578] = 26
                            mem[_25578 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25578 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25607 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25607] = 26
                            mem[_25607 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25607 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25368 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25368] = 26
                    mem[_25368 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25527] = 30
                    mem[_25527 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25725 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25725] = 30
                        mem[_25725 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25992] = 30
                            mem[_25992 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27390 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27390] = 0
                                    mem[_27390 + 32] = 0
                                    _27529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27529] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27529 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30821 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30821] = 26
                                            mem[_30821 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31082 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31082] = 26
                                            mem[_31082 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26643 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26643] = 26
                                        mem[_26643 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29611 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29611] = 0
                                        mem[_29611 + 32] = 0
                                        _29756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29756] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29756 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33510 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33510] = 26
                                                mem[_33510 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33825 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33825] = 26
                                                mem[_33825 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26755 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26755] = 26
                                        mem[_26755 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29874 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29874] = 0
                                        mem[_29874 + 32] = 0
                                        _30047 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30047] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30047 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33824 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33824] = 26
                                                mem[_33824 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34226 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34226] = 26
                                                mem[_34226 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27648 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27648] = 0
                                    mem[_27648 + 32] = 0
                                    _27795 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27795] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27795 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31080 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31080] = 26
                                            mem[_31080 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31418 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31418] = 26
                                            mem[_31418 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26753 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26753] = 26
                                        mem[_26753 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29873 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29873] = 0
                                        mem[_29873 + 32] = 0
                                        _30039 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30039] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30039 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33823 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33823] = 26
                                                mem[_33823 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34222 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34222] = 26
                                                mem[_34222 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26910] = 26
                                        mem[_26910 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30180 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30180] = 0
                                        mem[_30180 + 32] = 0
                                        _30354 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30354] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30354 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34221 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34221] = 26
                                                mem[_34221 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34682 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34682] = 26
                                                mem[_34682 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26025 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26025] = 30
                            mem[_26025 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27645 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27645] = 0
                                    mem[_27645 + 32] = 0
                                    _27786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27786] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27786 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31078] = 26
                                            mem[_31078 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31413 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31413] = 26
                                            mem[_31413 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26751 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26751] = 26
                                        mem[_26751 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _29872 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29872] = 0
                                        mem[_29872 + 32] = 0
                                        _30031 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30031] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30031 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33822 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33822] = 26
                                                mem[_33822 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34217 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34217] = 26
                                                mem[_34217 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26906 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26906] = 26
                                        mem[_26906 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30178 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30178] = 0
                                        mem[_30178 + 32] = 0
                                        _30347 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30347] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30347 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34216 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34216] = 26
                                                mem[_34216 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34673 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34673] = 26
                                                mem[_34673 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _27905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27905] = 0
                                    mem[_27905 + 32] = 0
                                    _28030 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28030] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_28030 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31411 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31411] = 26
                                            mem[_31411 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31834 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31834] = 26
                                            mem[_31834 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26904 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26904] = 26
                                        mem[_26904 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30177] = 0
                                        mem[_30177 + 32] = 0
                                        _30339 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30339] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30339 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34215 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34215] = 26
                                                mem[_34215 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34669 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34669] = 26
                                                mem[_34669 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27123 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27123] = 26
                                        mem[_27123 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _30477 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30477] = 0
                                        mem[_30477 + 32] = 0
                                        _30591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30591] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30591 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34668 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34668] = 26
                                                mem[_34668 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35112 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35112] = 26
                                                mem[_35112 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25946 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25946] = 30
                        mem[_25946 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26188] = 30
                            mem[_26188 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _28862 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28862] = 0
                                    mem[_28862 + 32] = 0
                                    _29042 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29042] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29042 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32858 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32858] = 26
                                            mem[_32858 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33159 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33159] = 26
                                            mem[_33159 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27803 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27803] = 26
                                        mem[_27803 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31090] = 0
                                        mem[_31090 + 32] = 0
                                        _31261 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31261] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31261 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35646 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35646] = 26
                                                mem[_35646 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35895 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35895] = 26
                                                mem[_35895 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28049 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28049] = 26
                                        mem[_28049 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31431 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31431] = 0
                                        mem[_31431 + 32] = 0
                                        _31652 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31652] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31652 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35894 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35894] = 26
                                                mem[_35894 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36102 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36102] = 26
                                                mem[_36102 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29189 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29189] = 0
                                    mem[_29189 + 32] = 0
                                    _29353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29353] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29353 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33157 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33157] = 26
                                            mem[_33157 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33401 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33401] = 26
                                            mem[_33401 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28047 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28047] = 26
                                        mem[_28047 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31430] = 0
                                        mem[_31430 + 32] = 0
                                        _31644 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31644] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31644 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35893 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35893] = 26
                                                mem[_35893 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36098 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36098] = 26
                                                mem[_36098 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28266 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28266] = 26
                                        mem[_28266 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31859 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31859] = 0
                                        mem[_31859 + 32] = 0
                                        _32090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32090] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32090 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36097 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36097] = 26
                                                mem[_36097 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36323 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36323] = 26
                                                mem[_36323 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26233 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26233] = 30
                            mem[_26233 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29186 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29186] = 0
                                    mem[_29186 + 32] = 0
                                    _29344 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29344] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29344 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33155 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33155] = 26
                                            mem[_33155 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33396 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33396] = 26
                                            mem[_33396 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28045 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28045] = 26
                                        mem[_28045 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31429 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31429] = 0
                                        mem[_31429 + 32] = 0
                                        _31636 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31636] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31636 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35892 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35892] = 26
                                                mem[_35892 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36093 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36093] = 26
                                                mem[_36093 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28262 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28262] = 26
                                        mem[_28262 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31857] = 0
                                        mem[_31857 + 32] = 0
                                        _32083 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32083] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32083 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36092 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36092] = 26
                                                mem[_36092 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36314 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36314] = 26
                                                mem[_36314 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = arg1
                                    mem[32] = 12
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(arg1)].field_512 = block.timestamp
                                    _29495 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29495] = 0
                                    mem[_29495 + 32] = 0
                                    _29616 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29616] = arg2 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29616 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(arg1)].field_0++
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                    if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg2
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg2,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    arg1,
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33394 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33394] = 26
                                            mem[_33394 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33661 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33661] = 26
                                            mem[_33661 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28260 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28260] = 26
                                        mem[_28260 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _31856 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31856] = 0
                                        mem[_31856 + 32] = 0
                                        _32075 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32075] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32075 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36091 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36091] = 26
                                                mem[_36091 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36310 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36310] = 26
                                                mem[_36310 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28525 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28525] = 26
                                        mem[_28525 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = arg1
                                        mem[32] = 12
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + stor12[address(arg1)].field_0 < stor12[address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(arg1)].field_0 += arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(arg1)].field_512 = block.timestamp
                                        _32307 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32307] = 0
                                        mem[_32307 + 32] = 0
                                        _32485 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32485] = arg2 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32485 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(arg1)].field_0++
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_0 = arg2 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(arg1)][stor13[address(arg1)].field_0].field_256 = block.timestamp
                                        if (arg2 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg2 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg2
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg2,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        arg1,
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36309 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36309] = 26
                                                mem[_36309 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
                                            else:
                                                if stor12[address(arg1)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36600 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36600] = 26
                                                mem[_36600 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg2,
                                                            stor12[address(arg1)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            arg1,
}

function stake(uint256 arg1, bytes arg2) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    if arg1 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: stake amount is zero'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: beneficiary is zero address'
    if not totalStakingShares:
        if totalStakingShares <= 0:
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            if stor11 * arg1 / arg1 != stor11:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
            if stor11 * arg1 <= 0:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 0 == totalLockedShares:
                if ext_call.return_data[0] > 0:
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                if stor9 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor9:
                    if stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                    stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                stor9 = block.timestamp
                if stor12[msg.sender].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor12[msg.sender].field_512:
                    if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                stor12[msg.sender].field_512 = block.timestamp
                if 0 >= stor8:
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                    stor12[address(msg.sender)].field_512 = block.timestamp
                    stor13[address(msg.sender)].field_0++
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg1
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg1,
                                    0,
                                    96,
                                    0,
                                    mem[480],
                                    msg.sender,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                        else:
                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                else:
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                    if stor8 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require stor8
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                    stor12[address(msg.sender)].field_512 = block.timestamp
                    stor13[address(msg.sender)].field_0++
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg1
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg1,
                                    0,
                                    96,
                                    0,
                                    mem[544],
                                    msg.sender,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
                        else:
                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
            else:
                idx = 0
                while idx < unlockSchedules.length:
                    mem[0] = 14
                    if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                        idx = idx + 1
                        continue 
                    if block.timestamp >= unlockSchedules[idx].field_768:
                        _25363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25363] = 30
                        mem[_25363 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                            unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                            if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                            if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        _25397 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25397 + 68] = mem[idx + _25363 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25397 + 68] = mem[_25397 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25397 + -mem[64] + 100
                    _25362 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25362] = 30
                    mem[_25362 + 32] = 'SafeMath: subtraction overflow'
                    if unlockSchedules[idx].field_512 > block.timestamp:
                        _25394 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25394 + 68] = mem[idx + _25362 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25394 + 68] = mem[_25394 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25394 + -mem[64] + 100
                    if not block.timestamp - unlockSchedules[idx].field_512:
                        _25573 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25573] = 26
                        mem[_25573 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                            if 0 / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25573 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25597] = 26
                        mem[_25597 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25597 + 32]
                            idx = idx + 32
                            continue 
                    revert with 0, 'SafeMath: division by zero'
                _25361 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25361] = 26
                mem[_25361 + 32] = 'SafeMath: division by zero'
                if totalLockedShares <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalLockedShares
                _25521 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25521] = 30
                mem[_25521 + 32] = 'SafeMath: subtraction overflow'
                if 0 > totalLockedShares:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 / totalLockedShares <= 0:
                    _25715 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25715] = 30
                    mem[_25715 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _25987 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25987] = 30
                        mem[_25987 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27366 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27366] = 0
                                mem[_27366 + 32] = 0
                                _27500 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27500] = stor11 * arg1
                                mem[_27500 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _30798 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30798] = 26
                                        mem[_30798 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31061] = 26
                                        mem[_31061 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26637 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26637] = 26
                                    mem[_26637 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29583] = 0
                                    mem[_29583 + 32] = 0
                                    _29730 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29730] = stor11 * arg1
                                    mem[_29730 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33487 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33487] = 26
                                            mem[_33487 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33794 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33794] = 26
                                            mem[_33794 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26741] = 26
                                    mem[_26741 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29850 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29850] = 0
                                    mem[_29850 + 32] = 0
                                    _30011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30011] = stor11 * arg1
                                    mem[_30011 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33793 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33793] = 26
                                            mem[_33793 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34186 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34186] = 26
                                            mem[_34186 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27626 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27626] = 0
                                mem[_27626 + 32] = 0
                                _27763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27763] = stor11 * arg1
                                mem[_27763 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31059 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31059] = 26
                                        mem[_31059 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31391 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31391] = 26
                                        mem[_31391 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26739] = 26
                                    mem[_26739 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29849 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29849] = 0
                                    mem[_29849 + 32] = 0
                                    _30003 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30003] = stor11 * arg1
                                    mem[_30003 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33792 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33792] = 26
                                            mem[_33792 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34182 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34182] = 26
                                            mem[_34182 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26885] = 26
                                    mem[_26885 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30158 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30158] = 0
                                    mem[_30158 + 32] = 0
                                    _30314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30314] = stor11 * arg1
                                    mem[_30314 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34181] = 26
                                            mem[_34181 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34637 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34637] = 26
                                            mem[_34637 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26015 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26015] = 30
                        mem[_26015 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27623 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27623] = 0
                                mem[_27623 + 32] = 0
                                _27754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27754] = stor11 * arg1
                                mem[_27754 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31057 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31057] = 26
                                        mem[_31057 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31386] = 26
                                        mem[_31386 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26737] = 26
                                    mem[_26737 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29848 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29848] = 0
                                    mem[_29848 + 32] = 0
                                    _29995 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29995] = stor11 * arg1
                                    mem[_29995 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33791 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33791] = 26
                                            mem[_33791 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34177 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34177] = 26
                                            mem[_34177 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26881 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26881] = 26
                                    mem[_26881 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30156 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30156] = 0
                                    mem[_30156 + 32] = 0
                                    _30307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30307] = stor11 * arg1
                                    mem[_30307 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34176] = 26
                                            mem[_34176 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34628 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34628] = 26
                                            mem[_34628 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27887] = 0
                                mem[_27887 + 32] = 0
                                _27999 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27999] = stor11 * arg1
                                mem[_27999 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31384] = 26
                                        mem[_31384 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31802 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31802] = 26
                                        mem[_31802 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26879 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26879] = 26
                                    mem[_26879 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30155 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30155] = 0
                                    mem[_30155 + 32] = 0
                                    _30299 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30299] = stor11 * arg1
                                    mem[_30299 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34175 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34175] = 26
                                            mem[_34175 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34624 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34624] = 26
                                            mem[_34624 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _27095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27095] = 26
                                    mem[_27095 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30463 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30463] = 0
                                    mem[_30463 + 32] = 0
                                    _30559 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30559] = stor11 * arg1
                                    mem[_30559 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34623 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34623] = 26
                                            mem[_34623 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35069 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35069] = 26
                                            mem[_35069 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                else:
                    mem[mem[64] + 36] = 0 / totalLockedShares
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, 0 / totalLockedShares
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 32] = ext_call.return_data[0]
                    emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                    _25939 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25939] = 30
                    mem[_25939 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26179 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26179] = 30
                        mem[_26179 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _28834 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28834] = 0
                                mem[_28834 + 32] = 0
                                _29004 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29004] = stor11 * arg1
                                mem[_29004 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _32833 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32833] = 26
                                        mem[_32833 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33139 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33139] = 26
                                        mem[_33139 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _27771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27771] = 26
                                    mem[_27771 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31069 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31069] = 0
                                    mem[_31069 + 32] = 0
                                    _31221 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31221] = stor11 * arg1
                                    mem[_31221 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35626 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35626] = 26
                                            mem[_35626 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35878 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35878] = 26
                                            mem[_35878 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28018 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28018] = 26
                                    mem[_28018 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31404 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31404] = 0
                                    mem[_31404 + 32] = 0
                                    _31603 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31603] = stor11 * arg1
                                    mem[_31603 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35877 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35877] = 26
                                            mem[_35877 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36077 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36077] = 26
                                            mem[_36077 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _29166 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29166] = 0
                                mem[_29166 + 32] = 0
                                _29316 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29316] = stor11 * arg1
                                mem[_29316 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33137] = 26
                                        mem[_33137 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33376 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33376] = 26
                                        mem[_33376 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28016 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28016] = 26
                                    mem[_28016 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31403] = 0
                                    mem[_31403 + 32] = 0
                                    _31595 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31595] = stor11 * arg1
                                    mem[_31595 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35876 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35876] = 26
                                            mem[_35876 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36073 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36073] = 26
                                            mem[_36073 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28232 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28232] = 26
                                    mem[_28232 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31827] = 0
                                    mem[_31827 + 32] = 0
                                    _32040 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32040] = stor11 * arg1
                                    mem[_32040 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36072 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36072] = 26
                                            mem[_36072 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36287 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36287] = 26
                                            mem[_36287 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26221 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26221] = 30
                        mem[_26221 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _29163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29163] = 0
                                mem[_29163 + 32] = 0
                                _29307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29307] = stor11 * arg1
                                mem[_29307 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33135 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33135] = 26
                                        mem[_33135 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33371] = 26
                                        mem[_33371 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28014] = 26
                                    mem[_28014 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31402 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31402] = 0
                                    mem[_31402 + 32] = 0
                                    _31587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31587] = stor11 * arg1
                                    mem[_31587 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35875 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35875] = 26
                                            mem[_35875 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36068 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36068] = 26
                                            mem[_36068 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28228 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28228] = 26
                                    mem[_28228 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31825 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31825] = 0
                                    mem[_31825 + 32] = 0
                                    _32033 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32033] = stor11 * arg1
                                    mem[_32033 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36067 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36067] = 26
                                            mem[_36067 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36278 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36278] = 26
                                            mem[_36278 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _29473 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29473] = 0
                                mem[_29473 + 32] = 0
                                _29588 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29588] = stor11 * arg1
                                mem[_29588 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33369 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33369] = 26
                                        mem[_33369 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33628 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33628] = 26
                                        mem[_33628 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28226 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28226] = 26
                                    mem[_28226 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31824 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31824] = 0
                                    mem[_31824 + 32] = 0
                                    _32025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32025] = stor11 * arg1
                                    mem[_32025 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36066 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36066] = 26
                                            mem[_36066 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36274 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36274] = 26
                                            mem[_36274 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28490 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28490] = 26
                                    mem[_28490 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _32274 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32274] = 0
                                    mem[_32274 + 32] = 0
                                    _32447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32447] = stor11 * arg1
                                    mem[_32447 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36273 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36273] = 26
                                            mem[_36273 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36561 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36561] = 26
                                            mem[_36561 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
        else:
            require ext_code.size(stor1)
            staticcall stor1.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not totalStakingShares:
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if 0 / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25360 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25360] = 30
                            mem[_25360 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25388 + 68] = mem[idx + _25360 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25388 + 68] = mem[_25388 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25388 + -mem[64] + 100
                        _25359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25359] = 30
                        mem[_25359 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25385 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25385 + 68] = mem[idx + _25359 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25385 + 68] = mem[_25385 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25385 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25572 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25572] = 26
                            mem[_25572 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25572 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25591 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25591] = 26
                            mem[_25591 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25591 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25358 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25358] = 26
                    mem[_25358 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25519 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25519] = 30
                    mem[_25519 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25709 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25709] = 30
                        mem[_25709 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25986 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25986] = 30
                            mem[_25986 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27346 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27346] = 0
                                    mem[_27346 + 32] = 0
                                    _27475 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27475] = 0 / ext_call.return_data[0]
                                    mem[_27475 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30779 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30779] = 26
                                            mem[_30779 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31044 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31044] = 26
                                            mem[_31044 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26635 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26635] = 26
                                        mem[_26635 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29559 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29559] = 0
                                        mem[_29559 + 32] = 0
                                        _29708 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29708] = 0 / ext_call.return_data[0]
                                        mem[_29708 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33468 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33468] = 26
                                                mem[_33468 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33767 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33767] = 26
                                                mem[_33767 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26731] = 26
                                        mem[_26731 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29830 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29830] = 0
                                        mem[_29830 + 32] = 0
                                        _29979 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29979] = 0 / ext_call.return_data[0]
                                        mem[_29979 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33766 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33766] = 26
                                                mem[_33766 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34150 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34150] = 26
                                                mem[_34150 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27608 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27608] = 0
                                    mem[_27608 + 32] = 0
                                    _27735 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27735] = 0 / ext_call.return_data[0]
                                    mem[_27735 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31042 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31042] = 26
                                            mem[_31042 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31368] = 26
                                            mem[_31368 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26729 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26729] = 26
                                        mem[_26729 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29829] = 0
                                        mem[_29829 + 32] = 0
                                        _29971 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29971] = 0 / ext_call.return_data[0]
                                        mem[_29971 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33765 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33765] = 26
                                                mem[_33765 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34146 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34146] = 26
                                                mem[_34146 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26864 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26864] = 26
                                        mem[_26864 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30140 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30140] = 0
                                        mem[_30140 + 32] = 0
                                        _30278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30278] = 0 / ext_call.return_data[0]
                                        mem[_30278 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34145 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34145] = 26
                                                mem[_34145 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34596 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34596] = 26
                                                mem[_34596 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26009] = 30
                            mem[_26009 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27605] = 0
                                    mem[_27605 + 32] = 0
                                    _27726 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27726] = 0 / ext_call.return_data[0]
                                    mem[_27726 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31040 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31040] = 26
                                            mem[_31040 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31363 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31363] = 26
                                            mem[_31363 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26727 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26727] = 26
                                        mem[_26727 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29828 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29828] = 0
                                        mem[_29828 + 32] = 0
                                        _29963 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29963] = 0 / ext_call.return_data[0]
                                        mem[_29963 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33764 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33764] = 26
                                                mem[_33764 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34141 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34141] = 26
                                                mem[_34141 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26860 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26860] = 26
                                        mem[_26860 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30138 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30138] = 0
                                        mem[_30138 + 32] = 0
                                        _30271 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30271] = 0 / ext_call.return_data[0]
                                        mem[_30271 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34140 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34140] = 26
                                                mem[_34140 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34587 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34587] = 26
                                                mem[_34587 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27873] = 0
                                    mem[_27873 + 32] = 0
                                    _27972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27972] = 0 / ext_call.return_data[0]
                                    mem[_27972 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31361 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31361] = 26
                                            mem[_31361 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31774 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31774] = 26
                                            mem[_31774 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26858 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26858] = 26
                                        mem[_26858 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30137] = 0
                                        mem[_30137 + 32] = 0
                                        _30263 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30263] = 0 / ext_call.return_data[0]
                                        mem[_30263 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34139 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34139] = 26
                                                mem[_34139 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34583 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34583] = 26
                                                mem[_34583 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27071] = 26
                                        mem[_27071 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30453 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30453] = 0
                                        mem[_30453 + 32] = 0
                                        _30531 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30531] = 0 / ext_call.return_data[0]
                                        mem[_30531 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34582 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34582] = 26
                                                mem[_34582 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35030 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35030] = 26
                                                mem[_35030 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25936 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25936] = 30
                        mem[_25936 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26174 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26174] = 30
                            mem[_26174 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _28810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28810] = 0
                                    mem[_28810 + 32] = 0
                                    _28970 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28970] = 0 / ext_call.return_data[0]
                                    mem[_28970 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32812 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32812] = 26
                                            mem[_32812 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33123 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33123] = 26
                                            mem[_33123 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27743 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27743] = 26
                                        mem[_27743 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31052 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31052] = 0
                                        mem[_31052 + 32] = 0
                                        _31185 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31185] = 0 / ext_call.return_data[0]
                                        mem[_31185 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35610 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35610] = 26
                                                mem[_35610 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35865 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35865] = 26
                                                mem[_35865 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27991 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27991] = 26
                                        mem[_27991 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31381 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31381] = 0
                                        mem[_31381 + 32] = 0
                                        _31558 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31558] = 0 / ext_call.return_data[0]
                                        mem[_31558 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35864 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35864] = 26
                                                mem[_35864 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36056 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36056] = 26
                                                mem[_36056 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29147] = 0
                                    mem[_29147 + 32] = 0
                                    _29283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29283] = 0 / ext_call.return_data[0]
                                    mem[_29283 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33121 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33121] = 26
                                            mem[_33121 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33355 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33355] = 26
                                            mem[_33355 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27989 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27989] = 26
                                        mem[_27989 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31380] = 0
                                        mem[_31380 + 32] = 0
                                        _31550 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31550] = 0 / ext_call.return_data[0]
                                        mem[_31550 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35863 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35863] = 26
                                                mem[_35863 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36052 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36052] = 26
                                                mem[_36052 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28202 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28202] = 26
                                        mem[_28202 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31799 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31799] = 0
                                        mem[_31799 + 32] = 0
                                        _31994 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31994] = 0 / ext_call.return_data[0]
                                        mem[_31994 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36051 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36051] = 26
                                                mem[_36051 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36255 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36255] = 26
                                                mem[_36255 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26213 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26213] = 30
                            mem[_26213 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29144] = 0
                                    mem[_29144 + 32] = 0
                                    _29274 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29274] = 0 / ext_call.return_data[0]
                                    mem[_29274 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33119 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33119] = 26
                                            mem[_33119 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33350 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33350] = 26
                                            mem[_33350 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27987 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27987] = 26
                                        mem[_27987 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31379] = 0
                                        mem[_31379 + 32] = 0
                                        _31542 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31542] = 0 / ext_call.return_data[0]
                                        mem[_31542 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35862 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35862] = 26
                                                mem[_35862 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36047 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36047] = 26
                                                mem[_36047 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28198 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28198] = 26
                                        mem[_28198 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31797 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31797] = 0
                                        mem[_31797 + 32] = 0
                                        _31987 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31987] = 0 / ext_call.return_data[0]
                                        mem[_31987 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36046 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36046] = 26
                                                mem[_36046 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36246 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36246] = 26
                                                mem[_36246 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29455] = 0
                                    mem[_29455 + 32] = 0
                                    _29564 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29564] = 0 / ext_call.return_data[0]
                                    mem[_29564 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33348 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33348] = 26
                                            mem[_33348 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33599] = 26
                                            mem[_33599 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28196 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28196] = 26
                                        mem[_28196 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31796 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31796] = 0
                                        mem[_31796 + 32] = 0
                                        _31979 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31979] = 0 / ext_call.return_data[0]
                                        mem[_31979 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36045 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36045] = 26
                                                mem[_36045 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36242 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36242] = 26
                                                mem[_36242 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28459 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28459] = 26
                                        mem[_28459 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _32245 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32245] = 0
                                        mem[_32245 + 32] = 0
                                        _32413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32413] = 0 / ext_call.return_data[0]
                                        mem[_32413 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36241 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36241] = 26
                                                mem[_36241 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36526 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36526] = 26
                                                mem[_36526 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
            else:
                if arg1 * totalStakingShares / totalStakingShares != arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if arg1 * totalStakingShares / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25357 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25357] = 30
                            mem[_25357 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25379 + 68] = mem[idx + _25357 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25379 + 68] = mem[_25379 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25379 + -mem[64] + 100
                        _25356 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25356] = 30
                        mem[_25356 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25376 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25376 + 68] = mem[idx + _25356 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25376 + 68] = mem[_25376 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25376 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25571] = 26
                            mem[_25571 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25571 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25585] = 26
                            mem[_25585 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25585 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25355 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25355] = 26
                    mem[_25355 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25517 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25517] = 30
                    mem[_25517 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25703] = 30
                        mem[_25703 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25985 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25985] = 30
                            mem[_25985 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27326 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27326] = 0
                                    mem[_27326 + 32] = 0
                                    _27450 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27450] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27450 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30760 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30760] = 26
                                            mem[_30760 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31027 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31027] = 26
                                            mem[_31027 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26633 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26633] = 26
                                        mem[_26633 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29535] = 0
                                        mem[_29535 + 32] = 0
                                        _29686 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29686] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29686 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33449 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33449] = 26
                                                mem[_33449 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33740 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33740] = 26
                                                mem[_33740 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26721 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26721] = 26
                                        mem[_26721 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29810 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29810] = 0
                                        mem[_29810 + 32] = 0
                                        _29947 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29947] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29947 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33739 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33739] = 26
                                                mem[_33739 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34114 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34114] = 26
                                                mem[_34114 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27590 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27590] = 0
                                    mem[_27590 + 32] = 0
                                    _27707 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27707] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27707 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31025 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31025] = 26
                                            mem[_31025 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31345 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31345] = 26
                                            mem[_31345 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26719 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26719] = 26
                                        mem[_26719 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29809 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29809] = 0
                                        mem[_29809 + 32] = 0
                                        _29939 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29939] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29939 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33738 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33738] = 26
                                                mem[_33738 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34110 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34110] = 26
                                                mem[_34110 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26843] = 26
                                        mem[_26843 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30122 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30122] = 0
                                        mem[_30122 + 32] = 0
                                        _30242 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30242] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30242 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34109 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34109] = 26
                                                mem[_34109 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34555 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34555] = 26
                                                mem[_34555 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26003 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26003] = 30
                            mem[_26003 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27587] = 0
                                    mem[_27587 + 32] = 0
                                    _27698 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27698] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27698 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31023 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31023] = 26
                                            mem[_31023 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31340 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31340] = 26
                                            mem[_31340 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26717 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26717] = 26
                                        mem[_26717 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29808 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29808] = 0
                                        mem[_29808 + 32] = 0
                                        _29931 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29931] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29931 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33737 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33737] = 26
                                                mem[_33737 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34105 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34105] = 26
                                                mem[_34105 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26839 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26839] = 26
                                        mem[_26839 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30120] = 0
                                        mem[_30120 + 32] = 0
                                        _30235 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30235] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30235 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34104 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34104] = 26
                                                mem[_34104 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34546 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34546] = 26
                                                mem[_34546 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27859 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27859] = 0
                                    mem[_27859 + 32] = 0
                                    _27945 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27945] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27945 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31338] = 26
                                            mem[_31338 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31746 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31746] = 26
                                            mem[_31746 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26837 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26837] = 26
                                        mem[_26837 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30119 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30119] = 0
                                        mem[_30119 + 32] = 0
                                        _30227 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30227] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30227 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34103 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34103] = 26
                                                mem[_34103 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34542 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34542] = 26
                                                mem[_34542 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27047 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27047] = 26
                                        mem[_27047 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30443 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30443] = 0
                                        mem[_30443 + 32] = 0
                                        _30503 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30503] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30503 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34541 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34541] = 26
                                                mem[_34541 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34991 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34991] = 26
                                                mem[_34991 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25933 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25933] = 30
                        mem[_25933 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26169 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26169] = 30
                            mem[_26169 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _28786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28786] = 0
                                    mem[_28786 + 32] = 0
                                    _28936 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28936] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_28936 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32791 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32791] = 26
                                            mem[_32791 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33107 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33107] = 26
                                            mem[_33107 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27715 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27715] = 26
                                        mem[_27715 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31035 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31035] = 0
                                        mem[_31035 + 32] = 0
                                        _31149 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31149] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31149 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35594 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35594] = 26
                                                mem[_35594 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35852 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35852] = 26
                                                mem[_35852 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27964 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27964] = 26
                                        mem[_27964 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31358 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31358] = 0
                                        mem[_31358 + 32] = 0
                                        _31513 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31513] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31513 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35851 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35851] = 26
                                                mem[_35851 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36035 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36035] = 26
                                                mem[_36035 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29128] = 0
                                    mem[_29128 + 32] = 0
                                    _29250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29250] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29250 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33105 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33105] = 26
                                            mem[_33105 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33334 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33334] = 26
                                            mem[_33334 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27962 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27962] = 26
                                        mem[_27962 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31357 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31357] = 0
                                        mem[_31357 + 32] = 0
                                        _31505 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31505] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31505 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35850 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35850] = 26
                                                mem[_35850 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36031 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36031] = 26
                                                mem[_36031 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28172 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28172] = 26
                                        mem[_28172 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31771 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31771] = 0
                                        mem[_31771 + 32] = 0
                                        _31948 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31948] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31948 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36030 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36030] = 26
                                                mem[_36030 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36223 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36223] = 26
                                                mem[_36223 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26205 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26205] = 30
                            mem[_26205 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29125 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29125] = 0
                                    mem[_29125 + 32] = 0
                                    _29241 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29241] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29241 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33103 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33103] = 26
                                            mem[_33103 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33329 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33329] = 26
                                            mem[_33329 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27960 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27960] = 26
                                        mem[_27960 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31356 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31356] = 0
                                        mem[_31356 + 32] = 0
                                        _31497 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31497] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31497 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35849 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35849] = 26
                                                mem[_35849 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36026 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36026] = 26
                                                mem[_36026 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28168 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28168] = 26
                                        mem[_28168 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31769 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31769] = 0
                                        mem[_31769 + 32] = 0
                                        _31941 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31941] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31941 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36025 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36025] = 26
                                                mem[_36025 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36214 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36214] = 26
                                                mem[_36214 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29437] = 0
                                    mem[_29437 + 32] = 0
                                    _29540 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29540] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29540 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33327 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33327] = 26
                                            mem[_33327 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33570 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33570] = 26
                                            mem[_33570 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28166 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28166] = 26
                                        mem[_28166 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31768 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31768] = 0
                                        mem[_31768 + 32] = 0
                                        _31933 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31933] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31933 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36024 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36024] = 26
                                                mem[_36024 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36210 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36210] = 26
                                                mem[_36210 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28428 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28428] = 26
                                        mem[_28428 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _32216 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32216] = 0
                                        mem[_32216 + 32] = 0
                                        _32379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32379] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32379 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36209 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36209] = 26
                                                mem[_36209 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36491 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36491] = 26
                                                mem[_36491 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
    else:
        require ext_code.size(stor1)
        staticcall stor1.balance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= 0:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'TokenGeyser: Invalid state. Staking shares exist, but no staking tokens do'
        if totalStakingShares <= 0:
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            if stor11 * arg1 / arg1 != stor11:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
            if stor11 * arg1 <= 0:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: Stake amount is too small'
            require ext_code.size(stor3)
            staticcall stor3.balance() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 0 == totalLockedShares:
                if ext_call.return_data[0] > 0:
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                if stor9 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor9:
                    if stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                        revert with 0, 'SafeMath: addition overflow'
                    stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                stor9 = block.timestamp
                if stor12[msg.sender].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor12[msg.sender].field_512:
                    if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                stor12[msg.sender].field_512 = block.timestamp
                if 0 >= stor8:
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                    stor12[address(msg.sender)].field_512 = block.timestamp
                    stor13[address(msg.sender)].field_0++
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg1
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg1,
                                    0,
                                    96,
                                    0,
                                    mem[480],
                                    msg.sender,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                        else:
                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                else:
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0]:
                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                    if stor8 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require stor8
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(stor2)
                    staticcall stor2.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                    stor12[address(msg.sender)].field_512 = block.timestamp
                    stor13[address(msg.sender)].field_0++
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                        revert with 0, 'SafeMath: addition overflow'
                    totalStakingShares += stor11 * arg1
                    require ext_code.size(stor1)
                    staticcall stor1.0xfc0c546a with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0x23b872dd with:
                         gas gas_remaining wei
                        args msg.sender, stor1, arg1
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                    if totalStakingShares <= 0:
                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                    arg1,
                                    0,
                                    96,
                                    0,
                                    mem[544],
                                    msg.sender,
                    else:
                        require ext_code.size(stor1)
                        staticcall stor1.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0 / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
                        else:
                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if totalStakingShares <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalStakingShares
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
            else:
                idx = 0
                while idx < unlockSchedules.length:
                    mem[0] = 14
                    if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                        idx = idx + 1
                        continue 
                    if block.timestamp >= unlockSchedules[idx].field_768:
                        _25372 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25372] = 30
                        mem[_25372 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                            unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                            if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                            if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        _25424 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25424 + 68] = mem[idx + _25372 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25424 + 68] = mem[_25424 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25424 + -mem[64] + 100
                    _25371 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25371] = 30
                    mem[_25371 + 32] = 'SafeMath: subtraction overflow'
                    if unlockSchedules[idx].field_512 > block.timestamp:
                        _25421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25421 + 68] = mem[idx + _25371 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25421 + 68] = mem[_25421 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25421 + -mem[64] + 100
                    if not block.timestamp - unlockSchedules[idx].field_512:
                        _25576 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25576] = 26
                        mem[_25576 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                            if 0 / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25576 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25615] = 26
                        mem[_25615 + 32] = 'SafeMath: division by zero'
                        if unlockSchedules[idx].field_1024 > 0:
                            require unlockSchedules[idx].field_1024
                            unlockSchedules[idx].field_512 = block.timestamp
                            if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _25615 + 32]
                            idx = idx + 32
                            continue 
                    revert with 0, 'SafeMath: division by zero'
                _25370 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25370] = 26
                mem[_25370 + 32] = 'SafeMath: division by zero'
                if totalLockedShares <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalLockedShares
                _25527 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25527] = 30
                mem[_25527 + 32] = 'SafeMath: subtraction overflow'
                if 0 > totalLockedShares:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 / totalLockedShares <= 0:
                    _25733 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25733] = 30
                    mem[_25733 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _25990 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25990] = 30
                        mem[_25990 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27426] = 0
                                mem[_27426 + 32] = 0
                                _27575 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27575] = stor11 * arg1
                                mem[_27575 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _30855 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30855] = 26
                                        mem[_30855 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31112 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31112] = 26
                                        mem[_31112 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26643 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26643] = 26
                                    mem[_26643 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29655 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29655] = 0
                                    mem[_29655 + 32] = 0
                                    _29796 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29796] = stor11 * arg1
                                    mem[_29796 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33544 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33544] = 26
                                            mem[_33544 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33875 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33875] = 26
                                            mem[_33875 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26771] = 26
                                    mem[_26771 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29910 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29910] = 0
                                    mem[_29910 + 32] = 0
                                    _30107 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30107] = stor11 * arg1
                                    mem[_30107 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33874 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33874] = 26
                                            mem[_33874 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34294 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34294] = 26
                                            mem[_34294 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27680 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27680] = 0
                                mem[_27680 + 32] = 0
                                _27847 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27847] = stor11 * arg1
                                mem[_27847 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31110] = 26
                                        mem[_31110 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31460 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31460] = 26
                                        mem[_31460 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26769] = 26
                                    mem[_26769 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29909 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29909] = 0
                                    mem[_29909 + 32] = 0
                                    _30099 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30099] = stor11 * arg1
                                    mem[_30099 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33873 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33873] = 26
                                            mem[_33873 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34290 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34290] = 26
                                            mem[_34290 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26948 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26948] = 26
                                    mem[_26948 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30212 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30212] = 0
                                    mem[_30212 + 32] = 0
                                    _30422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30422] = stor11 * arg1
                                    mem[_30422 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34289 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34289] = 26
                                            mem[_34289 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34760 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34760] = 26
                                            mem[_34760 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26033] = 30
                        mem[_26033 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27677 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27677] = 0
                                mem[_27677 + 32] = 0
                                _27838 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27838] = stor11 * arg1
                                mem[_27838 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31108 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31108] = 26
                                        mem[_31108 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31455 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31455] = 26
                                        mem[_31455 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26767 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26767] = 26
                                    mem[_26767 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29908] = 0
                                    mem[_29908 + 32] = 0
                                    _30091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30091] = stor11 * arg1
                                    mem[_30091 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33872 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33872] = 26
                                            mem[_33872 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34285 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34285] = 26
                                            mem[_34285 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _26944 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26944] = 26
                                    mem[_26944 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30210] = 0
                                    mem[_30210 + 32] = 0
                                    _30415 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30415] = stor11 * arg1
                                    mem[_30415 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34284 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34284] = 26
                                            mem[_34284 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34751 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34751] = 26
                                            mem[_34751 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _27929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27929] = 0
                                mem[_27929 + 32] = 0
                                _28080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28080] = stor11 * arg1
                                mem[_28080 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _31453 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31453] = 26
                                        mem[_31453 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _31886 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31886] = 26
                                        mem[_31886 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _26942 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26942] = 26
                                    mem[_26942 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30209] = 0
                                    mem[_30209 + 32] = 0
                                    _30407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30407] = stor11 * arg1
                                    mem[_30407 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34283 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34283] = 26
                                            mem[_34283 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _34747 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34747] = 26
                                            mem[_34747 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _27167 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27167] = 26
                                    mem[_27167 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _30493 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30493] = 0
                                    mem[_30493 + 32] = 0
                                    _30643 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_30643] = stor11 * arg1
                                    mem[_30643 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _34746 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34746] = 26
                                            mem[_34746 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35186 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35186] = 26
                                            mem[_35186 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                else:
                    mem[mem[64] + 36] = 0 / totalLockedShares
                    require ext_code.size(stor3)
                    call stor3.0xa9059cbb with:
                         gas gas_remaining wei
                        args stor2, 0 / totalLockedShares
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                    require ext_code.size(stor3)
                    staticcall stor3.balance() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 32] = ext_call.return_data[0]
                    emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                    _25948 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25948] = 30
                    mem[_25948 + 32] = 'SafeMath: subtraction overflow'
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26194 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26194] = 30
                        mem[_26194 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _28906 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28906] = 0
                                mem[_28906 + 32] = 0
                                _29106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29106] = stor11 * arg1
                                mem[_29106 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _32896 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32896] = 26
                                        mem[_32896 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33187 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33187] = 26
                                        mem[_33187 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _27855 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27855] = 26
                                    mem[_27855 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31120] = 0
                                    mem[_31120 + 32] = 0
                                    _31329 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31329] = stor11 * arg1
                                    mem[_31329 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35674 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35674] = 26
                                            mem[_35674 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _35917 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35917] = 26
                                            mem[_35917 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28099 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28099] = 26
                                    mem[_28099 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31473 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31473] = 0
                                    mem[_31473 + 32] = 0
                                    _31738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31738] = stor11 * arg1
                                    mem[_31738 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35916 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35916] = 26
                                            mem[_35916 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36140 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36140] = 26
                                            mem[_36140 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _29223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29223] = 0
                                mem[_29223 + 32] = 0
                                _29415 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29415] = stor11 * arg1
                                mem[_29415 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33185 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33185] = 26
                                        mem[_33185 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33439 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33439] = 26
                                        mem[_33439 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28097 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28097] = 26
                                    mem[_28097 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31472 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31472] = 0
                                    mem[_31472 + 32] = 0
                                    _31730 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31730] = stor11 * arg1
                                    mem[_31730 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35915 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35915] = 26
                                            mem[_35915 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36136 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36136] = 26
                                            mem[_36136 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28322] = 26
                                    mem[_28322 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31911 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31911] = 0
                                    mem[_31911 + 32] = 0
                                    _32178 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32178] = stor11 * arg1
                                    mem[_32178 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36135 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36135] = 26
                                            mem[_36135 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36383 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36383] = 26
                                            mem[_36383 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                        stor9 = block.timestamp
                        mem[0] = msg.sender
                        mem[32] = 12
                        _26245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26245] = 30
                        mem[_26245 + 32] = 'SafeMath: subtraction overflow'
                        if stor12[msg.sender].field_512 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor12[msg.sender].field_512:
                            if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _29220 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29220] = 0
                                mem[_29220 + 32] = 0
                                _29406 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29406] = stor11 * arg1
                                mem[_29406 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33183] = 26
                                        mem[_33183 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33434 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33434] = 26
                                        mem[_33434 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28095] = 26
                                    mem[_28095 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31471 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31471] = 0
                                    mem[_31471 + 32] = 0
                                    _31722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31722] = stor11 * arg1
                                    mem[_31722 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _35914 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35914] = 26
                                            mem[_35914 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36131 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36131] = 26
                                            mem[_36131 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28318] = 26
                                    mem[_28318 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31909 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31909] = 0
                                    mem[_31909 + 32] = 0
                                    _32171 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32171] = stor11 * arg1
                                    mem[_32171 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36130 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36130] = 26
                                            mem[_36130 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36374] = 26
                                            mem[_36374 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                        else:
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: addition overflow'
                            stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                            stor12[msg.sender].field_512 = block.timestamp
                            if 0 >= stor8:
                                require ext_code.size(stor3)
                                staticcall stor3.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[0] = msg.sender
                                mem[32] = 12
                                if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[address(msg.sender)].field_0 += stor11 * arg1
                                stor12[address(msg.sender)].field_512 = block.timestamp
                                _29527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29527] = 0
                                mem[_29527 + 32] = 0
                                _29660 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29660] = stor11 * arg1
                                mem[_29660 + 32] = block.timestamp
                                mem[32] = 13
                                stor13[address(msg.sender)].field_0++
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalStakingShares += stor11 * arg1
                                require ext_code.size(stor1)
                                staticcall stor1.0xfc0c546a with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(address(ext_call.return_data[0]))
                                call address(ext_call.return_data[0]).0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, stor1, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                if totalStakingShares <= 0:
                                    mem[mem[64] + 64] = 96
                                    mem[mem[64] + 96] = 0
                                    emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                arg1,
                                                0,
                                                96,
                                                0,
                                                mem[mem[64] + 128],
                                                msg.sender,
                                else:
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    require ext_code.size(stor1)
                                    staticcall stor1.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _33432 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33432] = 26
                                        mem[_33432 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0 / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _33715 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33715] = 26
                                        mem[_33715 + 32] = 'SafeMath: division by zero'
                                        if totalStakingShares <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalStakingShares
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                            else:
                                require ext_code.size(stor2)
                                staticcall stor2.balance() with:
                                        gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    _28316 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28316] = 26
                                    mem[_28316 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _31908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31908] = 0
                                    mem[_31908 + 32] = 0
                                    _32163 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32163] = stor11 * arg1
                                    mem[_32163 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36129 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36129] = 26
                                            mem[_36129 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36370 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36370] = 26
                                            mem[_36370 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _28583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28583] = 26
                                    mem[_28583 + 32] = 'SafeMath: division by zero'
                                    if stor8 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require stor8
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (stor11 * arg1) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += stor11 * arg1
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _32361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32361] = 0
                                    mem[_32361 + 32] = 0
                                    _32549 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32549] = stor11 * arg1
                                    mem[_32549 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = stor11 * arg1
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (stor11 * arg1) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += stor11 * arg1
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _36369 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36369] = 26
                                            mem[_36369 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _36666 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_36666] = 26
                                            mem[_36666 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
        else:
            require ext_code.size(stor1)
            staticcall stor1.balance() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not totalStakingShares:
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if 0 / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += 0 / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25369 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25369] = 30
                            mem[_25369 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25415 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25415 + 68] = mem[idx + _25369 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25415 + 68] = mem[_25415 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25415 + -mem[64] + 100
                        _25368 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25368] = 30
                        mem[_25368 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25412 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25412 + 68] = mem[idx + _25368 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25412 + 68] = mem[_25412 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25412 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25575] = 26
                            mem[_25575 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25575 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25609 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25609] = 26
                            mem[_25609 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25609 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25367 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25367] = 26
                    mem[_25367 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25525 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25525] = 30
                    mem[_25525 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25727 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25727] = 30
                        mem[_25727 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25989] = 30
                            mem[_25989 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27406] = 0
                                    mem[_27406 + 32] = 0
                                    _27550 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27550] = 0 / ext_call.return_data[0]
                                    mem[_27550 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30836 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30836] = 26
                                            mem[_30836 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31095 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31095] = 26
                                            mem[_31095 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26641 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26641] = 26
                                        mem[_26641 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29631 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29631] = 0
                                        mem[_29631 + 32] = 0
                                        _29774 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29774] = 0 / ext_call.return_data[0]
                                        mem[_29774 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33525 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33525] = 26
                                                mem[_33525 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33848 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33848] = 26
                                                mem[_33848 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26761 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26761] = 26
                                        mem[_26761 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29890] = 0
                                        mem[_29890 + 32] = 0
                                        _30075 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30075] = 0 / ext_call.return_data[0]
                                        mem[_30075 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33847 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33847] = 26
                                                mem[_33847 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34258 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34258] = 26
                                                mem[_34258 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27662 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27662] = 0
                                    mem[_27662 + 32] = 0
                                    _27819 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27819] = 0 / ext_call.return_data[0]
                                    mem[_27819 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31093 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31093] = 26
                                            mem[_31093 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31437 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31437] = 26
                                            mem[_31437 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26759 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26759] = 26
                                        mem[_26759 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29889 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29889] = 0
                                        mem[_29889 + 32] = 0
                                        _30067 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30067] = 0 / ext_call.return_data[0]
                                        mem[_30067 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33846 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33846] = 26
                                                mem[_33846 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34254 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34254] = 26
                                                mem[_34254 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26927 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26927] = 26
                                        mem[_26927 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30194 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30194] = 0
                                        mem[_30194 + 32] = 0
                                        _30386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30386] = 0 / ext_call.return_data[0]
                                        mem[_30386 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34253 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34253] = 26
                                                mem[_34253 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34719 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34719] = 26
                                                mem[_34719 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26027] = 30
                            mem[_26027 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27659] = 0
                                    mem[_27659 + 32] = 0
                                    _27810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27810] = 0 / ext_call.return_data[0]
                                    mem[_27810 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31091 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31091] = 26
                                            mem[_31091 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31432 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31432] = 26
                                            mem[_31432 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26757 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26757] = 26
                                        mem[_26757 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29888 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29888] = 0
                                        mem[_29888 + 32] = 0
                                        _30059 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30059] = 0 / ext_call.return_data[0]
                                        mem[_30059 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33845 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33845] = 26
                                                mem[_33845 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34249 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34249] = 26
                                                mem[_34249 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26923 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26923] = 26
                                        mem[_26923 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30192 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30192] = 0
                                        mem[_30192 + 32] = 0
                                        _30379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30379] = 0 / ext_call.return_data[0]
                                        mem[_30379 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34248 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34248] = 26
                                                mem[_34248 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34710 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34710] = 26
                                                mem[_34710 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27915 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27915] = 0
                                    mem[_27915 + 32] = 0
                                    _28053 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28053] = 0 / ext_call.return_data[0]
                                    mem[_28053 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31430 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31430] = 26
                                            mem[_31430 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31858 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31858] = 26
                                            mem[_31858 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26921 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26921] = 26
                                        mem[_26921 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30191 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30191] = 0
                                        mem[_30191 + 32] = 0
                                        _30371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30371] = 0 / ext_call.return_data[0]
                                        mem[_30371 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34247 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34247] = 26
                                                mem[_34247 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34706 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34706] = 26
                                                mem[_34706 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27143] = 26
                                        mem[_27143 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30483 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30483] = 0
                                        mem[_30483 + 32] = 0
                                        _30615 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30615] = 0 / ext_call.return_data[0]
                                        mem[_30615 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34705 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34705] = 26
                                                mem[_34705 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35147 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35147] = 26
                                                mem[_35147 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25945 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25945] = 30
                        mem[_25945 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26189] = 30
                            mem[_26189 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _28882 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28882] = 0
                                    mem[_28882 + 32] = 0
                                    _29072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29072] = 0 / ext_call.return_data[0]
                                    mem[_29072 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32875 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32875] = 26
                                            mem[_32875 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33171] = 26
                                            mem[_33171 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27827] = 26
                                        mem[_27827 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31103 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31103] = 0
                                        mem[_31103 + 32] = 0
                                        _31293 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31293] = 0 / ext_call.return_data[0]
                                        mem[_31293 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35658 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35658] = 26
                                                mem[_35658 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35904 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35904] = 26
                                                mem[_35904 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28072 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28072] = 26
                                        mem[_28072 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31450 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31450] = 0
                                        mem[_31450 + 32] = 0
                                        _31693 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31693] = 0 / ext_call.return_data[0]
                                        mem[_31693 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35903 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35903] = 26
                                                mem[_35903 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36119 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36119] = 26
                                                mem[_36119 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29204 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29204] = 0
                                    mem[_29204 + 32] = 0
                                    _29382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29382] = 0 / ext_call.return_data[0]
                                    mem[_29382 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33169 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33169] = 26
                                            mem[_33169 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33418 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33418] = 26
                                            mem[_33418 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28070 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28070] = 26
                                        mem[_28070 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31449 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31449] = 0
                                        mem[_31449 + 32] = 0
                                        _31685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31685] = 0 / ext_call.return_data[0]
                                        mem[_31685 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35902 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35902] = 26
                                                mem[_35902 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36115 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36115] = 26
                                                mem[_36115 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28292 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28292] = 26
                                        mem[_28292 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31883 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31883] = 0
                                        mem[_31883 + 32] = 0
                                        _32132 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32132] = 0 / ext_call.return_data[0]
                                        mem[_32132 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36114 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36114] = 26
                                                mem[_36114 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36351 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36351] = 26
                                                mem[_36351 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26237 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26237] = 30
                            mem[_26237 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29201 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29201] = 0
                                    mem[_29201 + 32] = 0
                                    _29373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29373] = 0 / ext_call.return_data[0]
                                    mem[_29373 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33167 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33167] = 26
                                            mem[_33167 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33413 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33413] = 26
                                            mem[_33413 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28068 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28068] = 26
                                        mem[_28068 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31448 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31448] = 0
                                        mem[_31448 + 32] = 0
                                        _31677 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31677] = 0 / ext_call.return_data[0]
                                        mem[_31677 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35901 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35901] = 26
                                                mem[_35901 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36110 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36110] = 26
                                                mem[_36110 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28288 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28288] = 26
                                        mem[_28288 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31881 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31881] = 0
                                        mem[_31881 + 32] = 0
                                        _32125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32125] = 0 / ext_call.return_data[0]
                                        mem[_32125 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36109 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36109] = 26
                                                mem[_36109 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36342 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36342] = 26
                                                mem[_36342 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29509 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29509] = 0
                                    mem[_29509 + 32] = 0
                                    _29636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29636] = 0 / ext_call.return_data[0]
                                    mem[_29636 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += 0 / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33411 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33411] = 26
                                            mem[_33411 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33686 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33686] = 26
                                            mem[_33686 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28286 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28286] = 26
                                        mem[_28286 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31880 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31880] = 0
                                        mem[_31880 + 32] = 0
                                        _32117 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32117] = 0 / ext_call.return_data[0]
                                        mem[_32117 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36108 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36108] = 26
                                                mem[_36108 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36338 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36338] = 26
                                                mem[_36338 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28552 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28552] = 26
                                        mem[_28552 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (0 / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += 0 / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _32332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32332] = 0
                                        mem[_32332 + 32] = 0
                                        _32515 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32515] = 0 / ext_call.return_data[0]
                                        mem[_32515 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = 0 / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (0 / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += 0 / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36337 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36337] = 26
                                                mem[_36337 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36631 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36631] = 26
                                                mem[_36631 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
            else:
                if arg1 * totalStakingShares / totalStakingShares != arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                mem[64] = 160
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if arg1 * totalStakingShares / ext_call.return_data[0] <= 0:
                    revert with 0, 'TokenGeyser: Stake amount is too small'
                require ext_code.size(stor3)
                staticcall stor3.balance() with:
                        gas gas_remaining wei
                mem[160] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 == totalLockedShares:
                    if ext_call.return_data[0] > 0:
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        emit TokensUnlocked(ext_call.return_data[0], ext_call.return_data[0]);
                    if stor9 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor9:
                        if stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                            revert with 0, 'SafeMath: addition overflow'
                        stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                    stor9 = block.timestamp
                    if stor12[msg.sender].field_512 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not block.timestamp - stor12[msg.sender].field_512:
                        if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                    stor12[msg.sender].field_512 = block.timestamp
                    if 0 >= stor8:
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[544],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[608],
                                            msg.sender,
                    else:
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                revert with 0, 'SafeMath: multiplication overflow'
                        if stor8 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require stor8
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(stor2)
                        staticcall stor2.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                        stor12[address(msg.sender)].field_512 = block.timestamp
                        stor13[address(msg.sender)].field_0++
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                            revert with 0, 'SafeMath: addition overflow'
                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                        require ext_code.size(stor1)
                        staticcall stor1.0xfc0c546a with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, stor1, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                        if totalStakingShares <= 0:
                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                        arg1,
                                        0,
                                        96,
                                        0,
                                        mem[608],
                                        msg.sender,
                        else:
                            require ext_code.size(stor1)
                            staticcall stor1.balance() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            0 / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                            else:
                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if totalStakingShares <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalStakingShares
                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                            arg1,
                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                            96,
                                            0,
                                            mem[672],
                                            msg.sender,
                else:
                    idx = 0
                    while idx < unlockSchedules.length:
                        mem[0] = 14
                        if unlockSchedules[idx].field_256 >= unlockSchedules[idx].field_0:
                            idx = idx + 1
                            continue 
                        if block.timestamp >= unlockSchedules[idx].field_768:
                            _25366 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25366] = 30
                            mem[_25366 + 32] = 'SafeMath: subtraction overflow'
                            if unlockSchedules[idx].field_256 <= unlockSchedules[idx].field_0:
                                unlockSchedules[idx].field_512 = unlockSchedules[idx].field_768
                                if unlockSchedules[idx].field_0 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 = unlockSchedules[idx].field_0
                                if unlockSchedules[idx].field_0 - unlockSchedules[idx].field_256 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            _25406 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25406 + 68] = mem[idx + _25366 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25406 + 68] = mem[_25406 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25406 + -mem[64] + 100
                        _25365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25365] = 30
                        mem[_25365 + 32] = 'SafeMath: subtraction overflow'
                        if unlockSchedules[idx].field_512 > block.timestamp:
                            _25403 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25403 + 68] = mem[idx + _25365 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25403 + 68] = mem[_25403 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25403 + -mem[64] + 100
                        if not block.timestamp - unlockSchedules[idx].field_512:
                            _25574 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25574] = 26
                            mem[_25574 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if (0 / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += 0 / unlockSchedules[idx].field_1024
                                if 0 / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25574 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / block.timestamp - unlockSchedules[idx].field_512 != unlockSchedules[idx].field_0:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25603 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25603] = 26
                            mem[_25603 + 32] = 'SafeMath: division by zero'
                            if unlockSchedules[idx].field_1024 > 0:
                                require unlockSchedules[idx].field_1024
                                unlockSchedules[idx].field_512 = block.timestamp
                                if ((block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024) + unlockSchedules[idx].field_256 < unlockSchedules[idx].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                unlockSchedules[idx].field_256 += (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024
                                if (block.timestamp * unlockSchedules[idx].field_0) - (unlockSchedules[idx].field_512 * unlockSchedules[idx].field_0) / unlockSchedules[idx].field_1024 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _25603 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    _25364 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25364] = 26
                    mem[_25364 + 32] = 'SafeMath: division by zero'
                    if totalLockedShares <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalLockedShares
                    _25523 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25523] = 30
                    mem[_25523 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > totalLockedShares:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 / totalLockedShares <= 0:
                        _25721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25721] = 30
                        mem[_25721 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _25988 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25988] = 30
                            mem[_25988 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27386] = 0
                                    mem[_27386 + 32] = 0
                                    _27525 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27525] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27525 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _30817 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_30817] = 26
                                            mem[_30817 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31078] = 26
                                            mem[_31078 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26639 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26639] = 26
                                        mem[_26639 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29607] = 0
                                        mem[_29607 + 32] = 0
                                        _29752 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29752] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_29752 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33506 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33506] = 26
                                                mem[_33506 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _33821 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33821] = 26
                                                mem[_33821 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26751 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26751] = 26
                                        mem[_26751 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29870 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29870] = 0
                                        mem[_29870 + 32] = 0
                                        _30043 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30043] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30043 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33820 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33820] = 26
                                                mem[_33820 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34222 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34222] = 26
                                                mem[_34222 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27644] = 0
                                    mem[_27644 + 32] = 0
                                    _27791 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27791] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27791 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31076 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31076] = 26
                                            mem[_31076 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31414 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31414] = 26
                                            mem[_31414 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26749 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26749] = 26
                                        mem[_26749 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29869 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29869] = 0
                                        mem[_29869 + 32] = 0
                                        _30035 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30035] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30035 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33819 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33819] = 26
                                                mem[_33819 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34218 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34218] = 26
                                                mem[_34218 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26906 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26906] = 26
                                        mem[_26906 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30176] = 0
                                        mem[_30176 + 32] = 0
                                        _30350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30350] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30350 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34217 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34217] = 26
                                                mem[_34217 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34678 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34678] = 26
                                                mem[_34678 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26021 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26021] = 30
                            mem[_26021 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27641 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27641] = 0
                                    mem[_27641 + 32] = 0
                                    _27782 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27782] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_27782 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31074 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31074] = 26
                                            mem[_31074 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31409 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31409] = 26
                                            mem[_31409 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26747 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26747] = 26
                                        mem[_26747 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _29868 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_29868] = 0
                                        mem[_29868 + 32] = 0
                                        _30027 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30027] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30027 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _33818 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33818] = 26
                                                mem[_33818 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34213 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34213] = 26
                                                mem[_34213 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _26902 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26902] = 26
                                        mem[_26902 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30174] = 0
                                        mem[_30174 + 32] = 0
                                        _30343 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30343] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30343 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34212 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34212] = 26
                                                mem[_34212 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34669 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34669] = 26
                                                mem[_34669 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _27901 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27901] = 0
                                    mem[_27901 + 32] = 0
                                    _28026 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28026] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_28026 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _31407 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31407] = 26
                                            mem[_31407 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _31830 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_31830] = 26
                                            mem[_31830 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _26900 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26900] = 26
                                        mem[_26900 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30173] = 0
                                        mem[_30173 + 32] = 0
                                        _30335 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30335] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30335 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34211 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34211] = 26
                                                mem[_34211 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _34665 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34665] = 26
                                                mem[_34665 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _27119 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27119] = 26
                                        mem[_27119 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _30473 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30473] = 0
                                        mem[_30473 + 32] = 0
                                        _30587 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_30587] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_30587 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _34664 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_34664] = 26
                                                mem[_34664 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35108 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35108] = 26
                                                mem[_35108 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                    else:
                        mem[mem[64] + 36] = 0 / totalLockedShares
                        require ext_code.size(stor3)
                        call stor3.0xa9059cbb with:
                             gas gas_remaining wei
                            args stor2, 0 / totalLockedShares
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'TokenGeyser: transfer out of locked pool failed'
                        require ext_code.size(stor3)
                        staticcall stor3.balance() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 32] = ext_call.return_data[0]
                        emit TokensUnlocked(0 / totalLockedShares, ext_call.return_data[0]);
                        _25942 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25942] = 30
                        mem[_25942 + 32] = 'SafeMath: subtraction overflow'
                        if stor9 > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.timestamp - stor9:
                            if stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26184 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26184] = 30
                            mem[_26184 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _28858 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28858] = 0
                                    mem[_28858 + 32] = 0
                                    _29038 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29038] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29038 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _32854 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32854] = 26
                                            mem[_32854 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33155 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33155] = 26
                                            mem[_33155 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _27799 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27799] = 26
                                        mem[_27799 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31086 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31086] = 0
                                        mem[_31086 + 32] = 0
                                        _31257 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31257] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31257 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35642 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35642] = 26
                                                mem[_35642 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _35891 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35891] = 26
                                                mem[_35891 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28045 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28045] = 26
                                        mem[_28045 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31427 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31427] = 0
                                        mem[_31427 + 32] = 0
                                        _31648 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31648] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31648 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35890 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35890] = 26
                                                mem[_35890 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36098 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36098] = 26
                                                mem[_36098 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29185 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29185] = 0
                                    mem[_29185 + 32] = 0
                                    _29349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29349] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29349 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33153 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33153] = 26
                                            mem[_33153 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33397 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33397] = 26
                                            mem[_33397 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28043 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28043] = 26
                                        mem[_28043 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31426 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31426] = 0
                                        mem[_31426 + 32] = 0
                                        _31640 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31640] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31640 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35889 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35889] = 26
                                                mem[_35889 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36094 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36094] = 26
                                                mem[_36094 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28262 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28262] = 26
                                        mem[_28262 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31855 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31855] = 0
                                        mem[_31855 + 32] = 0
                                        _32086 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32086] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32086 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36093 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36093] = 26
                                                mem[_36093 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36319 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36319] = 26
                                                mem[_36319 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                        else:
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) / block.timestamp - stor9 != totalStakingShares:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8 < stor8:
                                revert with 0, 'SafeMath: addition overflow'
                            stor8 = (block.timestamp * totalStakingShares) - (stor9 * totalStakingShares) + stor8
                            stor9 = block.timestamp
                            mem[0] = msg.sender
                            mem[32] = 12
                            _26229 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26229] = 30
                            mem[_26229 + 32] = 'SafeMath: subtraction overflow'
                            if stor12[msg.sender].field_512 > block.timestamp:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.timestamp - stor12[msg.sender].field_512:
                                if stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29182] = 0
                                    mem[_29182 + 32] = 0
                                    _29340 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29340] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29340 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33151 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33151] = 26
                                            mem[_33151 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33392 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33392] = 26
                                            mem[_33392 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28041 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28041] = 26
                                        mem[_28041 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31425 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31425] = 0
                                        mem[_31425 + 32] = 0
                                        _31632 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31632] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_31632 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _35888 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35888] = 26
                                                mem[_35888 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36089 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36089] = 26
                                                mem[_36089 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28258 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28258] = 26
                                        mem[_28258 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31853 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31853] = 0
                                        mem[_31853 + 32] = 0
                                        _32079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32079] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32079 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36088 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36088] = 26
                                                mem[_36088 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36310 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36310] = 26
                                                mem[_36310 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                            else:
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) / block.timestamp - stor12[msg.sender].field_512 != stor12[msg.sender].field_0:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256 < stor12[msg.sender].field_256:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor12[msg.sender].field_256 = (block.timestamp * stor12[msg.sender].field_0) - (stor12[msg.sender].field_512 * stor12[msg.sender].field_0) + stor12[msg.sender].field_256
                                stor12[msg.sender].field_512 = block.timestamp
                                if 0 >= stor8:
                                    require ext_code.size(stor3)
                                    staticcall stor3.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[0] = msg.sender
                                    mem[32] = 12
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor12[address(msg.sender)].field_512 = block.timestamp
                                    _29491 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29491] = 0
                                    mem[_29491 + 32] = 0
                                    _29612 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_29612] = arg1 * totalStakingShares / ext_call.return_data[0]
                                    mem[_29612 + 32] = block.timestamp
                                    mem[32] = 13
                                    stor13[address(msg.sender)].field_0++
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                    stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                    if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                    require ext_code.size(stor1)
                                    staticcall stor1.0xfc0c546a with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(address(ext_call.return_data[0]))
                                    call address(ext_call.return_data[0]).0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, stor1, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                    if totalStakingShares <= 0:
                                        mem[mem[64] + 64] = 96
                                        mem[mem[64] + 96] = 0
                                        emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                    arg1,
                                                    0,
                                                    96,
                                                    0,
                                                    mem[mem[64] + 128],
                                                    msg.sender,
                                    else:
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        require ext_code.size(stor1)
                                        staticcall stor1.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            _33390 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33390] = 26
                                            mem[_33390 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0 / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _33657 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33657] = 26
                                            mem[_33657 + 32] = 'SafeMath: division by zero'
                                            if totalStakingShares <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalStakingShares
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                else:
                                    require ext_code.size(stor2)
                                    staticcall stor2.balance() with:
                                            gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        _28256 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28256] = 26
                                        mem[_28256 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _31852 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_31852] = 0
                                        mem[_31852 + 32] = 0
                                        _32071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32071] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32071 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36087 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36087] = 26
                                                mem[_36087 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36306 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36306] = 26
                                                mem[_36306 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                    else:
                                        if stor12[msg.sender].field_256 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[msg.sender].field_256:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _28521 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_28521] = 26
                                        mem[_28521 + 32] = 'SafeMath: division by zero'
                                        if stor8 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require stor8
                                        require ext_code.size(stor3)
                                        staticcall stor3.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(stor2)
                                        staticcall stor2.balance() with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[0] = msg.sender
                                        mem[32] = 12
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + stor12[address(msg.sender)].field_0 < stor12[address(msg.sender)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor12[address(msg.sender)].field_0 += arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor12[address(msg.sender)].field_512 = block.timestamp
                                        _32303 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32303] = 0
                                        mem[_32303 + 32] = 0
                                        _32481 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32481] = arg1 * totalStakingShares / ext_call.return_data[0]
                                        mem[_32481 + 32] = block.timestamp
                                        mem[32] = 13
                                        stor13[address(msg.sender)].field_0++
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_0 = arg1 * totalStakingShares / ext_call.return_data[0]
                                        stor13[address(msg.sender)][stor13[address(msg.sender)].field_0].field_256 = block.timestamp
                                        if (arg1 * totalStakingShares / ext_call.return_data[0]) + totalStakingShares < totalStakingShares:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalStakingShares += arg1 * totalStakingShares / ext_call.return_data[0]
                                        require ext_code.size(stor1)
                                        staticcall stor1.0xfc0c546a with:
                                                gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(address(ext_call.return_data[0]))
                                        call address(ext_call.return_data[0]).0x23b872dd with:
                                             gas gas_remaining wei
                                            args msg.sender, stor1, arg1
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if not ext_call.return_data[0]:
                                            revert with 0, 'TokenGeyser: transfer into staking pool failed'
                                        if totalStakingShares <= 0:
                                            mem[mem[64] + 64] = 96
                                            mem[mem[64] + 96] = 0
                                            emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                        arg1,
                                                        0,
                                                        96,
                                                        0,
                                                        mem[mem[64] + 128],
                                                        msg.sender,
                                        else:
                                            mem[0] = msg.sender
                                            mem[32] = 12
                                            require ext_code.size(stor1)
                                            staticcall stor1.balance() with:
                                                    gas gas_remaining wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if not ext_call.return_data[0]:
                                                _36305 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36305] = 26
                                                mem[_36305 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            0 / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
                                            else:
                                                if stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / ext_call.return_data[0] != stor12[address(msg.sender)].field_0:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _36596 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_36596] = 26
                                                mem[_36596 + 32] = 'SafeMath: division by zero'
                                                if totalStakingShares <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalStakingShares
                                                mem[mem[64] + 64] = 96
                                                mem[mem[64] + 96] = 0
                                                emit Staked(address rg1, uint256 rg2, uint256 rg3, bytes rg4):
                                                            arg1,
                                                            stor12[address(msg.sender)].field_0 * ext_call.return_data[0] / totalStakingShares,
                                                            96,
                                                            0,
                                                            mem[mem[64] + 128],
                                                            msg.sender,
}



}
