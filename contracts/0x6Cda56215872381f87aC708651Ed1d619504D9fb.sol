contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#
address _owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
array of struct stor6;
array of struct stor7;
uint8 decimals;
address feeAddress;
uint256 stor12;
uint256 totalSupply;
uint256 stor14;
uint256 totalFees;
uint256 totalBurn;
uint256 totalCharity;
uint256 _TAX_FEE;
uint256 _BURN_FEE;
uint256 _CHARITY_FEE;
uint256 stor21;
uint256 stor22;
uint256 stor23;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699760;

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function decimals() payable {
    return decimals
}

function totalBurn() payable {
    return totalBurn
}

function _BURN_FEE() payable {
    return _BURN_FEE
}

function FeeAddress() payable {
    return feeAddress
}

function owner() payable {
    return _owner
}

function _CHARITY_FEE() payable {
    return _CHARITY_FEE
}

function _owner() payable {
    return _owner
}

function _TAX_FEE() payable {
    return _TAX_FEE
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function totalCharity() payable {
    return totalCharity
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(_owner, 0);
    _owner = 0
}

function setAsCharityAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    feeAddress = arg1
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(_owner, arg1);
    _owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function updateFee(uint256 arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require arg1 < 100
    require arg2 < 100
    require arg3 < 100
    if arg1 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _TAX_FEE = 100 * arg1
    if arg2 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _BURN_FEE = 100 * arg2
    if arg3 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _CHARITY_FEE = 100 * arg3
    stor21 = _TAX_FEE
    stor22 = _BURN_FEE
    stor23 = 100 * arg3
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 39, 0xfe544f4b454e32303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[167 len 25] >> 56, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already included'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor5.length < 1:
            revert with 0, 17
        if stor5.length - 1 >= stor5.length:
            revert with 0, 50
        if idx >= stor5.length:
            revert with 0, 50
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor5.length:
            revert with 0, 49
        stor5[stor5.length] = 0
        stor5.length--
}

function name() payable {
    if bool(stor6.length):
        if bool(stor6.length) == stor6.length.field_1 < 32:
            revert with 0, 34
        if bool(stor6.length):
            if bool(stor6.length) == stor6.length.field_1 < 32:
                revert with 0, 34
            if stor6.length.field_1:
                if 31 < stor6.length.field_1:
                    mem[128] = uint256(stor6.field_0)
                    idx = 128
                    s = 0
                    while stor6.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor6[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor6.length.field_1), data=mem[128 len ceil32(stor6.length.field_1)])
                mem[128] = 256 * stor6.length.field_8
        else:
            if bool(stor6.length) == stor6.length.field_1 < 32:
                revert with 0, 34
            if stor6.length.field_1:
                if 31 < stor6.length.field_1:
                    mem[128] = uint256(stor6.field_0)
                    idx = 128
                    s = 0
                    while stor6.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor6[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor6.length.field_1), data=mem[128 len ceil32(stor6.length.field_1)])
                mem[128] = 256 * stor6.length.field_8
        mem[ceil32(stor6.length.field_1) + 192 len ceil32(stor6.length.field_1)] = mem[128 len ceil32(stor6.length.field_1)]
        if ceil32(stor6.length.field_1) > stor6.length.field_1:
            mem[ceil32(stor6.length.field_1) + stor6.length.field_1 + 192] = 0
        return Array(len=2 * Mask(256, -1, stor6.length.field_1), data=mem[128 len ceil32(stor6.length.field_1)], mem[(2 * ceil32(stor6.length.field_1)) + 192 len 2 * ceil32(stor6.length.field_1)]), 
    if bool(stor6.length) == stor6.length.field_1 < 32:
        revert with 0, 34
    if bool(stor6.length):
        if bool(stor6.length) == stor6.length.field_1 < 32:
            revert with 0, 34
        if stor6.length.field_1:
            if 31 < stor6.length.field_1:
                mem[128] = uint256(stor6.field_0)
                idx = 128
                s = 0
                while stor6.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor6[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])
            mem[128] = 256 * stor6.length.field_8
    else:
        if bool(stor6.length) == stor6.length.field_1 < 32:
            revert with 0, 34
        if stor6.length.field_1:
            if 31 < stor6.length.field_1:
                mem[128] = uint256(stor6.field_0)
                idx = 128
                s = 0
                while stor6.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor6[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)])
            mem[128] = 256 * stor6.length.field_8
    mem[ceil32(stor6.length.field_1) + 192 len ceil32(stor6.length.field_1)] = mem[128 len ceil32(stor6.length.field_1)]
    if ceil32(stor6.length.field_1) > stor6.length.field_1:
        mem[ceil32(stor6.length.field_1) + stor6.length.field_1 + 192] = 0
    return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1)], mem[(2 * ceil32(stor6.length.field_1)) + 192 len 2 * ceil32(stor6.length.field_1)]), 
}

function symbol() payable {
    if bool(stor7.length):
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if bool(stor7.length):
            if bool(stor7.length) == stor7.length.field_1 < 32:
                revert with 0, 34
            if stor7.length.field_1:
                if 31 < stor7.length.field_1:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while stor7.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length.field_1), data=mem[128 len ceil32(stor7.length.field_1)])
                mem[128] = 256 * stor7.length.field_8
        else:
            if bool(stor7.length) == stor7.length.field_1 < 32:
                revert with 0, 34
            if stor7.length.field_1:
                if 31 < stor7.length.field_1:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while stor7.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length.field_1), data=mem[128 len ceil32(stor7.length.field_1)])
                mem[128] = 256 * stor7.length.field_8
        mem[ceil32(stor7.length.field_1) + 192 len ceil32(stor7.length.field_1)] = mem[128 len ceil32(stor7.length.field_1)]
        if ceil32(stor7.length.field_1) > stor7.length.field_1:
            mem[ceil32(stor7.length.field_1) + stor7.length.field_1 + 192] = 0
        return Array(len=2 * Mask(256, -1, stor7.length.field_1), data=mem[128 len ceil32(stor7.length.field_1)], mem[(2 * ceil32(stor7.length.field_1)) + 192 len 2 * ceil32(stor7.length.field_1)]), 
    if bool(stor7.length) == stor7.length.field_1 < 32:
        revert with 0, 34
    if bool(stor7.length):
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if stor7.length.field_1:
            if 31 < stor7.length.field_1:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while stor7.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    else:
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if stor7.length.field_1:
            if 31 < stor7.length.field_1:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while stor7.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    mem[ceil32(stor7.length.field_1) + 192 len ceil32(stor7.length.field_1)] = mem[128 len ceil32(stor7.length.field_1)]
    if ceil32(stor7.length.field_1) > stor7.length.field_1:
        mem[ceil32(stor7.length.field_1) + stor7.length.field_1 + 192] = 0
    return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)], mem[(2 * ceil32(stor7.length.field_1)) + 192 len 2 * ceil32(stor7.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor14:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor14
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _93 = mem[64]
            mem[64] = mem[64] + 64
            mem[_93] = 26
            mem[_93 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _98 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _98 + 68] = mem[idx + _93 + 32]
                    idx = idx + 32
                    continue 
                mem[_98 + 94] = 0
                revert with memory
                  from mem[64]
                   len _98 + -mem[64] + 100
            _118 = mem[64]
            mem[64] = mem[64] + 64
            mem[_118] = 26
            mem[_118 + 32] = 'SafeMath: division by zero'
            if stor14 / totalSupply:
                return (arg1 / stor14 / totalSupply)
            _127 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _127 + 68] = mem[idx + _118 + 32]
                idx = idx + 32
                continue 
            mem[_127 + 94] = 0
            revert with memory
              from mem[64]
               len _127 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _99 = mem[64]
            mem[64] = mem[64] + 64
            mem[_99] = 26
            mem[_99 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _104 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _104 + 68] = mem[idx + _99 + 32]
                    idx = idx + 32
                    continue 
                mem[_104 + 94] = 0
                revert with memory
                  from mem[64]
                   len _104 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor14 / totalSupply:
                return (arg1 / stor14 / totalSupply)
            _134 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _134 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_134 + 94] = 0
            revert with memory
              from mem[64]
               len _134 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _96 = mem[64]
        mem[64] = mem[64] + 64
        mem[_96] = 30
        mem[_96 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _96 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _123 = mem[64]
        mem[64] = mem[64] + 64
        mem[_123] = 30
        mem[_123 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _130 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _130 + 68] = mem[idx + _123 + 32]
            idx = idx + 32
            continue 
        mem[_130 + 98] = 0
        revert with memory
          from mem[64]
           len _130 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor14 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor14 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor14 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor14:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor14
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _103 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_103 + 94] = 0
                revert with memory
                  from mem[64]
                   len _103 + -mem[64] + 100
            _123 = mem[64]
            mem[64] = mem[64] + 64
            mem[_123] = 26
            mem[_123 + 32] = 'SafeMath: division by zero'
            if stor14 / totalSupply:
                return (stor1[address(arg1)] / stor14 / totalSupply)
            _132 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _132 + 68] = mem[idx + _123 + 32]
                idx = idx + 32
                continue 
            mem[_132 + 94] = 0
            revert with memory
              from mem[64]
               len _132 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _104 = mem[64]
            mem[64] = mem[64] + 64
            mem[_104] = 26
            mem[_104 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _109 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _109 + 68] = mem[idx + _104 + 32]
                    idx = idx + 32
                    continue 
                mem[_109 + 94] = 0
                revert with memory
                  from mem[64]
                   len _109 + -mem[64] + 100
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 26
            mem[_133 + 32] = 'SafeMath: division by zero'
            if stor14 / totalSupply:
                return (stor1[address(arg1)] / stor14 / totalSupply)
            _139 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _139 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_139 + 94] = 0
            revert with memory
              from mem[64]
               len _139 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _107 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _107 + 68] = mem[idx + _101 + 32]
                idx = idx + 32
                continue 
            mem[_107 + 98] = 0
            revert with memory
              from mem[64]
               len _107 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _128 = mem[64]
        mem[64] = mem[64] + 64
        mem[_128] = 30
        mem[_128 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _135 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _135 + 68] = mem[idx + _128 + 32]
            idx = idx + 32
            continue 
        mem[_135 + 98] = 0
        revert with memory
          from mem[64]
           len _135 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor14 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor14 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / stor14 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor14:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor14
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _101 = mem[64]
                mem[64] = mem[64] + 64
                mem[_101] = 26
                mem[_101 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _106 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _106 + 68] = mem[idx + _101 + 32]
                        idx = idx + 32
                        continue 
                    mem[_106 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _106 + -mem[64] + 100
                _126 = mem[64]
                mem[64] = mem[64] + 64
                mem[_126] = 26
                mem[_126 + 32] = 'SafeMath: division by zero'
                if stor14 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor14 / totalSupply
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = arg1
                _135 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _135 + 68] = mem[idx + _126 + 32]
                    idx = idx + 32
                    continue 
                mem[_135 + 94] = 0
                revert with memory
                  from mem[64]
                   len _135 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _107 = mem[64]
                mem[64] = mem[64] + 64
                mem[_107] = 26
                mem[_107 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _112 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _112 + 68] = mem[idx + _107 + 32]
                        idx = idx + 32
                        continue 
                    mem[_112 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _112 + -mem[64] + 100
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if stor14 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor14 / totalSupply
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = arg1
                _142 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _142 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_142 + 94] = 0
                revert with memory
                  from mem[64]
                   len _142 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _104 = mem[64]
            mem[64] = mem[64] + 64
            mem[_104] = 30
            mem[_104 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _110 + 68] = mem[idx + _104 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 98] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 0, 17
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _131 = mem[64]
            mem[64] = mem[64] + 64
            mem[_131] = 30
            mem[_131 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _138 + 68] = mem[idx + _131 + 32]
                idx = idx + 32
                continue 
            mem[_138 + 98] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor14 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor14 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor14 / totalSupply
    stor4[address(arg1)] = 1
    stor5.length++
    stor36B6[stor5.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if not arg1:
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if not stor12:
                        revert with 0, 'SafeMath: division by zero', 0
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0 / stor12 / 100:
                        revert with 0, 17
                    mem[544] = 30
                    mem[576] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 > arg1 - (0 / stor12 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (0 / stor12 / 100) < 0 / stor12 / 100:
                        revert with 0, 17
                    mem[64] = 672
                    mem[608] = 30
                    mem[640] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 > arg1 - (2 * 0 / stor12 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (2 * 0 / stor12 / 100) < 0 / stor12 / 100:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor14
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _19208 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19208] = 26
                            mem[_19208 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _19281 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19281 + 68] = mem[idx + _19208 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19281 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _19281 + -mem[64] + 100
                            if not arg1:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    _20382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20382] = 30
                                    mem[_20382 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20632 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20632 + 68] = mem[idx + _20382 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20632 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20632 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21636] = 30
                                    mem[_21636 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        _22151 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22151 + 68] = mem[idx + _21636 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22151 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22151 + -mem[64] + 100
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24599] = 30
                                    mem[_24599 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                    _25645 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25645 + 68] = mem[idx + _24599 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25645 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25645 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    _21144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21144] = 30
                                    mem[_21144 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _21635 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21635 + 68] = mem[idx + _21144 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21635 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21635 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _23669 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23669] = 30
                                    mem[_23669 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        _24598 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24598 + 68] = mem[idx + _23669 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24598 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24598 + -mem[64] + 100
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _27947 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27947] = 30
                                    mem[_27947 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                        if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                            revert with 0, 17
                                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                    _29178 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _29178 + 68] = mem[idx + _27947 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29178 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29178 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _22848 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22848] = 30
                                mem[_22848 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _23668 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23668 + 68] = mem[idx + _22848 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23668 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23668 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _26710 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26710] = 30
                                mem[_26710 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _27946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27946 + 68] = mem[idx + _26710 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27946 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27946 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _31546 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31546] = 30
                                mem[_31546 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _32722 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32722 + 68] = mem[idx + _31546 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32722 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32722 + -mem[64] + 100
                            if arg1 and stor14 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20380 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20380] = 30
                                mem[_20380 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20631 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20631 + 68] = mem[idx + _20380 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20631 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20631 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21633 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21633] = 30
                                mem[_21633 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22149 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22149 + 68] = mem[idx + _21633 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22149 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22149 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24596] = 30
                                mem[_24596 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25644 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25644 + 68] = mem[idx + _24596 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25644 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25644 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21143] = 30
                                mem[_21143 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21632 + 68] = mem[idx + _21143 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21632 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21632 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23666 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23666] = 30
                                mem[_23666 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    _24595 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24595 + 68] = mem[idx + _23666 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24595 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24595 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _27944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27944] = 30
                                mem[_27944 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29176 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29176 + 68] = mem[idx + _27944 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29176 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29176 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _22847 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22847] = 30
                                mem[_22847 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _23665 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23665 + 68] = mem[idx + _22847 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23665 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23665 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _26708 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26708] = 30
                                mem[_26708 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    _27943 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27943 + 68] = mem[idx + _26708 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27943 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27943 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _31543 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31543] = 30
                                mem[_31543 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _32720 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32720 + 68] = mem[idx + _31543 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32720 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32720 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25643 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25643] = 30
                            mem[_25643 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _26707 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26707 + 68] = mem[idx + _25643 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26707 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26707 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _30313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30313] = 30
                            mem[_30313 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _31542 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31542 + 68] = mem[idx + _30313 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31542 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _31542 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _34543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34543] = 30
                            mem[_34543 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _35408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35408 + 68] = mem[idx + _34543 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35408 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _35408 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _19250 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19250] = 30
                            mem[_19250 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _19330 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19330 + 68] = mem[idx + _19250 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19330 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19330 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _19673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19673] = 30
                            mem[_19673 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _19730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19730 + 68] = mem[idx + _19673 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19730 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19730 + -mem[64] + 100
                        _19282 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19282] = 26
                        mem[_19282 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19370 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19370 + 68] = mem[idx + _19282 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19370 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19370 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20636 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20636] = 30
                                mem[_20636 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20815 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20815 + 68] = mem[idx + _20636 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20815 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20815 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22157 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22157] = 30
                                mem[_22157 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _22851 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22851 + 68] = mem[idx + _22157 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22851 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22851 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25651] = 30
                                mem[_25651 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _26714 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26714 + 68] = mem[idx + _25651 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26714 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26714 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21640 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21640] = 30
                                mem[_21640 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22156 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22156 + 68] = mem[idx + _21640 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22156 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22156 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _24605 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24605] = 30
                                mem[_24605 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _25650 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25650 + 68] = mem[idx + _24605 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25650 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25650 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _29184 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_29184] = 30
                                mem[_29184 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _30317 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _30317 + 68] = mem[idx + _29184 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30317 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _30317 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23672 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23672] = 30
                            mem[_23672 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _24604 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24604 + 68] = mem[idx + _23672 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24604 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24604 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27953] = 30
                            mem[_27953 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _29183 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29183 + 68] = mem[idx + _27953 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29183 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29183 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _32728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32728] = 30
                            mem[_32728 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _33597 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33597 + 68] = mem[idx + _32728 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33597 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33597 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _20634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20634] = 30
                            mem[_20634 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20814 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20814 + 68] = mem[idx + _20634 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20814 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20814 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22154 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22154] = 30
                            mem[_22154 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22849 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22849 + 68] = mem[idx + _22154 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22849 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22849 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25648 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25648] = 30
                            mem[_25648 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26713 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26713 + 68] = mem[idx + _25648 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26713 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26713 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21639] = 30
                            mem[_21639 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22153 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22153 + 68] = mem[idx + _21639 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22153 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22153 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24602] = 30
                            mem[_24602 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _25647 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25647 + 68] = mem[idx + _24602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25647 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25647 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29181 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29181] = 30
                            mem[_29181 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30315 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30315 + 68] = mem[idx + _29181 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30315 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30315 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _23671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23671] = 30
                            mem[_23671 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _24601 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24601 + 68] = mem[idx + _23671 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24601 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24601 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27951 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27951] = 30
                            mem[_27951 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _29180 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29180 + 68] = mem[idx + _27951 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29180 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29180 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _32725 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32725] = 30
                            mem[_32725 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _33595 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33595 + 68] = mem[idx + _32725 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33595 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33595 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _26712 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26712] = 30
                        mem[_26712 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _27950 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27950 + 68] = mem[idx + _26712 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27950 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27950 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31549 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31549] = 30
                        mem[_31549 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _32724 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32724 + 68] = mem[idx + _31549 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32724 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32724 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _35411 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35411] = 30
                        mem[_35411 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _35892 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35892 + 68] = mem[idx + _35411 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35892 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35892 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor14 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * t / s)
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor12 / 100:
                            return 0
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (2 * 0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19204 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19204] = 26
                        mem[_19204 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19278 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19278 + 68] = mem[idx + _19204 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19278 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19278 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20374 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20374] = 30
                                mem[_20374 + 32] = 'SafeMath: subtraction overflow'
                                _21620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21620] = 30
                                mem[_21620 + 32] = 'SafeMath: subtraction overflow'
                                _24574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24574] = 30
                                mem[_24574 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25628 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25628 + 68] = mem[idx + _24574 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25628 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25628 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20373] = 30
                                    mem[_20373 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20625 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20625 + 68] = mem[idx + _20373 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20625 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20625 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21618 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21618] = 30
                                    mem[_21618 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        _22138 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22138 + 68] = mem[idx + _21618 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22138 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22138 + -mem[64] + 100
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24572 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24572] = 30
                                    mem[_24572 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                    _25627 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25627 + 68] = mem[idx + _24572 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25627 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25627 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21133 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21133] = 30
                                mem[_21133 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21617 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21617 + 68] = mem[idx + _21133 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21617 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21617 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23648 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23648] = 30
                                mem[_23648 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24571 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24571 + 68] = mem[idx + _23648 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24571 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24571 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _27919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27919] = 30
                                mem[_27919 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                                _29155 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29155 + 68] = mem[idx + _27919 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29155 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29155 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21132 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21132] = 30
                                mem[_21132 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21616 + 68] = mem[idx + _21132 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21616 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21616 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23646 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23646] = 30
                                mem[_23646 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24570 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24570 + 68] = mem[idx + _23646 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24570 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24570 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27917 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27917] = 30
                                mem[_27917 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29154 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29154 + 68] = mem[idx + _27917 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29154 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29154 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22835 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22835] = 30
                            mem[_22835 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _23645 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23645 + 68] = mem[idx + _22835 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23645 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23645 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26689 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26689] = 30
                            mem[_26689 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _27916 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27916 + 68] = mem[idx + _26689 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27916 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27916 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31522] = 30
                            mem[_31522 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _32699 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32699 + 68] = mem[idx + _31522 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32699 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32699 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20371 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20371] = 30
                                mem[_20371 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20624 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20624 + 68] = mem[idx + _20371 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20624 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20624 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21614 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21614] = 30
                                mem[_21614 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22136 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22136 + 68] = mem[idx + _21614 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22136 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22136 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24568 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24568] = 30
                                mem[_24568 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25626 + 68] = mem[idx + _24568 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25626 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25626 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21131] = 30
                            mem[_21131 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21613 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21613 + 68] = mem[idx + _21131 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21613 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21613 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23643 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23643] = 30
                            mem[_23643 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _24567 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24567 + 68] = mem[idx + _23643 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24567 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24567 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _27914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27914] = 30
                            mem[_27914 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29152 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29152 + 68] = mem[idx + _27914 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29152 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29152 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21130 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21130] = 30
                                mem[_21130 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21612 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21612 + 68] = mem[idx + _21130 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21612 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21612 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23641] = 30
                                mem[_23641 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    _24566 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24566 + 68] = mem[idx + _23641 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24566 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24566 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _27912 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27912] = 30
                                mem[_27912 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29151 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29151 + 68] = mem[idx + _27912 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29151 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29151 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22834 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22834] = 30
                            mem[_22834 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23640 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23640 + 68] = mem[idx + _22834 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23640 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23640 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26687] = 30
                            mem[_26687 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _27911 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27911 + 68] = mem[idx + _26687 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27911 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27911 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31519] = 30
                            mem[_31519 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _32696 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32696 + 68] = mem[idx + _31519 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32696 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32696 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _22833 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22833] = 30
                            mem[_22833 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23639 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23639 + 68] = mem[idx + _22833 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23639 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23639 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26685 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26685] = 30
                            mem[_26685 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _27910 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27910 + 68] = mem[idx + _26685 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27910 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27910 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31517 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31517] = 30
                            mem[_31517 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _32695 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32695 + 68] = mem[idx + _31517 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32695 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32695 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25625 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25625] = 30
                        mem[_25625 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26684 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26684 + 68] = mem[idx + _25625 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26684 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26684 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30294 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30294] = 30
                        mem[_30294 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _31516 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31516 + 68] = mem[idx + _30294 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31516 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31516 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34523 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34523] = 30
                        mem[_34523 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _35390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35390 + 68] = mem[idx + _34523 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35390 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35390 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19249 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19249] = 30
                        mem[_19249 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19327 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19327 + 68] = mem[idx + _19249 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19327 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19327 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19671] = 30
                        mem[_19671 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19729 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19729 + 68] = mem[idx + _19671 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19729 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19729 + -mem[64] + 100
                    _19279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19279] = 26
                    mem[_19279 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19368 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19368 + 68] = mem[idx + _19279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19368 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19368 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20630] = 30
                            mem[_20630 + 32] = 'SafeMath: subtraction overflow'
                            _22148 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22148] = 30
                            mem[_22148 + 32] = 'SafeMath: subtraction overflow'
                            _25638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25638] = 30
                            mem[_25638 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26694 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26694 + 68] = mem[idx + _25638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26694 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26694 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20629] = 30
                                mem[_20629 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20812 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20812 + 68] = mem[idx + _20629 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20812 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20812 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22146 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22146] = 30
                                mem[_22146 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _22839 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22839 + 68] = mem[idx + _22146 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22839 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22839 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25636 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25636] = 30
                                mem[_25636 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _26693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26693 + 68] = mem[idx + _25636 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26693 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21625 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21625] = 30
                            mem[_21625 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22145 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22145 + 68] = mem[idx + _21625 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22145 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22145 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24584 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24584] = 30
                            mem[_24584 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25635 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25635 + 68] = mem[idx + _24584 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25635 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25635 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29167] = 30
                            mem[_29167 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _30300 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30300 + 68] = mem[idx + _29167 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30300 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30300 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21624] = 30
                            mem[_21624 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22144 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22144 + 68] = mem[idx + _21624 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22144 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22144 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24582] = 30
                            mem[_24582 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25634 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25634 + 68] = mem[idx + _24582 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25634 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25634 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29165 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29165] = 30
                            mem[_29165 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30299 + 68] = mem[idx + _29165 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30299 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30299 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23652] = 30
                        mem[_23652 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _24581 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24581 + 68] = mem[idx + _23652 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24581 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24581 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27927 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27927] = 30
                        mem[_27927 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _29164 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29164 + 68] = mem[idx + _27927 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29164 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29164 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32708 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32708] = 30
                        mem[_32708 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _33588 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33588 + 68] = mem[idx + _32708 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33588 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33588 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20627] = 30
                            mem[_20627 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20811 + 68] = mem[idx + _20627 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20811 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20811 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22142 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22142] = 30
                            mem[_22142 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22837 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22837 + 68] = mem[idx + _22142 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22837 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22837 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25632 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25632] = 30
                            mem[_25632 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26692 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26692 + 68] = mem[idx + _25632 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26692 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26692 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21623 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21623] = 30
                        mem[_21623 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22141 + 68] = mem[idx + _21623 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22141 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22141 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24579 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24579] = 30
                        mem[_24579 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _25631 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25631 + 68] = mem[idx + _24579 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25631 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25631 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _29162 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29162] = 30
                        mem[_29162 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30297 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30297 + 68] = mem[idx + _29162 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30297 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30297 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21622 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21622] = 30
                            mem[_21622 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22140 + 68] = mem[idx + _21622 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22140 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22140 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24577] = 30
                            mem[_24577 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _25630 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25630 + 68] = mem[idx + _24577 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25630 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25630 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29160 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29160] = 30
                            mem[_29160 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30296 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30296 + 68] = mem[idx + _29160 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30296 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30296 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23651 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23651] = 30
                        mem[_23651 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24576 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24576 + 68] = mem[idx + _23651 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24576 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24576 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27925 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27925] = 30
                        mem[_27925 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29159 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29159 + 68] = mem[idx + _27925 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29159 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29159 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _32705 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32705] = 30
                        mem[_32705 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _33585 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33585 + 68] = mem[idx + _32705 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33585 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33585 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _23650 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23650] = 30
                        mem[_23650 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24575 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24575 + 68] = mem[idx + _23650 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24575 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24575 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27923 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27923] = 30
                        mem[_27923 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29158 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29158 + 68] = mem[idx + _27923 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29158 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29158 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32703] = 30
                        mem[_32703 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _33584 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33584 + 68] = mem[idx + _32703 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33584 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33584 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26691 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26691] = 30
                    mem[_26691 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _27922 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27922 + 68] = mem[idx + _26691 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27922 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27922 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31526 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31526] = 30
                    mem[_31526 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _32702 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32702 + 68] = mem[idx + _31526 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32702 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32702 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35394 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35394] = 30
                    mem[_35394 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _35888 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35888 + 68] = mem[idx + _35394 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35888 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35888 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * t / s)
                            if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19200 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19200] = 26
                        mem[_19200 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19275 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19275 + 68] = mem[idx + _19200 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19275 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19275 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor12 / 100:
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    if not 0 / stor12 / 100:
                                        return 0
                                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20365 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20365] = 30
                                    mem[_20365 + 32] = 'SafeMath: subtraction overflow'
                                    _21598 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21598] = 30
                                    mem[_21598 + 32] = 'SafeMath: subtraction overflow'
                                    _24539 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24539] = 30
                                    mem[_24539 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                            revert with 0, 17
                                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                    _25604 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25604 + 68] = mem[idx + _24539 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25604 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25604 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    _20364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20364] = 30
                                    mem[_20364 + 32] = 'SafeMath: subtraction overflow'
                                    _21597 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21597] = 30
                                    mem[_21597 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22118 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22118 + 68] = mem[idx + _21597 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22118 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22118 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24537 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24537] = 30
                                    mem[_24537 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                                    _25603 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25603 + 68] = mem[idx + _24537 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25603 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25603 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21117] = 30
                                mem[_21117 + 32] = 'SafeMath: subtraction overflow'
                                _23616 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23616] = 30
                                mem[_23616 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24536 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24536 + 68] = mem[idx + _23616 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24536 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24536 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27878 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27878] = 30
                                mem[_27878 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29123 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29123 + 68] = mem[idx + _27878 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29123 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29123 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    _20363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20363] = 30
                                    mem[_20363 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20616 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20616 + 68] = mem[idx + _20363 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20616 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20616 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21595 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21595] = 30
                                    mem[_21595 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        _22117 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22117 + 68] = mem[idx + _21595 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22117 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22117 + -mem[64] + 100
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24534 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24534] = 30
                                    mem[_24534 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                    _25602 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25602 + 68] = mem[idx + _24534 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25602 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25602 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21116 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21116] = 30
                                mem[_21116 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21594 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21594 + 68] = mem[idx + _21116 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21594 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21594 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23614 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23614] = 30
                                mem[_23614 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24533 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24533 + 68] = mem[idx + _23614 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24533 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24533 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _27876 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27876] = 30
                                mem[_27876 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29121 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29121 + 68] = mem[idx + _27876 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29121 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29121 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21115] = 30
                                mem[_21115 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21593 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21593 + 68] = mem[idx + _21115 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21593 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21593 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23612] = 30
                                mem[_23612 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24532 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24532 + 68] = mem[idx + _23612 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24532 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24532 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27874 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27874] = 30
                                mem[_27874 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                                _29120 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29120 + 68] = mem[idx + _27874 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29120 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29120 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22815 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22815] = 30
                            mem[_22815 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _23611 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23611 + 68] = mem[idx + _22815 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23611 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23611 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26655] = 30
                            mem[_26655 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _27873 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27873 + 68] = mem[idx + _26655 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27873 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27873 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31485 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31485] = 30
                            mem[_31485 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _32664 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32664 + 68] = mem[idx + _31485 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32664 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32664 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    _20361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20361] = 30
                                    mem[_20361 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _20615 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20615 + 68] = mem[idx + _20361 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20615 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20615 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _21591 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21591] = 30
                                    mem[_21591 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _22115 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22115 + 68] = mem[idx + _21591 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22115 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22115 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24530 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24530] = 30
                                    mem[_24530 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor14 / totalSupply:
                                        if arg1 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor14 / totalSupply)
                                    _25601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25601 + 68] = mem[idx + _24530 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25601 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25601 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21114 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21114] = 30
                                mem[_21114 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21590 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21590 + 68] = mem[idx + _21114 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21590 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21590 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23609 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23609] = 30
                                mem[_23609 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _24529 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24529 + 68] = mem[idx + _23609 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24529 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24529 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _27871 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27871] = 30
                                mem[_27871 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29118 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29118 + 68] = mem[idx + _27871 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29118 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29118 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21113 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21113] = 30
                                mem[_21113 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21589 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21589 + 68] = mem[idx + _21113 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21589 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21589 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23607] = 30
                                mem[_23607 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24528 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24528 + 68] = mem[idx + _23607 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24528 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24528 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27869 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27869] = 30
                                mem[_27869 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                                _29117 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29117 + 68] = mem[idx + _27869 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29117 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29117 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22814 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22814] = 30
                            mem[_22814 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23606 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23606 + 68] = mem[idx + _22814 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23606 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23606 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26653] = 30
                            mem[_26653 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _27868 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27868 + 68] = mem[idx + _26653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27868 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27868 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31482 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31482] = 30
                            mem[_31482 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _32661 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32661 + 68] = mem[idx + _31482 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32661 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32661 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _21112 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21112] = 30
                                mem[_21112 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21588 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21588 + 68] = mem[idx + _21112 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21588 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21588 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23604 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23604] = 30
                                mem[_23604 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    _24527 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24527 + 68] = mem[idx + _23604 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24527 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24527 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _27866 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27866] = 30
                                mem[_27866 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29116 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29116 + 68] = mem[idx + _27866 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29116 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29116 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22813 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22813] = 30
                            mem[_22813 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23603 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23603 + 68] = mem[idx + _22813 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23603 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23603 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26651 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26651] = 30
                            mem[_26651 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _27865 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27865 + 68] = mem[idx + _26651 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27865 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27865 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31480 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31480] = 30
                            mem[_31480 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _32659 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32659 + 68] = mem[idx + _31480 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32659 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32659 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _22812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22812] = 30
                            mem[_22812 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23602 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23602 + 68] = mem[idx + _22812 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23602 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23602 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26649] = 30
                            mem[_26649 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _27864 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27864 + 68] = mem[idx + _26649 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27864 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27864 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31478 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31478] = 30
                            mem[_31478 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                            _32658 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32658 + 68] = mem[idx + _31478 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32658 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32658 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25600 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25600] = 30
                        mem[_25600 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26648 + 68] = mem[idx + _25600 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26648 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26648 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30268 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30268] = 30
                        mem[_30268 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _31477 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31477 + 68] = mem[idx + _30268 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31477 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31477 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34495 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34495] = 30
                        mem[_34495 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _35363 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35363 + 68] = mem[idx + _34495 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35363 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35363 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19248 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19248] = 30
                        mem[_19248 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19324 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19324 + 68] = mem[idx + _19248 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19324 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19324 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19669] = 30
                        mem[_19669 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19728 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19728 + 68] = mem[idx + _19669 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19728 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19728 + -mem[64] + 100
                    _19276 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19276] = 26
                    mem[_19276 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19366 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19366 + 68] = mem[idx + _19276 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19366 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19366 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20623 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20623] = 30
                                mem[_20623 + 32] = 'SafeMath: subtraction overflow'
                                _22130 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22130] = 30
                                mem[_22130 + 32] = 'SafeMath: subtraction overflow'
                                _25618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25618] = 30
                                mem[_25618 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _26661 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26661 + 68] = mem[idx + _25618 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26661 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26661 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20622] = 30
                                mem[_20622 + 32] = 'SafeMath: subtraction overflow'
                                _22129 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22129] = 30
                                mem[_22129 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22821 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22821 + 68] = mem[idx + _22129 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22821 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22821 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25616 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25616] = 30
                                mem[_25616 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                                _26660 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26660 + 68] = mem[idx + _25616 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26660 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26660 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21605 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21605] = 30
                            mem[_21605 + 32] = 'SafeMath: subtraction overflow'
                            _24554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24554] = 30
                            mem[_24554 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _25615 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25615 + 68] = mem[idx + _24554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25615 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25615 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29140] = 30
                            mem[_29140 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30277 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30277 + 68] = mem[idx + _29140 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30277 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30277 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20621] = 30
                                mem[_20621 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20805 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20805 + 68] = mem[idx + _20621 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20805 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20805 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22127 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22127] = 30
                                mem[_22127 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _22820 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22820 + 68] = mem[idx + _22127 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22820 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22820 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25613 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25613] = 30
                                mem[_25613 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _26659 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26659 + 68] = mem[idx + _25613 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26659 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26659 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21604 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21604] = 30
                            mem[_21604 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22126 + 68] = mem[idx + _21604 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22126 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22126 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24552 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24552] = 30
                            mem[_24552 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25612 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25612 + 68] = mem[idx + _24552 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25612 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25612 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29138 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29138] = 30
                            mem[_29138 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30275 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30275 + 68] = mem[idx + _29138 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30275 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30275 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21603 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21603] = 30
                            mem[_21603 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22125 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22125 + 68] = mem[idx + _21603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22125 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22125 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24550 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24550] = 30
                            mem[_24550 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25611 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25611 + 68] = mem[idx + _24550 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25611 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25611 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29136 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29136] = 30
                            mem[_29136 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                            _30274 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30274 + 68] = mem[idx + _29136 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30274 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30274 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23620 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23620] = 30
                        mem[_23620 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _24549 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24549 + 68] = mem[idx + _23620 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24549 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24549 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27888 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27888] = 30
                        mem[_27888 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _29135 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29135 + 68] = mem[idx + _27888 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29135 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29135 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32676 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32676] = 30
                        mem[_32676 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _33576 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33576 + 68] = mem[idx + _32676 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33576 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33576 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20619 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20619] = 30
                                mem[_20619 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20804 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20804 + 68] = mem[idx + _20619 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20804 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20804 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _22123 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22123] = 30
                                mem[_22123 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22818 + 68] = mem[idx + _22123 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22818 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22818 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25609 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25609] = 30
                                mem[_25609 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _26658 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26658 + 68] = mem[idx + _25609 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26658 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26658 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21602] = 30
                            mem[_21602 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22122 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22122 + 68] = mem[idx + _21602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22122 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22122 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24547 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24547] = 30
                            mem[_24547 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _25608 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25608 + 68] = mem[idx + _24547 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25608 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25608 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29133] = 30
                            mem[_29133 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30272 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30272 + 68] = mem[idx + _29133 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30272 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30272 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21601 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21601] = 30
                            mem[_21601 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22121 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22121 + 68] = mem[idx + _21601 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22121 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22121 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24545] = 30
                            mem[_24545 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25607 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25607 + 68] = mem[idx + _24545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25607 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25607 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29131] = 30
                            mem[_29131 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                            _30271 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30271 + 68] = mem[idx + _29131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30271 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30271 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23619 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23619] = 30
                        mem[_23619 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24544 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24544 + 68] = mem[idx + _23619 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24544 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24544 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _27886 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27886] = 30
                        mem[_27886 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29130 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29130 + 68] = mem[idx + _27886 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29130 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29130 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32673 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32673] = 30
                        mem[_32673 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _33573 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33573 + 68] = mem[idx + _32673 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33573 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33573 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _21600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21600] = 30
                            mem[_21600 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22120 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22120 + 68] = mem[idx + _21600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22120 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22120 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24542 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24542] = 30
                            mem[_24542 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _25606 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25606 + 68] = mem[idx + _24542 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25606 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25606 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29128] = 30
                            mem[_29128 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30270 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30270 + 68] = mem[idx + _29128 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30270 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30270 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23618 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23618] = 30
                        mem[_23618 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24541 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24541 + 68] = mem[idx + _23618 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24541 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24541 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27884 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27884] = 30
                        mem[_27884 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29127 + 68] = mem[idx + _27884 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29127 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29127 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _32671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32671] = 30
                        mem[_32671 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _33571 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33571 + 68] = mem[idx + _32671 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33571 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33571 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _23617 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23617] = 30
                        mem[_23617 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24540 + 68] = mem[idx + _23617 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24540 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27882 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27882] = 30
                        mem[_27882 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29126 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29126 + 68] = mem[idx + _27882 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29126 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29126 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32669] = 30
                        mem[_32669 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _33570 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33570 + 68] = mem[idx + _32669 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33570 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33570 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26657 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26657] = 30
                    mem[_26657 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _27881 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27881 + 68] = mem[idx + _26657 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27881 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27881 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31490 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31490] = 30
                    mem[_31490 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _32668 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32668 + 68] = mem[idx + _31490 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32668 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32668 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35368 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35368] = 30
                    mem[_35368 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    _35883 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35883 + 68] = mem[idx + _35368 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35883 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35883 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * t / s)
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s)
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * t / s)
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                return (arg1 * t / s)
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
            if arg1 and _CHARITY_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 / stor12 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0 / stor12 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (0 / stor12 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor14
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _19196 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19196] = 26
                    mem[_19196 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19272 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19272 + 68] = mem[idx + _19196 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19272 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19272 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20352] = 30
                                mem[_20352 + 32] = 'SafeMath: subtraction overflow'
                                _21574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21574] = 30
                                mem[_21574 + 32] = 'SafeMath: subtraction overflow'
                                _24496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24496] = 30
                                mem[_24496 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25577 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25577 + 68] = mem[idx + _24496 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25577 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25577 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20351 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20351] = 30
                                mem[_20351 + 32] = 'SafeMath: subtraction overflow'
                                _21573 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21573] = 30
                                mem[_21573 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22094 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22094 + 68] = mem[idx + _21573 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22094 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22094 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _24494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24494] = 30
                                mem[_24494 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25576 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25576 + 68] = mem[idx + _24494 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25576 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25576 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21095 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21095] = 30
                            mem[_21095 + 32] = 'SafeMath: subtraction overflow'
                            _23575 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23575] = 30
                            mem[_23575 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _24493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24493 + 68] = mem[idx + _23575 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24493 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24493 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27824 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27824] = 30
                            mem[_27824 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29086 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29086 + 68] = mem[idx + _27824 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29086 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29086 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20350 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20350] = 30
                                mem[_20350 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20607 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20607 + 68] = mem[idx + _20350 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20607 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20607 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _21571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21571] = 30
                                mem[_21571 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _22093 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22093 + 68] = mem[idx + _21571 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22093 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22093 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24491 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24491] = 30
                                mem[_24491 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _25575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25575 + 68] = mem[idx + _24491 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25575 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25575 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21094 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21094] = 30
                            mem[_21094 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _21570 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21570 + 68] = mem[idx + _21094 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21570 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21570 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23573] = 30
                            mem[_23573 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _24490 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24490 + 68] = mem[idx + _23573 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24490 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24490 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _27822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27822] = 30
                            mem[_27822 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29084 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29084 + 68] = mem[idx + _27822 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29084 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29084 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21093 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21093] = 30
                            mem[_21093 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _21569 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21569 + 68] = mem[idx + _21093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21569 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21569 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23571] = 30
                            mem[_23571 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _24489 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24489 + 68] = mem[idx + _23571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24489 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24489 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27820 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27820] = 30
                            mem[_27820 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29083 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29083 + 68] = mem[idx + _27820 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29083 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29083 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22790] = 30
                        mem[_22790 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _23570 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23570 + 68] = mem[idx + _22790 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23570 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23570 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26611] = 30
                        mem[_26611 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _27819 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27819 + 68] = mem[idx + _26611 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27819 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27819 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31436] = 30
                        mem[_31436 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32621 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32621 + 68] = mem[idx + _31436 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32621 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32621 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20348 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20348] = 30
                                mem[_20348 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20606 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20606 + 68] = mem[idx + _20348 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20606 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20606 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21567 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21567] = 30
                                mem[_21567 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22091 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22091 + 68] = mem[idx + _21567 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22091 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22091 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24487] = 30
                                mem[_24487 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25574 + 68] = mem[idx + _24487 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25574 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25574 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21092 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21092] = 30
                            mem[_21092 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21566 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21566 + 68] = mem[idx + _21092 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21566 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21566 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23568] = 30
                            mem[_23568 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _24486 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24486 + 68] = mem[idx + _23568 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24486 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24486 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _27817 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27817] = 30
                            mem[_27817 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29081 + 68] = mem[idx + _27817 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29081 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29081 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21091 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21091] = 30
                            mem[_21091 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21565 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21565 + 68] = mem[idx + _21091 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21565 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21565 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23566] = 30
                            mem[_23566 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _24485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24485 + 68] = mem[idx + _23566 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24485 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24485 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27815 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27815] = 30
                            mem[_27815 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29080 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29080 + 68] = mem[idx + _27815 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29080 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29080 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22789] = 30
                        mem[_22789 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _23565 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23565 + 68] = mem[idx + _22789 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23565 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23565 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _26609 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26609] = 30
                        mem[_26609 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _27814 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27814 + 68] = mem[idx + _26609 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27814 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27814 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31433 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31433] = 30
                        mem[_31433 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32618 + 68] = mem[idx + _31433 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32618 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32618 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21090] = 30
                            mem[_21090 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _21564 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21564 + 68] = mem[idx + _21090 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21564 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21564 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23563] = 30
                            mem[_23563 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _24484 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24484 + 68] = mem[idx + _23563 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24484 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24484 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _27812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27812] = 30
                            mem[_27812 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _29079 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29079 + 68] = mem[idx + _27812 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29079 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29079 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22788 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22788] = 30
                        mem[_22788 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _23562 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23562 + 68] = mem[idx + _22788 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23562 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23562 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26607] = 30
                        mem[_26607 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _27811 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27811 + 68] = mem[idx + _26607 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27811 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27811 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _31431 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31431] = 30
                        mem[_31431 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32616 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32616 + 68] = mem[idx + _31431 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32616 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32616 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _22787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22787] = 30
                        mem[_22787 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _23561 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23561 + 68] = mem[idx + _22787 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23561 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23561 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26605 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26605] = 30
                        mem[_26605 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _27810 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27810 + 68] = mem[idx + _26605 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27810 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27810 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31429 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31429] = 30
                        mem[_31429 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32615 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32615 + 68] = mem[idx + _31429 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32615 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32615 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25573 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25573] = 30
                    mem[_25573 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _26604 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26604 + 68] = mem[idx + _25573 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26604 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26604 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _30238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30238] = 30
                    mem[_30238 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _31428 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31428 + 68] = mem[idx + _30238 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31428 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31428 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _34461 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34461] = 30
                    mem[_34461 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _35330 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35330 + 68] = mem[idx + _34461 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35330 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35330 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] <= s:
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    _19247 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19247] = 30
                    mem[_19247 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor5[idx]] > t:
                        _19321 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19321 + 68] = mem[idx + _19247 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19321 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19321 + -mem[64] + 100
                    if t < stor1[stor5[idx]]:
                        revert with 0, 17
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    _19667 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19667] = 30
                    mem[_19667 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor5[idx]] <= s:
                        if s < stor2[stor5[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor5[idx]]
                        t = t - stor1[stor5[idx]]
                        continue 
                    _19727 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19727 + 68] = mem[idx + _19667 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19727 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19727 + -mem[64] + 100
                _19273 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19273] = 26
                mem[_19273 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19364 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19364 + 68] = mem[idx + _19273 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19364 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19364 + -mem[64] + 100
                if not arg1:
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20614] = 30
                            mem[_20614 + 32] = 'SafeMath: subtraction overflow'
                            _22106 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22106] = 30
                            mem[_22106 + 32] = 'SafeMath: subtraction overflow'
                            _25591 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25591] = 30
                            mem[_25591 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26617 + 68] = mem[idx + _25591 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26617 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26617 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20613 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20613] = 30
                            mem[_20613 + 32] = 'SafeMath: subtraction overflow'
                            _22105 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22105] = 30
                            mem[_22105 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22796 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22796 + 68] = mem[idx + _22105 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22796 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22796 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _25589 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25589] = 30
                            mem[_25589 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26616 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26616 + 68] = mem[idx + _25589 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26616 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26616 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21581 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21581] = 30
                        mem[_21581 + 32] = 'SafeMath: subtraction overflow'
                        _24511 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24511] = 30
                        mem[_24511 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _25588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25588 + 68] = mem[idx + _24511 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25588 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25588 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _29103 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29103] = 30
                        mem[_29103 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30247 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30247 + 68] = mem[idx + _29103 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30247 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30247 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20612] = 30
                            mem[_20612 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _20797 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20797 + 68] = mem[idx + _20612 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20797 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20797 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _22103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22103] = 30
                            mem[_22103 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _22795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22795 + 68] = mem[idx + _22103 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22795 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22795 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25586] = 30
                            mem[_25586 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                            _26615 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26615 + 68] = mem[idx + _25586 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26615 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26615 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21580 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21580] = 30
                        mem[_21580 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _22102 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22102 + 68] = mem[idx + _21580 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22102 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22102 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24509 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24509] = 30
                        mem[_24509 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _25585 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25585 + 68] = mem[idx + _24509 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25585 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25585 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _29101 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29101] = 30
                        mem[_29101 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30245 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30245 + 68] = mem[idx + _29101 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30245 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30245 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21579 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21579] = 30
                        mem[_21579 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _22101 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22101 + 68] = mem[idx + _21579 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22101 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22101 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24507 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24507] = 30
                        mem[_24507 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _25584 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25584 + 68] = mem[idx + _24507 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25584 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25584 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _29099 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29099] = 30
                        mem[_29099 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30244 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30244 + 68] = mem[idx + _29099 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30244 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30244 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23579 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23579] = 30
                    mem[_23579 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                        _24506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24506 + 68] = mem[idx + _23579 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24506 + -mem[64] + 100
                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27834 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27834] = 30
                    mem[_27834 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                        _29098 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29098 + 68] = mem[idx + _27834 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29098 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29098 + -mem[64] + 100
                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32633 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32633] = 30
                    mem[_32633 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33562 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33562 + 68] = mem[idx + _32633 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33562 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33562 + -mem[64] + 100
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20610 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20610] = 30
                            mem[_20610 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20796 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20796 + 68] = mem[idx + _20610 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20796 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20796 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22099 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22099] = 30
                            mem[_22099 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22793 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22793 + 68] = mem[idx + _22099 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22793 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22793 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25582] = 30
                            mem[_25582 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26614 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26614 + 68] = mem[idx + _25582 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26614 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26614 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21578 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21578] = 30
                        mem[_21578 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22098 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22098 + 68] = mem[idx + _21578 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22098 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22098 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24504] = 30
                        mem[_24504 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _25581 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25581 + 68] = mem[idx + _24504 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25581 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25581 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _29096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29096] = 30
                        mem[_29096 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30242 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30242 + 68] = mem[idx + _29096 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30242 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30242 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21577 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21577] = 30
                        mem[_21577 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22097 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22097 + 68] = mem[idx + _21577 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22097 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22097 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24502] = 30
                        mem[_24502 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _25580 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25580 + 68] = mem[idx + _24502 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25580 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25580 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _29094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29094] = 30
                        mem[_29094 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30241 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30241 + 68] = mem[idx + _29094 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30241 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30241 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23578 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23578] = 30
                    mem[_23578 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        _24501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24501 + 68] = mem[idx + _23578 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24501 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24501 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _27832 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27832] = 30
                    mem[_27832 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _29093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29093 + 68] = mem[idx + _27832 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29093 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29093 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32630 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32630] = 30
                    mem[_32630 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33559 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33559 + 68] = mem[idx + _32630 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33559 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33559 + -mem[64] + 100
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21576 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21576] = 30
                        mem[_21576 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _22096 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22096 + 68] = mem[idx + _21576 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22096 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22096 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24499] = 30
                        mem[_24499 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _25579 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25579 + 68] = mem[idx + _24499 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25579 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25579 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _29091 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29091] = 30
                        mem[_29091 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _30240 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30240 + 68] = mem[idx + _29091 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30240 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30240 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23577 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23577] = 30
                    mem[_23577 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _24498 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24498 + 68] = mem[idx + _23577 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24498 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24498 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27830 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27830] = 30
                    mem[_27830 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _29090 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29090 + 68] = mem[idx + _27830 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29090 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29090 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    _32628 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32628] = 30
                    mem[_32628 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33557 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33557 + 68] = mem[idx + _32628 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33557 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33557 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    _23576 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23576] = 30
                    mem[_23576 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _24497 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24497 + 68] = mem[idx + _23576 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24497 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24497 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27828 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27828] = 30
                    mem[_27828 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _29089 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29089 + 68] = mem[idx + _27828 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29089 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29089 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32626 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32626] = 30
                    mem[_32626 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33556 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33556 + 68] = mem[idx + _32626 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33556 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33556 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26613 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26613] = 30
                mem[_26613 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    _27827 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27827 + 68] = mem[idx + _26613 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27827 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27827 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _31441 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31441] = 30
                mem[_31441 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    _32625 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32625 + 68] = mem[idx + _31441 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32625 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32625 + -mem[64] + 100
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _35335 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35335] = 30
                mem[_35335 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                _35878 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35878 + 68] = mem[idx + _35335 + 32]
                    idx = idx + 32
                    continue 
                mem[_35878 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35878 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor14 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not 0 / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 and stor14 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor12 / 100:
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                revert with 0, 17
            if not 0 / stor12 / 100:
                revert with 0, 18
            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor12 / 100:
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor12:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19192 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19192] = 26
                        mem[_19192 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19269 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19269 + 68] = mem[idx + _19192 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19269 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19269 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    _20340 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20340] = 30
                                    mem[_20340 + 32] = 'SafeMath: subtraction overflow'
                                    _21552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21552] = 30
                                    mem[_21552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22073 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22073 + 68] = mem[idx + _21552 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22073 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22073 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24457 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24457] = 30
                                    mem[_24457 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                    _25553 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25553 + 68] = mem[idx + _24457 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25553 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25553 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21075] = 30
                                mem[_21075 + 32] = 'SafeMath: subtraction overflow'
                                _23535 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23535] = 30
                                mem[_23535 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24456 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24456 + 68] = mem[idx + _23535 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24456 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24456 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27772] = 30
                                mem[_27772 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29055 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29055 + 68] = mem[idx + _27772 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29055 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29055 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20339] = 30
                                mem[_20339 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20599 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20599 + 68] = mem[idx + _20339 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20599 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20599 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _21550 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21550] = 30
                                mem[_21550 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _22072 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22072 + 68] = mem[idx + _21550 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22072 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22072 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24454 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24454] = 30
                                mem[_24454 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25552 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25552 + 68] = mem[idx + _24454 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25552 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25552 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21074] = 30
                                mem[_21074 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21549 + 68] = mem[idx + _21074 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21549 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23533 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23533] = 30
                                mem[_23533 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24453 + 68] = mem[idx + _23533 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24453 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24453 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27770 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27770] = 30
                                mem[_27770 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29053 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29053 + 68] = mem[idx + _27770 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29053 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29053 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22766 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22766] = 30
                            mem[_22766 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _23532 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23532 + 68] = mem[idx + _22766 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23532 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23532 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26568] = 30
                            mem[_26568 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _27769 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27769 + 68] = mem[idx + _26568 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27769 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27769 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31388 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31388] = 30
                            mem[_31388 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _32582 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32582 + 68] = mem[idx + _31388 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32582 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32582 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20337] = 30
                                mem[_20337 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20598 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20598 + 68] = mem[idx + _20337 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20598 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20598 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21547 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21547] = 30
                                mem[_21547 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22070 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22070 + 68] = mem[idx + _21547 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22070 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22070 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24451 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24451] = 30
                                mem[_24451 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25551 + 68] = mem[idx + _24451 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25551 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21073] = 30
                                mem[_21073 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21546 + 68] = mem[idx + _21073 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21546 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21546 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23530] = 30
                                mem[_23530 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24450 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24450 + 68] = mem[idx + _23530 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24450 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24450 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27767 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27767] = 30
                                mem[_27767 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                                _29051 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29051 + 68] = mem[idx + _27767 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29051 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29051 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22765 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22765] = 30
                            mem[_22765 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23529 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23529 + 68] = mem[idx + _22765 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23529 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23529 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26566] = 30
                            mem[_26566 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _27766 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27766 + 68] = mem[idx + _26566 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27766 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27766 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31385] = 30
                            mem[_31385 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _32580 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32580 + 68] = mem[idx + _31385 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32580 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32580 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21072 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21072] = 30
                            mem[_21072 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _21545 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21545 + 68] = mem[idx + _21072 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21545 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21545 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23527 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23527] = 30
                            mem[_23527 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _24449 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24449 + 68] = mem[idx + _23527 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24449 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24449 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _27764 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27764] = 30
                            mem[_27764 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29050 + 68] = mem[idx + _27764 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29050 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29050 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _22764 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22764] = 30
                            mem[_22764 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23526 + 68] = mem[idx + _22764 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23526 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23526 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26564 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26564] = 30
                            mem[_26564 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _27763 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27763 + 68] = mem[idx + _26564 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27763 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27763 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31383 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31383] = 30
                            mem[_31383 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _32578 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32578 + 68] = mem[idx + _31383 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32578 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32578 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25550] = 30
                        mem[_25550 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26563 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26563 + 68] = mem[idx + _25550 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26563 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26563 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30211 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30211] = 30
                        mem[_30211 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _31382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31382 + 68] = mem[idx + _30211 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31382 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34429 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34429] = 30
                        mem[_34429 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _35300 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35300 + 68] = mem[idx + _34429 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35300 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35300 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19246 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19246] = 30
                        mem[_19246 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19318 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19318 + 68] = mem[idx + _19246 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19318 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19318 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19665 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19665] = 30
                        mem[_19665 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19726 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19726 + 68] = mem[idx + _19665 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19726 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19726 + -mem[64] + 100
                    _19270 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19270] = 26
                    mem[_19270 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19362 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19362 + 68] = mem[idx + _19270 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19362 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19362 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20605 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20605] = 30
                                mem[_20605 + 32] = 'SafeMath: subtraction overflow'
                                _22082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22082] = 30
                                mem[_22082 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22771 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22771 + 68] = mem[idx + _22082 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22771 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22771 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25563 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25563] = 30
                                mem[_25563 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _26573 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26573 + 68] = mem[idx + _25563 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26573 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26573 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21557] = 30
                            mem[_21557 + 32] = 'SafeMath: subtraction overflow'
                            _24468 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24468] = 30
                            mem[_24468 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _25562 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25562 + 68] = mem[idx + _24468 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25562 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25562 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29066] = 30
                            mem[_29066 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30218 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30218 + 68] = mem[idx + _29066 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30218 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30218 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _20604 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20604] = 30
                            mem[_20604 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _20789 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20789 + 68] = mem[idx + _20604 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20789 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20789 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _22080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22080] = 30
                            mem[_22080 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _22770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22770 + 68] = mem[idx + _22080 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22770 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22770 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25560 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25560] = 30
                            mem[_25560 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26572 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26572 + 68] = mem[idx + _25560 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26572 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26572 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21556] = 30
                            mem[_21556 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22079 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22079 + 68] = mem[idx + _21556 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22079 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22079 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24466 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24466] = 30
                            mem[_24466 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25559 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25559 + 68] = mem[idx + _24466 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25559 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25559 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29064 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29064] = 30
                            mem[_29064 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30216 + 68] = mem[idx + _29064 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30216 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30216 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23538 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23538] = 30
                        mem[_23538 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _24465 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24465 + 68] = mem[idx + _23538 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24465 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24465 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27780 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27780] = 30
                        mem[_27780 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _29063 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29063 + 68] = mem[idx + _27780 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29063 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29063 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32591 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32591] = 30
                        mem[_32591 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _33549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33549 + 68] = mem[idx + _32591 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33549 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33549 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _20602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20602] = 30
                            mem[_20602 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20788 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20788 + 68] = mem[idx + _20602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20788 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20788 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22077 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22077] = 30
                            mem[_22077 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22768 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22768 + 68] = mem[idx + _22077 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22768 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22768 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25557] = 30
                            mem[_25557 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26571 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26571 + 68] = mem[idx + _25557 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26571 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26571 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21555 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21555] = 30
                            mem[_21555 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22076 + 68] = mem[idx + _21555 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22076 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22076 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24463 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24463] = 30
                            mem[_24463 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25556 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25556 + 68] = mem[idx + _24463 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25556 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25556 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29061 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29061] = 30
                            mem[_29061 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _30214 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30214 + 68] = mem[idx + _29061 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30214 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30214 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23537 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23537] = 30
                        mem[_23537 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24462 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24462 + 68] = mem[idx + _23537 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24462 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24462 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _27778 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27778] = 30
                        mem[_27778 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29060 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29060 + 68] = mem[idx + _27778 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29060 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29060 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32588] = 30
                        mem[_32588 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _33547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33547 + 68] = mem[idx + _32588 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33547 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33547 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _21554 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21554] = 30
                        mem[_21554 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _22075 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22075 + 68] = mem[idx + _21554 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22075 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22075 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24460 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24460] = 30
                        mem[_24460 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _25555 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25555 + 68] = mem[idx + _24460 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25555 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25555 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _29058 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29058] = 30
                        mem[_29058 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30213 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30213 + 68] = mem[idx + _29058 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30213 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30213 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _23536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23536] = 30
                        mem[_23536 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24459 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24459 + 68] = mem[idx + _23536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24459 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24459 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27776 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27776] = 30
                        mem[_27776 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29057 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29057 + 68] = mem[idx + _27776 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29057 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29057 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32586 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32586] = 30
                        mem[_32586 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _33545 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33545 + 68] = mem[idx + _32586 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33545 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33545 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26570] = 30
                    mem[_26570 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _27775 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27775 + 68] = mem[idx + _26570 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27775 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27775 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31392] = 30
                    mem[_31392 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _32585 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32585 + 68] = mem[idx + _31392 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32585 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32585 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35304 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35304] = 30
                    mem[_35304 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    _35874 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35874 + 68] = mem[idx + _35304 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35874 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35874 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * t / s)
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                        if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            return 0
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
            if arg1 and _CHARITY_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor12 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < 0 / stor12 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor14
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _19188 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19188] = 26
                    mem[_19188 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19266 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19266 + 68] = mem[idx + _19188 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19266 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19266 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20328] = 30
                                mem[_20328 + 32] = 'SafeMath: subtraction overflow'
                                _21531 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21531] = 30
                                mem[_21531 + 32] = 'SafeMath: subtraction overflow'
                                _24420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24420] = 30
                                mem[_24420 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25529 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25529 + 68] = mem[idx + _24420 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25529 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25529 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20327] = 30
                                mem[_20327 + 32] = 'SafeMath: subtraction overflow'
                                _21530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21530] = 30
                                mem[_21530 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22054 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22054 + 68] = mem[idx + _21530 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22054 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22054 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _24418 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24418] = 30
                                mem[_24418 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _25528 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25528 + 68] = mem[idx + _24418 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25528 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25528 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21057 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21057] = 30
                            mem[_21057 + 32] = 'SafeMath: subtraction overflow'
                            _23505 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23505] = 30
                            mem[_23505 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _24417 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24417 + 68] = mem[idx + _23505 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24417 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24417 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27729] = 30
                            mem[_27729 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29022 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29022 + 68] = mem[idx + _27729 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29022 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29022 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20326] = 30
                                mem[_20326 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20590 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20590 + 68] = mem[idx + _20326 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20590 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20590 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _21528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21528] = 30
                                mem[_21528 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _22053 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22053 + 68] = mem[idx + _21528 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22053 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22053 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24415 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24415] = 30
                                mem[_24415 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25527 + 68] = mem[idx + _24415 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25527 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25527 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21056 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21056] = 30
                            mem[_21056 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _21527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21527 + 68] = mem[idx + _21056 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21527 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21527 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23503] = 30
                            mem[_23503 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _24414 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24414 + 68] = mem[idx + _23503 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24414 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24414 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _27727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27727] = 30
                            mem[_27727 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29020 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29020 + 68] = mem[idx + _27727 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29020 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29020 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21055 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21055] = 30
                            mem[_21055 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _21526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21526 + 68] = mem[idx + _21055 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21526 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21526 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23501 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23501] = 30
                            mem[_23501 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _24413 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24413 + 68] = mem[idx + _23501 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24413 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24413 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27725 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27725] = 30
                            mem[_27725 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _29019 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29019 + 68] = mem[idx + _27725 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29019 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29019 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22746 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22746] = 30
                        mem[_22746 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _23500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23500 + 68] = mem[idx + _22746 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23500 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23500 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26536] = 30
                        mem[_26536 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _27724 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27724 + 68] = mem[idx + _26536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27724 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27724 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31351 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31351] = 30
                        mem[_31351 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32547 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32547 + 68] = mem[idx + _31351 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32547 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32547 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20324] = 30
                                mem[_20324 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20589 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20589 + 68] = mem[idx + _20324 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20589 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20589 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21524 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21524] = 30
                                mem[_21524 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22051 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22051 + 68] = mem[idx + _21524 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22051 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22051 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24411] = 30
                                mem[_24411 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25526 + 68] = mem[idx + _24411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25526 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25526 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21054 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21054] = 30
                            mem[_21054 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21523 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21523 + 68] = mem[idx + _21054 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21523 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21523 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23498 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23498] = 30
                            mem[_23498 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _24410 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24410 + 68] = mem[idx + _23498 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24410 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24410 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _27722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27722] = 30
                            mem[_27722 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29017 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29017 + 68] = mem[idx + _27722 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29017 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29017 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21053 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21053] = 30
                            mem[_21053 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21522 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21522 + 68] = mem[idx + _21053 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21522 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21522 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23496 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23496] = 30
                            mem[_23496 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _24409 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24409 + 68] = mem[idx + _23496 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24409 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24409 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27720 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27720] = 30
                            mem[_27720 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _29016 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29016 + 68] = mem[idx + _27720 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29016 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29016 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22745 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22745] = 30
                        mem[_22745 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _23495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23495 + 68] = mem[idx + _22745 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23495 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23495 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _26534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26534] = 30
                        mem[_26534 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _27719 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27719 + 68] = mem[idx + _26534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27719 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27719 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31348 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31348] = 30
                        mem[_31348 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32544 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32544 + 68] = mem[idx + _31348 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32544 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32544 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21052 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21052] = 30
                            mem[_21052 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _21521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21521 + 68] = mem[idx + _21052 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21521 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21521 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23493 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23493] = 30
                            mem[_23493 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _24408 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24408 + 68] = mem[idx + _23493 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24408 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24408 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _27717 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27717] = 30
                            mem[_27717 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                            _29015 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29015 + 68] = mem[idx + _27717 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29015 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29015 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22744 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22744] = 30
                        mem[_22744 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _23492 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23492 + 68] = mem[idx + _22744 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23492 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23492 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26532 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26532] = 30
                        mem[_26532 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _27716 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27716 + 68] = mem[idx + _26532 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27716 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27716 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _31346 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31346] = 30
                        mem[_31346 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32542 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32542 + 68] = mem[idx + _31346 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32542 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32542 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _22743 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22743] = 30
                        mem[_22743 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _23491 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23491 + 68] = mem[idx + _22743 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23491 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23491 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26530 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26530] = 30
                        mem[_26530 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _27715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27715 + 68] = mem[idx + _26530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27715 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27715 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31344 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31344] = 30
                        mem[_31344 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _32541 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32541 + 68] = mem[idx + _31344 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32541 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32541 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25525 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25525] = 30
                    mem[_25525 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _26529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26529 + 68] = mem[idx + _25525 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26529 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26529 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _30185 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30185] = 30
                    mem[_30185 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _31343 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31343 + 68] = mem[idx + _30185 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31343 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31343 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _34401 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34401] = 30
                    mem[_34401 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _35273 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35273 + 68] = mem[idx + _34401 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35273 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35273 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] <= s:
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    _19245 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19245] = 30
                    mem[_19245 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor5[idx]] > t:
                        _19315 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19315 + 68] = mem[idx + _19245 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19315 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19315 + -mem[64] + 100
                    if t < stor1[stor5[idx]]:
                        revert with 0, 17
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    _19663 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19663] = 30
                    mem[_19663 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor5[idx]] <= s:
                        if s < stor2[stor5[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor5[idx]]
                        t = t - stor1[stor5[idx]]
                        continue 
                    _19725 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19725 + 68] = mem[idx + _19663 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19725 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19725 + -mem[64] + 100
                _19267 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19267] = 26
                mem[_19267 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19360 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19360 + 68] = mem[idx + _19267 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19360 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19360 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20597 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20597] = 30
                            mem[_20597 + 32] = 'SafeMath: subtraction overflow'
                            _22066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22066] = 30
                            mem[_22066 + 32] = 'SafeMath: subtraction overflow'
                            _25543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25543] = 30
                            mem[_25543 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26542 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26542 + 68] = mem[idx + _25543 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26542 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26542 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20596] = 30
                            mem[_20596 + 32] = 'SafeMath: subtraction overflow'
                            _22065 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22065] = 30
                            mem[_22065 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22752 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22752 + 68] = mem[idx + _22065 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22752 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22752 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _25541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25541] = 30
                            mem[_25541 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                            _26541 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26541 + 68] = mem[idx + _25541 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26541 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26541 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21538 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21538] = 30
                        mem[_21538 + 32] = 'SafeMath: subtraction overflow'
                        _24435 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24435] = 30
                        mem[_24435 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _25540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25540 + 68] = mem[idx + _24435 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25540 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _29039 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29039] = 30
                        mem[_29039 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30194 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30194 + 68] = mem[idx + _29039 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30194 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30194 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20595] = 30
                            mem[_20595 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _20785 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20785 + 68] = mem[idx + _20595 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20785 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20785 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _22063 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22063] = 30
                            mem[_22063 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _22751 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22751 + 68] = mem[idx + _22063 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22751 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22751 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25538] = 30
                            mem[_25538 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26540 + 68] = mem[idx + _25538 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26540 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21537 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21537] = 30
                        mem[_21537 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _22062 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22062 + 68] = mem[idx + _21537 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22062 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22062 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24433 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24433] = 30
                        mem[_24433 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _25537 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25537 + 68] = mem[idx + _24433 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25537 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25537 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _29037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29037] = 30
                        mem[_29037 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30192 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30192 + 68] = mem[idx + _29037 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30192 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30192 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21536] = 30
                        mem[_21536 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _22061 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22061 + 68] = mem[idx + _21536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22061 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22061 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24431 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24431] = 30
                        mem[_24431 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _25536 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25536 + 68] = mem[idx + _24431 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25536 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25536 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _29035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29035] = 30
                        mem[_29035 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _30191 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30191 + 68] = mem[idx + _29035 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30191 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30191 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23509 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23509] = 30
                    mem[_23509 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        _24430 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24430 + 68] = mem[idx + _23509 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24430 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24430 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27739 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27739] = 30
                    mem[_27739 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        _29034 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29034 + 68] = mem[idx + _27739 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29034 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29034 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32559 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32559] = 30
                    mem[_32559 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33537 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33537 + 68] = mem[idx + _32559 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33537 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33537 + -mem[64] + 100
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20593 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20593] = 30
                            mem[_20593 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20784 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20784 + 68] = mem[idx + _20593 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20784 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20784 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22059 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22059] = 30
                            mem[_22059 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22749 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22749 + 68] = mem[idx + _22059 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22749 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22749 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25534 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25534] = 30
                            mem[_25534 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26539 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26539 + 68] = mem[idx + _25534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26539 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26539 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21535 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21535] = 30
                        mem[_21535 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22058 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22058 + 68] = mem[idx + _21535 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22058 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22058 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24428 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24428] = 30
                        mem[_24428 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _25533 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25533 + 68] = mem[idx + _24428 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25533 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25533 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _29032 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29032] = 30
                        mem[_29032 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30189 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30189 + 68] = mem[idx + _29032 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30189 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30189 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21534] = 30
                        mem[_21534 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22057 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22057 + 68] = mem[idx + _21534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22057 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22057 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24426] = 30
                        mem[_24426 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _25532 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25532 + 68] = mem[idx + _24426 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25532 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25532 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _29030 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29030] = 30
                        mem[_29030 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _30188 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30188 + 68] = mem[idx + _29030 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30188 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30188 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23508 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23508] = 30
                    mem[_23508 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        _24425 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24425 + 68] = mem[idx + _23508 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24425 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24425 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _27737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27737] = 30
                    mem[_27737 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _29029 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29029 + 68] = mem[idx + _27737 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29029 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29029 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32556 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32556] = 30
                    mem[_32556 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33534 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33534 + 68] = mem[idx + _32556 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33534 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33534 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21533 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21533] = 30
                        mem[_21533 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _22056 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22056 + 68] = mem[idx + _21533 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22056 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22056 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24423 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24423] = 30
                        mem[_24423 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _25531 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25531 + 68] = mem[idx + _24423 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25531 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25531 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _29027 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29027] = 30
                        mem[_29027 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30187 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30187 + 68] = mem[idx + _29027 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30187 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30187 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23507 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23507] = 30
                    mem[_23507 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _24422 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24422 + 68] = mem[idx + _23507 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24422 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24422 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27735 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27735] = 30
                    mem[_27735 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _29026 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29026 + 68] = mem[idx + _27735 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29026 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29026 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    _32554 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32554] = 30
                    mem[_32554 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33532 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33532 + 68] = mem[idx + _32554 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33532 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33532 + -mem[64] + 100
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    _23506 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23506] = 30
                    mem[_23506 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _24421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24421 + 68] = mem[idx + _23506 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24421 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24421 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27733 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27733] = 30
                    mem[_27733 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _29025 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29025 + 68] = mem[idx + _27733 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29025 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29025 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32552 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32552] = 30
                    mem[_32552 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    _33531 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33531 + 68] = mem[idx + _32552 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33531 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33531 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26538 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26538] = 30
                mem[_26538 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    _27732 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27732 + 68] = mem[idx + _26538 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27732 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27732 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _31356 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31356] = 30
                mem[_31356 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    _32551 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32551 + 68] = mem[idx + _31356 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32551 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32551 + -mem[64] + 100
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _35278 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35278] = 30
                mem[_35278 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                _35869 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35869 + 68] = mem[idx + _35278 + 32]
                    idx = idx + 32
                    continue 
                mem[_35869 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35869 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor14 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 and stor14 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor12 / 100:
                if not 0 / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor12 / 100:
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                revert with 0, 17
            if not 0 / stor12 / 100:
                revert with 0, 18
            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
        if arg1 and _BURN_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        if not stor12:
            revert with 0, 'SafeMath: division by zero', 0
        mem[288] = 26
        mem[320] = 'SafeMath: division by zero'
        if not arg1:
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor12 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < 0 / stor12 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor14
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _19184 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19184] = 26
                    mem[_19184 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19263 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19263 + 68] = mem[idx + _19184 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19263 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19263 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20315] = 30
                                mem[_20315 + 32] = 'SafeMath: subtraction overflow'
                                _21507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21507] = 30
                                mem[_21507 + 32] = 'SafeMath: subtraction overflow'
                                _24377 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24377] = 30
                                mem[_24377 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                                _25502 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25502 + 68] = mem[idx + _24377 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25502 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25502 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20314 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20314] = 30
                                mem[_20314 + 32] = 'SafeMath: subtraction overflow'
                                _21506 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21506] = 30
                                mem[_21506 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22030 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22030 + 68] = mem[idx + _21506 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22030 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22030 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _24375 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24375] = 30
                                mem[_24375 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25501 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25501 + 68] = mem[idx + _24375 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25501 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25501 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21035 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21035] = 30
                            mem[_21035 + 32] = 'SafeMath: subtraction overflow'
                            _23464 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23464] = 30
                            mem[_23464 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _24374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24374 + 68] = mem[idx + _23464 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24374 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27675 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27675] = 30
                            mem[_27675 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _28985 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28985 + 68] = mem[idx + _27675 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28985 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28985 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20313 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20313] = 30
                                mem[_20313 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20581 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20581 + 68] = mem[idx + _20313 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20581 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20581 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _21504 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21504] = 30
                                mem[_21504 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _22029 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22029 + 68] = mem[idx + _21504 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22029 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22029 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24372 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24372] = 30
                                mem[_24372 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                                _25500 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25500 + 68] = mem[idx + _24372 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25500 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25500 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21034] = 30
                            mem[_21034 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _21503 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21503 + 68] = mem[idx + _21034 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21503 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21503 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23462 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23462] = 30
                            mem[_23462 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _24371 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24371 + 68] = mem[idx + _23462 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24371 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24371 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _27673 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27673] = 30
                            mem[_27673 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _28983 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28983 + 68] = mem[idx + _27673 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28983 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28983 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21033] = 30
                            mem[_21033 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _21502 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21502 + 68] = mem[idx + _21033 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21502 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21502 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23460 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23460] = 30
                            mem[_23460 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _24370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24370 + 68] = mem[idx + _23460 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24370 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27671] = 30
                            mem[_27671 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                            _28982 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28982 + 68] = mem[idx + _27671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28982 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28982 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22721] = 30
                        mem[_22721 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _23459 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23459 + 68] = mem[idx + _22721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23459 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23459 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26492 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26492] = 30
                        mem[_26492 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _27670 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27670 + 68] = mem[idx + _26492 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27670 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27670 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31302 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31302] = 30
                        mem[_31302 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _32504 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32504 + 68] = mem[idx + _31302 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32504 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32504 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20311] = 30
                                mem[_20311 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20580 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20580 + 68] = mem[idx + _20311 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20580 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20580 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21500 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21500] = 30
                                mem[_21500 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22027 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22027 + 68] = mem[idx + _21500 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22027 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22027 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24368 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24368] = 30
                                mem[_24368 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25499 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25499 + 68] = mem[idx + _24368 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25499 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25499 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21032] = 30
                            mem[_21032 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21499 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21499 + 68] = mem[idx + _21032 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21499 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21499 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23457 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23457] = 30
                            mem[_23457 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _24367 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24367 + 68] = mem[idx + _23457 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24367 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24367 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _27668 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27668] = 30
                            mem[_27668 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                            _28980 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28980 + 68] = mem[idx + _27668 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28980 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28980 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21031] = 30
                            mem[_21031 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21498 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21498 + 68] = mem[idx + _21031 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21498 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21498 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23455 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23455] = 30
                            mem[_23455 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _24366 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24366 + 68] = mem[idx + _23455 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24366 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24366 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27666 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27666] = 30
                            mem[_27666 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                            _28979 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28979 + 68] = mem[idx + _27666 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28979 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28979 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22720] = 30
                        mem[_22720 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _23454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23454 + 68] = mem[idx + _22720 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23454 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23454 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _26490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26490] = 30
                        mem[_26490 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _27665 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27665 + 68] = mem[idx + _26490 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27665 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27665 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31299] = 30
                        mem[_31299 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _32501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32501 + 68] = mem[idx + _31299 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32501 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32501 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _21030 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21030] = 30
                            mem[_21030 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _21497 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21497 + 68] = mem[idx + _21030 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21497 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21497 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23452 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23452] = 30
                            mem[_23452 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _24365 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24365 + 68] = mem[idx + _23452 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24365 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24365 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _27663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27663] = 30
                            mem[_27663 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                            _28978 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28978 + 68] = mem[idx + _27663 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28978 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28978 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22719 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22719] = 30
                        mem[_22719 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _23451 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23451 + 68] = mem[idx + _22719 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23451 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23451 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26488 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26488] = 30
                        mem[_26488 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _27662 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27662 + 68] = mem[idx + _26488 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27662 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27662 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _31297 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31297] = 30
                        mem[_31297 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _32499 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32499 + 68] = mem[idx + _31297 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32499 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32499 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _22718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22718] = 30
                        mem[_22718 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _23450 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23450 + 68] = mem[idx + _22718 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23450 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23450 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _26486 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26486] = 30
                        mem[_26486 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _27661 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27661 + 68] = mem[idx + _26486 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27661 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27661 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _31295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31295] = 30
                        mem[_31295 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _32498 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32498 + 68] = mem[idx + _31295 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32498 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32498 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25498 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25498] = 30
                    mem[_25498 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _26485 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26485 + 68] = mem[idx + _25498 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26485 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26485 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _30155 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30155] = 30
                    mem[_30155 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _31294 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _31294 + 68] = mem[idx + _30155 + 32]
                            idx = idx + 32
                            continue 
                        mem[_31294 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _31294 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _34367 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34367] = 30
                    mem[_34367 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    _35240 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35240 + 68] = mem[idx + _34367 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35240 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35240 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] <= s:
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    _19244 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19244] = 30
                    mem[_19244 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor5[idx]] > t:
                        _19312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19312 + 68] = mem[idx + _19244 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19312 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19312 + -mem[64] + 100
                    if t < stor1[stor5[idx]]:
                        revert with 0, 17
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    _19661 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19661] = 30
                    mem[_19661 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor5[idx]] <= s:
                        if s < stor2[stor5[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor5[idx]]
                        t = t - stor1[stor5[idx]]
                        continue 
                    _19724 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19724 + 68] = mem[idx + _19661 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19724 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19724 + -mem[64] + 100
                _19264 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19264] = 26
                mem[_19264 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19358 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19358 + 68] = mem[idx + _19264 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19358 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19358 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20588 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20588] = 30
                            mem[_20588 + 32] = 'SafeMath: subtraction overflow'
                            _22042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22042] = 30
                            mem[_22042 + 32] = 'SafeMath: subtraction overflow'
                            _25516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25516] = 30
                            mem[_25516 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                            _26498 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26498 + 68] = mem[idx + _25516 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26498 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26498 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _20587 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20587] = 30
                            mem[_20587 + 32] = 'SafeMath: subtraction overflow'
                            _22041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22041] = 30
                            mem[_22041 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22727 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22727 + 68] = mem[idx + _22041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22727 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22727 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _25514 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25514] = 30
                            mem[_25514 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26497 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26497 + 68] = mem[idx + _25514 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26497 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26497 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21514 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21514] = 30
                        mem[_21514 + 32] = 'SafeMath: subtraction overflow'
                        _24392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24392] = 30
                        mem[_24392 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _25513 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25513 + 68] = mem[idx + _24392 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25513 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25513 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _29002 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29002] = 30
                        mem[_29002 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _30164 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30164 + 68] = mem[idx + _29002 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30164 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30164 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _20586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20586] = 30
                            mem[_20586 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _20777 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20777 + 68] = mem[idx + _20586 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20777 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20777 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _22039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22039] = 30
                            mem[_22039 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _22726 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22726 + 68] = mem[idx + _22039 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22726 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22726 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25511] = 30
                            mem[_25511 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                            _26496 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26496 + 68] = mem[idx + _25511 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26496 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26496 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21513 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21513] = 30
                        mem[_21513 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _22038 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22038 + 68] = mem[idx + _21513 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22038 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22038 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24390 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24390] = 30
                        mem[_24390 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _25510 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25510 + 68] = mem[idx + _24390 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25510 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25510 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _29000 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29000] = 30
                        mem[_29000 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _30162 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30162 + 68] = mem[idx + _29000 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30162 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30162 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _21512 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21512] = 30
                        mem[_21512 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _22037 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22037 + 68] = mem[idx + _21512 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22037 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22037 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24388 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24388] = 30
                        mem[_24388 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _25509 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25509 + 68] = mem[idx + _24388 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25509 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25509 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28998 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28998] = 30
                        mem[_28998 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30161 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30161 + 68] = mem[idx + _28998 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30161 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30161 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23468 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23468] = 30
                    mem[_23468 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        _24387 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24387 + 68] = mem[idx + _23468 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24387 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24387 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27685 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27685] = 30
                    mem[_27685 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        _28997 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28997 + 68] = mem[idx + _27685 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28997 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28997 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32516 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32516] = 30
                    mem[_32516 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    _33523 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33523 + 68] = mem[idx + _32516 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33523 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33523 + -mem[64] + 100
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _20584 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20584] = 30
                            mem[_20584 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20776 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20776 + 68] = mem[idx + _20584 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20776 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20776 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22035 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22035] = 30
                            mem[_22035 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22724 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22724 + 68] = mem[idx + _22035 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22724 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22724 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25507 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25507] = 30
                            mem[_25507 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26495 + 68] = mem[idx + _25507 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26495 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26495 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21511 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21511] = 30
                        mem[_21511 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22034 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22034 + 68] = mem[idx + _21511 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22034 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22034 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24385 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24385] = 30
                        mem[_24385 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _25506 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25506 + 68] = mem[idx + _24385 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25506 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25506 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _28995 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28995] = 30
                        mem[_28995 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                        _30159 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30159 + 68] = mem[idx + _28995 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30159 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30159 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _21510 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21510] = 30
                        mem[_21510 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22033 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22033 + 68] = mem[idx + _21510 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22033 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22033 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24383] = 30
                        mem[_24383 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _25505 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25505 + 68] = mem[idx + _24383 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25505 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25505 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28993 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28993] = 30
                        mem[_28993 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30158 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30158 + 68] = mem[idx + _28993 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30158 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30158 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23467 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23467] = 30
                    mem[_23467 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        _24382 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24382 + 68] = mem[idx + _23467 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24382 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24382 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _27683 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27683] = 30
                    mem[_27683 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28992 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28992 + 68] = mem[idx + _27683 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28992 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28992 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32513 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32513] = 30
                    mem[_32513 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    _33520 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33520 + 68] = mem[idx + _32513 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33520 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33520 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        _21509 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21509] = 30
                        mem[_21509 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _22032 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22032 + 68] = mem[idx + _21509 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22032 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22032 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24380 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24380] = 30
                        mem[_24380 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _25504 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25504 + 68] = mem[idx + _24380 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25504 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25504 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _28990 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28990] = 30
                        mem[_28990 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                        _30157 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30157 + 68] = mem[idx + _28990 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30157 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30157 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23466 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23466] = 30
                    mem[_23466 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _24379 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24379 + 68] = mem[idx + _23466 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24379 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24379 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27681] = 30
                    mem[_27681 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _28989 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28989 + 68] = mem[idx + _27681 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28989 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28989 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    _32511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32511] = 30
                    mem[_32511 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                    _33518 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33518 + 68] = mem[idx + _32511 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33518 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33518 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    _23465 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23465] = 30
                    mem[_23465 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _24378 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24378 + 68] = mem[idx + _23465 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24378 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24378 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _27679 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27679] = 30
                    mem[_27679 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _28988 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28988 + 68] = mem[idx + _27679 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28988 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28988 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _32509 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32509] = 30
                    mem[_32509 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                    _33517 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33517 + 68] = mem[idx + _32509 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33517 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33517 + -mem[64] + 100
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26494 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26494] = 30
                mem[_26494 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    _27678 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27678 + 68] = mem[idx + _26494 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27678 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27678 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _31307 = mem[64]
                mem[64] = mem[64] + 64
                mem[_31307] = 30
                mem[_31307 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    _32508 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32508 + 68] = mem[idx + _31307 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32508 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32508 + -mem[64] + 100
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _35245 = mem[64]
                mem[64] = mem[64] + 64
                mem[_35245] = 30
                mem[_35245 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                _35864 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35864 + 68] = mem[idx + _35245 + 32]
                    idx = idx + 32
                    continue 
                mem[_35864 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35864 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor14 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * 0 / stor12 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor12 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor12 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s))
                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            return 0
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (-1 * 0 / stor12 / 100 * stor14 / totalSupply)
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
            if arg1 and stor14 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor12 / 100:
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor12 / 100:
                if not 0 / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                    revert with 0, 17
                if not 0 / stor12 / 100:
                    revert with 0, 18
                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor12 / 100:
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                revert with 0, 17
            if not 0 / stor12 / 100:
                revert with 0, 18
            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply))
        if arg1 and _CHARITY_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[352] = 26
        mem[384] = 'SafeMath: division by zero'
        if not stor12:
            revert with 0, 'SafeMath: division by zero', 0
        mem[416] = 26
        mem[448] = 'SafeMath: division by zero'
        mem[480] = 30
        mem[512] = 'SafeMath: subtraction overflow'
        if arg1 * _TAX_FEE / stor12 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * _TAX_FEE / stor12 / 100:
            revert with 0, 17
        mem[544] = 30
        mem[576] = 'SafeMath: subtraction overflow'
        if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
            revert with 0, 17
        mem[64] = 672
        mem[608] = 30
        mem[640] = 'SafeMath: subtraction overflow'
        if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
            revert with 0, 17
        idx = 0
        s = totalSupply
        t = stor14
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _19180 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19180] = 26
                mem[_19180 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19260 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19260 + 68] = mem[idx + _19180 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19260 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19260 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20302] = 30
                            mem[_20302 + 32] = 'SafeMath: subtraction overflow'
                            _21483 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21483] = 30
                            mem[_21483 + 32] = 'SafeMath: subtraction overflow'
                            _24334 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24334] = 30
                            mem[_24334 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                            _25475 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25475 + 68] = mem[idx + _24334 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25475 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25475 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20301] = 30
                            mem[_20301 + 32] = 'SafeMath: subtraction overflow'
                            _21482 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21482] = 30
                            mem[_21482 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22006 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22006 + 68] = mem[idx + _21482 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22006 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22006 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24332 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24332] = 30
                            mem[_24332 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                            _25474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25474 + 68] = mem[idx + _24332 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25474 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25474 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21013] = 30
                        mem[_21013 + 32] = 'SafeMath: subtraction overflow'
                        _23423 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23423] = 30
                        mem[_23423 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _24331 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24331 + 68] = mem[idx + _23423 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24331 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24331 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27621] = 30
                        mem[_27621 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _28948 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28948 + 68] = mem[idx + _27621 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28948 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28948 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20300] = 30
                            mem[_20300 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _20572 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20572 + 68] = mem[idx + _20300 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20572 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20572 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _21480 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21480] = 30
                            mem[_21480 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _22005 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22005 + 68] = mem[idx + _21480 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22005 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22005 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24329 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24329] = 30
                            mem[_24329 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                            _25473 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25473 + 68] = mem[idx + _24329 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25473 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25473 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21012 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21012] = 30
                        mem[_21012 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _21479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21479 + 68] = mem[idx + _21012 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21479 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _23421 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23421] = 30
                        mem[_23421 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _24328 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24328 + 68] = mem[idx + _23421 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24328 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24328 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _27619 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27619] = 30
                        mem[_27619 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _28946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28946 + 68] = mem[idx + _27619 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28946 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28946 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21011 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21011] = 30
                        mem[_21011 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _21478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21478 + 68] = mem[idx + _21011 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21478 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21478 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _23419 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23419] = 30
                        mem[_23419 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _24327 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24327 + 68] = mem[idx + _23419 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24327 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24327 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27617 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27617] = 30
                        mem[_27617 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _28945 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28945 + 68] = mem[idx + _27617 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28945 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28945 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22696 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22696] = 30
                    mem[_22696 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        _23418 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23418 + 68] = mem[idx + _22696 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23418 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23418 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _26448 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26448] = 30
                    mem[_26448 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        _27616 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27616 + 68] = mem[idx + _26448 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27616 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27616 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31253 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31253] = 30
                    mem[_31253 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _32461 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32461 + 68] = mem[idx + _31253 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32461 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32461 + -mem[64] + 100
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20298 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20298] = 30
                            mem[_20298 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20571 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20571 + 68] = mem[idx + _20298 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20571 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20571 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _21476 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21476] = 30
                            mem[_21476 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22003 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22003 + 68] = mem[idx + _21476 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22003 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22003 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24325 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24325] = 30
                            mem[_24325 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _25472 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25472 + 68] = mem[idx + _24325 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25472 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25472 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21010 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21010] = 30
                        mem[_21010 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _21475 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21475 + 68] = mem[idx + _21010 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21475 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21475 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _23416 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23416] = 30
                        mem[_23416 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24324 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24324 + 68] = mem[idx + _23416 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24324 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24324 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _27614 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27614] = 30
                        mem[_27614 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                        _28943 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28943 + 68] = mem[idx + _27614 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28943 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28943 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21009 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21009] = 30
                        mem[_21009 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _21474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21474 + 68] = mem[idx + _21009 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21474 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21474 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _23414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23414] = 30
                        mem[_23414 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24323 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24323 + 68] = mem[idx + _23414 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24323 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24323 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _27612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27612] = 30
                        mem[_27612 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                        _28942 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28942 + 68] = mem[idx + _27612 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28942 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28942 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22695 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22695] = 30
                    mem[_22695 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        _23413 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23413 + 68] = mem[idx + _22695 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23413 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23413 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _26446 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26446] = 30
                    mem[_26446 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _27611 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27611 + 68] = mem[idx + _26446 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27611 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27611 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31250 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31250] = 30
                    mem[_31250 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _32458 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32458 + 68] = mem[idx + _31250 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32458 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32458 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _21008 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21008] = 30
                        mem[_21008 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _21473 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21473 + 68] = mem[idx + _21008 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21473 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21473 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _23411 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23411] = 30
                        mem[_23411 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _24322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24322 + 68] = mem[idx + _23411 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24322 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24322 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _27609 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27609] = 30
                        mem[_27609 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                        _28941 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28941 + 68] = mem[idx + _27609 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28941 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28941 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22694 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22694] = 30
                    mem[_22694 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _23410 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23410 + 68] = mem[idx + _22694 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23410 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23410 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _26444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26444] = 30
                    mem[_26444 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _27608 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27608 + 68] = mem[idx + _26444 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27608 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27608 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    _31248 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31248] = 30
                    mem[_31248 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _32456 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32456 + 68] = mem[idx + _31248 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32456 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32456 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    _22693 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22693] = 30
                    mem[_22693 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _23409 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23409 + 68] = mem[idx + _22693 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23409 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23409 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _26442 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26442] = 30
                    mem[_26442 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _27607 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27607 + 68] = mem[idx + _26442 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27607 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27607 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31246 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31246] = 30
                    mem[_31246 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                    _32455 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32455 + 68] = mem[idx + _31246 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32455 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32455 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _25471 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25471] = 30
                mem[_25471 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    _26441 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _26441 + 68] = mem[idx + _25471 + 32]
                        idx = idx + 32
                        continue 
                    mem[_26441 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _26441 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _30125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_30125] = 30
                mem[_30125 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    _31245 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _31245 + 68] = mem[idx + _30125 + 32]
                        idx = idx + 32
                        continue 
                    mem[_31245 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _31245 + -mem[64] + 100
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _34333 = mem[64]
                mem[64] = mem[64] + 64
                mem[_34333] = 30
                mem[_34333 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                _35207 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35207 + 68] = mem[idx + _34333 + 32]
                    idx = idx + 32
                    continue 
                mem[_35207 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35207 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _19243 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19243] = 30
                mem[_19243 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _19309 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19309 + 68] = mem[idx + _19243 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19309 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19309 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _19659 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19659] = 30
                mem[_19659 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _19723 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _19723 + 68] = mem[idx + _19659 + 32]
                    idx = idx + 32
                    continue 
                mem[_19723 + 98] = 0
                revert with memory
                  from mem[64]
                   len _19723 + -mem[64] + 100
            _19261 = mem[64]
            mem[64] = mem[64] + 64
            mem[_19261] = 26
            mem[_19261 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _19356 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _19356 + 68] = mem[idx + _19261 + 32]
                    idx = idx + 32
                    continue 
                mem[_19356 + 94] = 0
                revert with memory
                  from mem[64]
                   len _19356 + -mem[64] + 100
            if not arg1:
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20579 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20579] = 30
                        mem[_20579 + 32] = 'SafeMath: subtraction overflow'
                        _22018 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22018] = 30
                        mem[_22018 + 32] = 'SafeMath: subtraction overflow'
                        _25489 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25489] = 30
                        mem[_25489 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                            if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                        _26454 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26454 + 68] = mem[idx + _25489 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26454 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26454 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _20578 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20578] = 30
                        mem[_20578 + 32] = 'SafeMath: subtraction overflow'
                        _22017 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22017] = 30
                        mem[_22017 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _22702 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22702 + 68] = mem[idx + _22017 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22702 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22702 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _25487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25487] = 30
                        mem[_25487 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                        _26453 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26453 + 68] = mem[idx + _25487 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26453 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26453 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21490 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21490] = 30
                    mem[_21490 + 32] = 'SafeMath: subtraction overflow'
                    _24349 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24349] = 30
                    mem[_24349 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        _25486 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25486 + 68] = mem[idx + _24349 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25486 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25486 + -mem[64] + 100
                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _28965 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28965] = 30
                    mem[_28965 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _30134 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30134 + 68] = mem[idx + _28965 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30134 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30134 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _20577 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20577] = 30
                        mem[_20577 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _20769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20769 + 68] = mem[idx + _20577 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20769 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20769 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _22015 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22015] = 30
                        mem[_22015 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _22701 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22701 + 68] = mem[idx + _22015 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22701 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22701 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _25484 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25484] = 30
                        mem[_25484 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                        _26452 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26452 + 68] = mem[idx + _25484 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26452 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26452 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21489 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21489] = 30
                    mem[_21489 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        _22014 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22014 + 68] = mem[idx + _21489 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22014 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22014 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _24347 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24347] = 30
                    mem[_24347 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        _25483 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25483 + 68] = mem[idx + _24347 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25483 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25483 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _28963 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28963] = 30
                    mem[_28963 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _30132 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30132 + 68] = mem[idx + _28963 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30132 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30132 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    _21488 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21488] = 30
                    mem[_21488 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        _22013 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22013 + 68] = mem[idx + _21488 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22013 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22013 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _24345 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24345] = 30
                    mem[_24345 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        _25482 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25482 + 68] = mem[idx + _24345 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25482 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25482 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _28961 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28961] = 30
                    mem[_28961 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                    _30131 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30131 + 68] = mem[idx + _28961 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30131 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30131 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23427 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23427] = 30
                mem[_23427 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                    _24344 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24344 + 68] = mem[idx + _23427 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24344 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24344 + -mem[64] + 100
                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _27631 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27631] = 30
                mem[_27631 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    _28960 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28960 + 68] = mem[idx + _27631 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28960 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28960 + -mem[64] + 100
                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _32473 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32473] = 30
                mem[_32473 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                _33509 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33509 + 68] = mem[idx + _32473 + 32]
                    idx = idx + 32
                    continue 
                mem[_33509 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33509 + -mem[64] + 100
            if arg1 and stor14 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor12 / 100:
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _20575 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20575] = 30
                        mem[_20575 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _20768 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20768 + 68] = mem[idx + _20575 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20768 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20768 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _22011 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22011] = 30
                        mem[_22011 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22699 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22699 + 68] = mem[idx + _22011 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22699 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22699 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _25480 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25480] = 30
                        mem[_25480 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _26451 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26451 + 68] = mem[idx + _25480 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26451 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26451 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21487 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21487] = 30
                    mem[_21487 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        _22010 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22010 + 68] = mem[idx + _21487 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22010 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22010 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _24342 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24342] = 30
                    mem[_24342 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        _25479 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25479 + 68] = mem[idx + _24342 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25479 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25479 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _28958 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28958] = 30
                    mem[_28958 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                        if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                    _30129 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30129 + 68] = mem[idx + _28958 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30129 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30129 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    _21486 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21486] = 30
                    mem[_21486 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor14 / totalSupply:
                        _22009 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22009 + 68] = mem[idx + _21486 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22009 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22009 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    _24340 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24340] = 30
                    mem[_24340 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _25478 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25478 + 68] = mem[idx + _24340 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25478 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25478 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _28956 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28956] = 30
                    mem[_28956 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                    _30128 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30128 + 68] = mem[idx + _28956 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30128 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30128 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23426 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23426] = 30
                mem[_23426 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor14 / totalSupply:
                    _24339 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24339 + 68] = mem[idx + _23426 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24339 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24339 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < 0:
                    revert with 0, 17
                _27629 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27629] = 30
                mem[_27629 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    _28955 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28955 + 68] = mem[idx + _27629 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28955 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28955 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _32470 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32470] = 30
                mem[_32470 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                _33506 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33506 + 68] = mem[idx + _32470 + 32]
                    idx = idx + 32
                    continue 
                mem[_33506 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33506 + -mem[64] + 100
            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor12 / 100:
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    _21485 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21485] = 30
                    mem[_21485 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _22008 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22008 + 68] = mem[idx + _21485 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22008 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22008 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _24337 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24337] = 30
                    mem[_24337 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _25477 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25477 + 68] = mem[idx + _24337 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25477 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25477 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    _28953 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28953] = 30
                    mem[_28953 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
                    _30127 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30127 + 68] = mem[idx + _28953 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30127 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30127 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23425 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23425] = 30
                mem[_23425 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    _24336 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24336 + 68] = mem[idx + _23425 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24336 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24336 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _27627 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27627] = 30
                mem[_27627 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    _28952 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28952 + 68] = mem[idx + _27627 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28952 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28952 + -mem[64] + 100
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                _32468 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32468] = 30
                mem[_32468 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
                _33504 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33504 + 68] = mem[idx + _32468 + 32]
                    idx = idx + 32
                    continue 
                mem[_33504 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33504 + -mem[64] + 100
            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                _23424 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23424] = 30
                mem[_23424 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    _24335 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24335 + 68] = mem[idx + _23424 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24335 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24335 + -mem[64] + 100
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _27625 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27625] = 30
                mem[_27625 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    _28951 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28951 + 68] = mem[idx + _27625 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28951 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28951 + -mem[64] + 100
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                _32466 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32466] = 30
                mem[_32466 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
                _33503 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33503 + 68] = mem[idx + _32466 + 32]
                    idx = idx + 32
                    continue 
                mem[_33503 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33503 + -mem[64] + 100
            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _26450 = mem[64]
            mem[64] = mem[64] + 64
            mem[_26450] = 30
            mem[_26450 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                _27624 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _27624 + 68] = mem[idx + _26450 + 32]
                    idx = idx + 32
                    continue 
                mem[_27624 + 98] = 0
                revert with memory
                  from mem[64]
                   len _27624 + -mem[64] + 100
            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            _31258 = mem[64]
            mem[64] = mem[64] + 64
            mem[_31258] = 30
            mem[_31258 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                _32465 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _32465 + 68] = mem[idx + _31258 + 32]
                    idx = idx + 32
                    continue 
                mem[_32465 + 98] = 0
                revert with memory
                  from mem[64]
                   len _32465 + -mem[64] + 100
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            _35212 = mem[64]
            mem[64] = mem[64] + 64
            mem[_35212] = 30
            mem[_35212 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            _35859 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _35859 + 68] = mem[idx + _35212 + 32]
                idx = idx + 32
                continue 
            mem[_35859 + 98] = 0
            revert with memory
              from mem[64]
               len _35859 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor14 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * t / s)
                    if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor12 / 100:
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
            if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor12 / 100:
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s))
            if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor12 / 100 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * _TAX_FEE / stor12 / 100:
                if not arg1 * _BURN_FEE / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        return 0
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply)
                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply)
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor12 / 100:
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply)
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            return ((-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
        if arg1 and stor14 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _TAX_FEE / stor12 / 100:
            if not arg1 * _BURN_FEE / stor12 / 100:
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor14 / totalSupply)
                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                if 0 > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor14 / totalSupply < 0:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
            revert with 0, 17
        if not arg1 * _TAX_FEE / stor12 / 100:
            revert with 0, 18
        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _BURN_FEE / stor12 / 100:
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply))
            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor12 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
            revert with 0, 17
        if not arg1 * _BURN_FEE / stor12 / 100:
            revert with 0, 18
        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _CHARITY_FEE / stor12 / 100:
            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply))
        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
            revert with 0, 17
        if not arg1 * _CHARITY_FEE / stor12 / 100:
            revert with 0, 18
        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
            revert with 0, 17
        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
            revert with 0, 17
        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
            revert with 0, 17
        return ((arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor12:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (2 * 0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19240 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19240] = 26
                        mem[_19240 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19305 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19305 + 68] = mem[idx + _19240 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19305 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19305 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20474] = 30
                                mem[_20474 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20698 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20698 + 68] = mem[idx + _20474 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20698 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20698 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _21810 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21810] = 30
                                mem[_21810 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _22315 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22315 + 68] = mem[idx + _21810 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22315 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22315 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24899] = 30
                                mem[_24899 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25835 + 68] = mem[idx + _24899 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25835 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25835 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21294] = 30
                                mem[_21294 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21809 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21809 + 68] = mem[idx + _21294 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21809 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21809 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23955 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23955] = 30
                                mem[_23955 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24898 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24898 + 68] = mem[idx + _23955 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24898 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24898 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28323 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28323] = 30
                                mem[_28323 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29434 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29434 + 68] = mem[idx + _28323 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29434 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29434 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23022 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23022] = 30
                            mem[_23022 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _23954 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23954 + 68] = mem[idx + _23022 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23954 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23954 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27014 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27014] = 30
                            mem[_27014 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _28322 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28322 + 68] = mem[idx + _27014 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28322 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28322 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31886 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31886] = 30
                            mem[_31886 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _33018 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33018 + 68] = mem[idx + _31886 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33018 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33018 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _20472 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20472] = 30
                            mem[_20472 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20697 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20697 + 68] = mem[idx + _20472 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20697 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20697 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _21807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21807] = 30
                            mem[_21807 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22313 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22313 + 68] = mem[idx + _21807 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22313 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22313 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24896 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24896] = 30
                            mem[_24896 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _25834 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25834 + 68] = mem[idx + _24896 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25834 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25834 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21293 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21293] = 30
                            mem[_21293 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _21806 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21806 + 68] = mem[idx + _21293 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21806 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21806 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23952 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23952] = 30
                            mem[_23952 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _24895 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24895 + 68] = mem[idx + _23952 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24895 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24895 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _28320 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28320] = 30
                            mem[_28320 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _29432 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29432 + 68] = mem[idx + _28320 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29432 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29432 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _23021 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23021] = 30
                            mem[_23021 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23951 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23951 + 68] = mem[idx + _23021 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23951 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23951 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _27012 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27012] = 30
                            mem[_27012 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _28319 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28319 + 68] = mem[idx + _27012 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28319 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28319 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31883 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31883] = 30
                            mem[_31883 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _33016 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33016 + 68] = mem[idx + _31883 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33016 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33016 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25833 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25833] = 30
                        mem[_25833 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _27011 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27011 + 68] = mem[idx + _25833 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27011 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27011 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30525 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30525] = 30
                        mem[_30525 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _31882 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31882 + 68] = mem[idx + _30525 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31882 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31882 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34783 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34783] = 30
                        mem[_34783 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35636 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35636 + 68] = mem[idx + _34783 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35636 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35636 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19258] = 30
                        mem[_19258 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19354 + 68] = mem[idx + _19258 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19354 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19354 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19689 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19689] = 30
                        mem[_19689 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19738 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19738 + 68] = mem[idx + _19689 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19738 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19738 + -mem[64] + 100
                    _19306 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19306] = 26
                    mem[_19306 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19386 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19386 + 68] = mem[idx + _19306 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19386 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19386 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor12 / 100:
                            return 0
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _20702 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20702] = 30
                            mem[_20702 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _20869 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20869 + 68] = mem[idx + _20702 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20869 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20869 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _22321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22321] = 30
                            mem[_22321 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _23025 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23025 + 68] = mem[idx + _22321 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23025 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23025 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25841 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25841] = 30
                            mem[_25841 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _27018 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27018 + 68] = mem[idx + _25841 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27018 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27018 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21814 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21814] = 30
                            mem[_21814 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22320 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22320 + 68] = mem[idx + _21814 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22320 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22320 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24905 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24905] = 30
                            mem[_24905 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25840 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25840 + 68] = mem[idx + _24905 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25840 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25840 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29440] = 30
                            mem[_29440 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30529 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30529 + 68] = mem[idx + _29440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30529 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30529 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23958 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23958] = 30
                        mem[_23958 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _24904 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24904 + 68] = mem[idx + _23958 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24904 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24904 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28329] = 30
                        mem[_28329 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _29439 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29439 + 68] = mem[idx + _28329 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29439 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29439 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _33024 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33024] = 30
                        mem[_33024 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33697 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33697 + 68] = mem[idx + _33024 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33697 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33697 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _20700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20700] = 30
                        mem[_20700 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _20868 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20868 + 68] = mem[idx + _20700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20868 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20868 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _22318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22318] = 30
                        mem[_22318 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _23023 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23023 + 68] = mem[idx + _22318 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23023 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23023 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _25838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25838] = 30
                        mem[_25838 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _27017 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27017 + 68] = mem[idx + _25838 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27017 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27017 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _21813 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21813] = 30
                        mem[_21813 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _22317 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22317 + 68] = mem[idx + _21813 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22317 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22317 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24902 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24902] = 30
                        mem[_24902 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _25837 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25837 + 68] = mem[idx + _24902 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25837 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25837 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _29437 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29437] = 30
                        mem[_29437 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _30527 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30527 + 68] = mem[idx + _29437 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30527 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30527 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _23957 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23957] = 30
                        mem[_23957 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24901 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24901 + 68] = mem[idx + _23957 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24901 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24901 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28327] = 30
                        mem[_28327 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29436 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29436 + 68] = mem[idx + _28327 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29436 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29436 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _33021 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33021] = 30
                        mem[_33021 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33695 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33695 + 68] = mem[idx + _33021 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33695 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33695 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _27016 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27016] = 30
                    mem[_27016 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28326 + 68] = mem[idx + _27016 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28326 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31889 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31889] = 30
                    mem[_31889 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _33020 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33020 + 68] = mem[idx + _31889 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33020 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33020 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35639 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35639] = 30
                    mem[_35639 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35928 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35928 + 68] = mem[idx + _35639 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35928 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35928 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if 0 / stor12 / 100:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                            return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if 0 / stor12 / 100:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        return 0
                    else:
                        return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor14 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor14 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (2 * 0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19236 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19236] = 26
                        mem[_19236 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19302 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19302 + 68] = mem[idx + _19236 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19302 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19302 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20466 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20466] = 30
                                mem[_20466 + 32] = 'SafeMath: subtraction overflow'
                                _21794 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21794] = 30
                                mem[_21794 + 32] = 'SafeMath: subtraction overflow'
                                _24874 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24874] = 30
                                mem[_24874 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25818 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25818 + 68] = mem[idx + _24874 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25818 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25818 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20465 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20465] = 30
                                    mem[_20465 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20691 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20691 + 68] = mem[idx + _20465 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20691 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20691 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21792 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21792] = 30
                                    mem[_21792 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        _22302 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22302 + 68] = mem[idx + _21792 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22302 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22302 + -mem[64] + 100
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24872 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24872] = 30
                                    mem[_24872 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25817 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25817 + 68] = mem[idx + _24872 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25817 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25817 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21283] = 30
                                mem[_21283 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21791 + 68] = mem[idx + _21283 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21791 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21791 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23934] = 30
                                mem[_23934 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24871 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24871 + 68] = mem[idx + _23934 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24871 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24871 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28295] = 30
                                mem[_28295 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29411 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29411 + 68] = mem[idx + _28295 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29411 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29411 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21282] = 30
                                mem[_21282 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21790 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21790 + 68] = mem[idx + _21282 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21790 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21790 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23932] = 30
                                mem[_23932 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24870 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24870 + 68] = mem[idx + _23932 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24870 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24870 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28293] = 30
                                mem[_28293 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29410 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29410 + 68] = mem[idx + _28293 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29410 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29410 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23009] = 30
                            mem[_23009 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _23931 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23931 + 68] = mem[idx + _23009 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23931 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23931 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26993 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26993] = 30
                            mem[_26993 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _28292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28292 + 68] = mem[idx + _26993 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28292 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28292 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31862] = 30
                            mem[_31862 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32995 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32995 + 68] = mem[idx + _31862 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32995 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32995 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20463 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20463] = 30
                                mem[_20463 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20690 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20690 + 68] = mem[idx + _20463 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20690 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20690 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21788 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21788] = 30
                                mem[_21788 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22300 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22300 + 68] = mem[idx + _21788 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22300 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22300 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24868 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24868] = 30
                                mem[_24868 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25816 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25816 + 68] = mem[idx + _24868 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25816 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25816 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21281 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21281] = 30
                            mem[_21281 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _21787 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21787 + 68] = mem[idx + _21281 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21787 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21787 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _23929 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23929] = 30
                            mem[_23929 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _24867 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24867 + 68] = mem[idx + _23929 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24867 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24867 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _28290 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28290] = 30
                            mem[_28290 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _29408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29408 + 68] = mem[idx + _28290 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29408 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29408 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21280 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21280] = 30
                                mem[_21280 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21786 + 68] = mem[idx + _21280 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21786 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21786 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23927 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23927] = 30
                                mem[_23927 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    _24866 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24866 + 68] = mem[idx + _23927 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24866 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24866 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _28288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28288] = 30
                                mem[_28288 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29407 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29407 + 68] = mem[idx + _28288 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29407 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29407 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23008 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23008] = 30
                            mem[_23008 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23926 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23926 + 68] = mem[idx + _23008 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23926 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23926 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26991] = 30
                            mem[_26991 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _28287 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28287 + 68] = mem[idx + _26991 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28287 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28287 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31859 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31859] = 30
                            mem[_31859 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32992 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32992 + 68] = mem[idx + _31859 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32992 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32992 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _23007 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23007] = 30
                            mem[_23007 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23925 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23925 + 68] = mem[idx + _23007 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23925 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23925 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26989] = 30
                            mem[_26989 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _28286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28286 + 68] = mem[idx + _26989 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28286 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28286 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31857] = 30
                            mem[_31857 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32991 + 68] = mem[idx + _31857 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32991 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32991 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25815 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25815] = 30
                        mem[_25815 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26988 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26988 + 68] = mem[idx + _25815 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26988 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26988 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30506 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30506] = 30
                        mem[_30506 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _31856 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31856 + 68] = mem[idx + _30506 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31856 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31856 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34763] = 30
                        mem[_34763 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35618 + 68] = mem[idx + _34763 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35618 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35618 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19257] = 30
                        mem[_19257 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19351 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19351 + 68] = mem[idx + _19257 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19351 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19351 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19687 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19687] = 30
                        mem[_19687 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19737 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19737 + 68] = mem[idx + _19687 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19737 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19737 + -mem[64] + 100
                    _19303 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19303] = 26
                    mem[_19303 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19384 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19384 + 68] = mem[idx + _19303 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19384 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19384 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20696] = 30
                            mem[_20696 + 32] = 'SafeMath: subtraction overflow'
                            _22312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22312] = 30
                            mem[_22312 + 32] = 'SafeMath: subtraction overflow'
                            _25828 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25828] = 30
                            mem[_25828 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26998 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26998 + 68] = mem[idx + _25828 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26998 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26998 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20695 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20695] = 30
                                mem[_20695 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20866 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20866 + 68] = mem[idx + _20695 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20866 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20866 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22310 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22310] = 30
                                mem[_22310 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _23013 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23013 + 68] = mem[idx + _22310 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23013 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23013 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25826 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25826] = 30
                                mem[_25826 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26997 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26997 + 68] = mem[idx + _25826 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26997 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26997 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21799] = 30
                            mem[_21799 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22309 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22309 + 68] = mem[idx + _21799 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22309 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22309 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24884 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24884] = 30
                            mem[_24884 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25825 + 68] = mem[idx + _24884 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25825 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25825 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29423 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29423] = 30
                            mem[_29423 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30512 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30512 + 68] = mem[idx + _29423 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30512 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30512 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21798] = 30
                            mem[_21798 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22308 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22308 + 68] = mem[idx + _21798 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22308 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22308 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24882] = 30
                            mem[_24882 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25824 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25824 + 68] = mem[idx + _24882 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25824 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25824 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29421] = 30
                            mem[_29421 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30511 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30511 + 68] = mem[idx + _29421 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30511 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30511 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23938 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23938] = 30
                        mem[_23938 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _24881 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24881 + 68] = mem[idx + _23938 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24881 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24881 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28303] = 30
                        mem[_28303 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _29420 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29420 + 68] = mem[idx + _28303 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29420 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29420 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _33004 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33004] = 30
                        mem[_33004 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33688 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33688 + 68] = mem[idx + _33004 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33688 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33688 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _20693 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20693] = 30
                            mem[_20693 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20865 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20865 + 68] = mem[idx + _20693 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20865 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20865 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22306] = 30
                            mem[_22306 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23011 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23011 + 68] = mem[idx + _22306 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23011 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23011 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25822] = 30
                            mem[_25822 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26996 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26996 + 68] = mem[idx + _25822 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26996 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26996 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21797 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21797] = 30
                        mem[_21797 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _22305 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22305 + 68] = mem[idx + _21797 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22305 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22305 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _24879 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24879] = 30
                        mem[_24879 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _25821 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25821 + 68] = mem[idx + _24879 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25821 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25821 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _29418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29418] = 30
                        mem[_29418 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _30509 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30509 + 68] = mem[idx + _29418 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30509 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30509 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21796] = 30
                            mem[_21796 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22304 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22304 + 68] = mem[idx + _21796 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22304 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22304 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24877 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24877] = 30
                            mem[_24877 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _25820 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25820 + 68] = mem[idx + _24877 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25820 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25820 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29416] = 30
                            mem[_29416 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30508 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30508 + 68] = mem[idx + _29416 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30508 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30508 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23937 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23937] = 30
                        mem[_23937 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24876 + 68] = mem[idx + _23937 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24876 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24876 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28301 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28301] = 30
                        mem[_28301 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29415 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29415 + 68] = mem[idx + _28301 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29415 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29415 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _33001 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33001] = 30
                        mem[_33001 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33685 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33685 + 68] = mem[idx + _33001 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33685 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33685 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _23936 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23936] = 30
                        mem[_23936 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24875 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24875 + 68] = mem[idx + _23936 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24875 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24875 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28299] = 30
                        mem[_28299 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29414 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29414 + 68] = mem[idx + _28299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29414 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29414 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32999 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32999] = 30
                        mem[_32999 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33684 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33684 + 68] = mem[idx + _32999 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33684 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33684 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26995 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26995] = 30
                    mem[_26995 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28298 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28298 + 68] = mem[idx + _26995 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28298 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28298 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31866 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31866] = 30
                    mem[_31866 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _32998 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32998 + 68] = mem[idx + _31866 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32998 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32998 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35622 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35622] = 30
                    mem[_35622 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35924 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35924 + 68] = mem[idx + _35622 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35924 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35924 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor12 / 100:
                        if arg1 * _CHARITY_FEE / stor12 / 100:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                else:
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19232 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19232] = 26
                        mem[_19232 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19299 + 68] = mem[idx + _19232 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19299 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19299 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor12 / 100:
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    if not 0 / stor12 / 100:
                                        return 0
                                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20457 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20457] = 30
                                    mem[_20457 + 32] = 'SafeMath: subtraction overflow'
                                    _21772 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21772] = 30
                                    mem[_21772 + 32] = 'SafeMath: subtraction overflow'
                                    _24839 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24839] = 30
                                    mem[_24839 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25794 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25794 + 68] = mem[idx + _24839 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25794 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25794 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    _20456 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20456] = 30
                                    mem[_20456 + 32] = 'SafeMath: subtraction overflow'
                                    _21771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21771] = 30
                                    mem[_21771 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22282 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22282 + 68] = mem[idx + _21771 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22282 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22282 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24837 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24837] = 30
                                    mem[_24837 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25793 + 68] = mem[idx + _24837 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25793 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25793 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21267 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21267] = 30
                                mem[_21267 + 32] = 'SafeMath: subtraction overflow'
                                _23902 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23902] = 30
                                mem[_23902 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24836 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24836 + 68] = mem[idx + _23902 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24836 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24836 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28254 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28254] = 30
                                mem[_28254 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29379 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29379 + 68] = mem[idx + _28254 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29379 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29379 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    _20455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20455] = 30
                                    mem[_20455 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20682 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20682 + 68] = mem[idx + _20455 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20682 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20682 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21769] = 30
                                    mem[_21769 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        _22281 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22281 + 68] = mem[idx + _21769 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22281 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22281 + -mem[64] + 100
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24834] = 30
                                    mem[_24834 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25792 + 68] = mem[idx + _24834 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25792 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25792 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21266 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21266] = 30
                                mem[_21266 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21768 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21768 + 68] = mem[idx + _21266 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21768 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21768 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23900 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23900] = 30
                                mem[_23900 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24833 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24833 + 68] = mem[idx + _23900 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24833 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24833 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28252 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28252] = 30
                                mem[_28252 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29377 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29377 + 68] = mem[idx + _28252 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29377 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29377 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21265] = 30
                                mem[_21265 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21767 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21767 + 68] = mem[idx + _21265 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21767 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21767 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23898 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23898] = 30
                                mem[_23898 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24832 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24832 + 68] = mem[idx + _23898 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24832 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24832 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28250] = 30
                                mem[_28250 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29376 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29376 + 68] = mem[idx + _28250 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29376 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29376 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22989] = 30
                            mem[_22989 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _23897 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23897 + 68] = mem[idx + _22989 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23897 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23897 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26959] = 30
                            mem[_26959 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _28249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28249 + 68] = mem[idx + _26959 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28249 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28249 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31825 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31825] = 30
                            mem[_31825 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32960 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32960 + 68] = mem[idx + _31825 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32960 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32960 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    _20453 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20453] = 30
                                    mem[_20453 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _20681 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20681 + 68] = mem[idx + _20453 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20681 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20681 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _21765 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21765] = 30
                                    mem[_21765 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _22279 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22279 + 68] = mem[idx + _21765 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22279 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22279 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24830 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24830] = 30
                                    mem[_24830 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor14 / totalSupply:
                                        if arg1 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor14 / totalSupply)
                                    _25791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25791 + 68] = mem[idx + _24830 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25791 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25791 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21264 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21264] = 30
                                mem[_21264 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21764 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21764 + 68] = mem[idx + _21264 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21764 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21764 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23895] = 30
                                mem[_23895 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _24829 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24829 + 68] = mem[idx + _23895 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24829 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24829 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28247 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28247] = 30
                                mem[_28247 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29374 + 68] = mem[idx + _28247 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29374 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21263] = 30
                                mem[_21263 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21763 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21763 + 68] = mem[idx + _21263 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21763 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21763 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23893 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23893] = 30
                                mem[_23893 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24828 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24828 + 68] = mem[idx + _23893 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24828 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24828 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28245 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28245] = 30
                                mem[_28245 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29373 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29373 + 68] = mem[idx + _28245 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29373 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29373 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22988 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22988] = 30
                            mem[_22988 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23892 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23892 + 68] = mem[idx + _22988 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23892 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23892 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26957 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26957] = 30
                            mem[_26957 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _28244 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28244 + 68] = mem[idx + _26957 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28244 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28244 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31822] = 30
                            mem[_31822 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32957 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32957 + 68] = mem[idx + _31822 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32957 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32957 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _21262 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21262] = 30
                                mem[_21262 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21762 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21762 + 68] = mem[idx + _21262 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21762 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21762 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23890 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23890] = 30
                                mem[_23890 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    _24827 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24827 + 68] = mem[idx + _23890 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24827 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24827 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _28242 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28242] = 30
                                mem[_28242 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29372 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29372 + 68] = mem[idx + _28242 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29372 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29372 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22987] = 30
                            mem[_22987 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23889 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23889 + 68] = mem[idx + _22987 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23889 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23889 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26955 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26955] = 30
                            mem[_26955 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _28241 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28241 + 68] = mem[idx + _26955 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28241 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28241 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31820 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31820] = 30
                            mem[_31820 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32955 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32955 + 68] = mem[idx + _31820 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32955 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32955 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _22986 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22986] = 30
                            mem[_22986 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23888 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23888 + 68] = mem[idx + _22986 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23888 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23888 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26953] = 30
                            mem[_26953 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _28240 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28240 + 68] = mem[idx + _26953 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28240 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28240 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31818 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31818] = 30
                            mem[_31818 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32954 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32954 + 68] = mem[idx + _31818 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32954 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32954 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25790] = 30
                        mem[_25790 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26952 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26952 + 68] = mem[idx + _25790 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26952 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26952 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30480 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30480] = 30
                        mem[_30480 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _31817 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31817 + 68] = mem[idx + _30480 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31817 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31817 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34735 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34735] = 30
                        mem[_34735 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35591 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35591 + 68] = mem[idx + _34735 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35591 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35591 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19256 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19256] = 30
                        mem[_19256 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19348 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19348 + 68] = mem[idx + _19256 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19348 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19348 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19685 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19685] = 30
                        mem[_19685 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19736 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19736 + 68] = mem[idx + _19685 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19736 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19736 + -mem[64] + 100
                    _19300 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19300] = 26
                    mem[_19300 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19382 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19382 + 68] = mem[idx + _19300 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19382 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19382 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20689] = 30
                                mem[_20689 + 32] = 'SafeMath: subtraction overflow'
                                _22294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22294] = 30
                                mem[_22294 + 32] = 'SafeMath: subtraction overflow'
                                _25808 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25808] = 30
                                mem[_25808 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26965 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26965 + 68] = mem[idx + _25808 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26965 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26965 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20688 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20688] = 30
                                mem[_20688 + 32] = 'SafeMath: subtraction overflow'
                                _22293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22293] = 30
                                mem[_22293 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22995 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22995 + 68] = mem[idx + _22293 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22995 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22995 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25806 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25806] = 30
                                mem[_25806 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26964 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26964 + 68] = mem[idx + _25806 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26964 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26964 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21779] = 30
                            mem[_21779 + 32] = 'SafeMath: subtraction overflow'
                            _24854 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24854] = 30
                            mem[_24854 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _25805 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25805 + 68] = mem[idx + _24854 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25805 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25805 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29396 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29396] = 30
                            mem[_29396 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30489 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30489 + 68] = mem[idx + _29396 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30489 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30489 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20687 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20687] = 30
                                mem[_20687 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20859 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20859 + 68] = mem[idx + _20687 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20859 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20859 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22291] = 30
                                mem[_22291 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _22994 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22994 + 68] = mem[idx + _22291 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22994 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22994 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25803 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25803] = 30
                                mem[_25803 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26963 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26963 + 68] = mem[idx + _25803 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26963 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26963 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21778 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21778] = 30
                            mem[_21778 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22290 + 68] = mem[idx + _21778 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22290 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22290 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24852 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24852] = 30
                            mem[_24852 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25802 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25802 + 68] = mem[idx + _24852 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25802 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25802 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29394 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29394] = 30
                            mem[_29394 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30487 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30487 + 68] = mem[idx + _29394 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30487 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30487 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21777 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21777] = 30
                            mem[_21777 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22289 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22289 + 68] = mem[idx + _21777 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22289 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22289 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24850 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24850] = 30
                            mem[_24850 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25801 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25801 + 68] = mem[idx + _24850 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25801 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25801 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29392] = 30
                            mem[_29392 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30486 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30486 + 68] = mem[idx + _29392 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30486 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30486 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23906 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23906] = 30
                        mem[_23906 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _24849 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24849 + 68] = mem[idx + _23906 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24849 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24849 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28264] = 30
                        mem[_28264 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _29391 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29391 + 68] = mem[idx + _28264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29391 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29391 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32972 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32972] = 30
                        mem[_32972 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33676 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33676 + 68] = mem[idx + _32972 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33676 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33676 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20685 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20685] = 30
                                mem[_20685 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20858 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20858 + 68] = mem[idx + _20685 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20858 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20858 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _22287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22287] = 30
                                mem[_22287 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22992 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22992 + 68] = mem[idx + _22287 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22992 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22992 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25799 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25799] = 30
                                mem[_25799 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _26962 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26962 + 68] = mem[idx + _25799 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26962 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26962 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21776] = 30
                            mem[_21776 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22286 + 68] = mem[idx + _21776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22286 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22286 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24847] = 30
                            mem[_24847 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _25798 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25798 + 68] = mem[idx + _24847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25798 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25798 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29389 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29389] = 30
                            mem[_29389 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30484 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30484 + 68] = mem[idx + _29389 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30484 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30484 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21775 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21775] = 30
                            mem[_21775 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22285 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22285 + 68] = mem[idx + _21775 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22285 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22285 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24845 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24845] = 30
                            mem[_24845 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25797 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25797 + 68] = mem[idx + _24845 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25797 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25797 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29387 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29387] = 30
                            mem[_29387 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30483 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30483 + 68] = mem[idx + _29387 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30483 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30483 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23905 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23905] = 30
                        mem[_23905 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24844 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24844 + 68] = mem[idx + _23905 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24844 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24844 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _28262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28262] = 30
                        mem[_28262 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29386 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29386 + 68] = mem[idx + _28262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29386 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29386 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32969 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32969] = 30
                        mem[_32969 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33673 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33673 + 68] = mem[idx + _32969 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33673 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33673 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _21774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21774] = 30
                            mem[_21774 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22284 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22284 + 68] = mem[idx + _21774 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22284 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22284 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24842 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24842] = 30
                            mem[_24842 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _25796 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25796 + 68] = mem[idx + _24842 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25796 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25796 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29384 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29384] = 30
                            mem[_29384 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30482 + 68] = mem[idx + _29384 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30482 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30482 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23904 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23904] = 30
                        mem[_23904 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24841 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24841 + 68] = mem[idx + _23904 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24841 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24841 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28260 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28260] = 30
                        mem[_28260 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29383 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29383 + 68] = mem[idx + _28260 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29383 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29383 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _32967 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32967] = 30
                        mem[_32967 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33671 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33671 + 68] = mem[idx + _32967 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33671 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33671 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _23903 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23903] = 30
                        mem[_23903 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24840 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24840 + 68] = mem[idx + _23903 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24840 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24840 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28258] = 30
                        mem[_28258 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29382 + 68] = mem[idx + _28258 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29382 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32965 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32965] = 30
                        mem[_32965 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33670 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33670 + 68] = mem[idx + _32965 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33670 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33670 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26961 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26961] = 30
                    mem[_26961 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28257 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28257 + 68] = mem[idx + _26961 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28257 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28257 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31830 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31830] = 30
                    mem[_31830 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _32964 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32964 + 68] = mem[idx + _31830 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32964 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32964 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35596 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35596] = 30
                    mem[_35596 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35919 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35919 + 68] = mem[idx + _35596 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35919 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35919 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if 0 / stor12 / 100:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if 0 / stor12 / 100:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19228] = 26
                        mem[_19228 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19296 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19296 + 68] = mem[idx + _19228 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19296 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19296 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor12 / 100:
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20444] = 30
                                    mem[_20444 + 32] = 'SafeMath: subtraction overflow'
                                    _21748 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21748] = 30
                                    mem[_21748 + 32] = 'SafeMath: subtraction overflow'
                                    _24796 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24796] = 30
                                    mem[_24796 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25767 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25767 + 68] = mem[idx + _24796 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25767 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25767 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20443] = 30
                                    mem[_20443 + 32] = 'SafeMath: subtraction overflow'
                                    _21747 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21747] = 30
                                    mem[_21747 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22258 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22258 + 68] = mem[idx + _21747 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22258 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22258 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24794 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24794] = 30
                                    mem[_24794 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25766 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25766 + 68] = mem[idx + _24794 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25766 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25766 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21245 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21245] = 30
                                mem[_21245 + 32] = 'SafeMath: subtraction overflow'
                                _23861 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23861] = 30
                                mem[_23861 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24793 + 68] = mem[idx + _23861 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24793 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24793 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28200 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28200] = 30
                                mem[_28200 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29342 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29342 + 68] = mem[idx + _28200 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29342 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29342 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20442 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20442] = 30
                                    mem[_20442 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20673 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20673 + 68] = mem[idx + _20442 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20673 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20673 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21745 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21745] = 30
                                    mem[_21745 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        _22257 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22257 + 68] = mem[idx + _21745 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22257 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22257 + -mem[64] + 100
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24791 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24791] = 30
                                    mem[_24791 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25765 + 68] = mem[idx + _24791 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25765 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25765 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21244 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21244] = 30
                                mem[_21244 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21744 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21744 + 68] = mem[idx + _21244 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21744 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21744 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23859 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23859] = 30
                                mem[_23859 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24790 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24790 + 68] = mem[idx + _23859 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24790 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24790 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28198 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28198] = 30
                                mem[_28198 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29340 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29340 + 68] = mem[idx + _28198 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29340 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29340 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21243] = 30
                                mem[_21243 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21743 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21743 + 68] = mem[idx + _21243 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21743 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21743 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23857 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23857] = 30
                                mem[_23857 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _24789 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24789 + 68] = mem[idx + _23857 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24789 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24789 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28196 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28196] = 30
                                mem[_28196 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29339 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29339 + 68] = mem[idx + _28196 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29339 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29339 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22964 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22964] = 30
                            mem[_22964 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _23856 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23856 + 68] = mem[idx + _22964 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23856 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23856 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26915 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26915] = 30
                            mem[_26915 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _28195 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28195 + 68] = mem[idx + _26915 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28195 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28195 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31776] = 30
                            mem[_31776 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32917 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32917 + 68] = mem[idx + _31776 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32917 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32917 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20440] = 30
                                    mem[_20440 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _20672 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20672 + 68] = mem[idx + _20440 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20672 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20672 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _21741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21741] = 30
                                    mem[_21741 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _22255 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22255 + 68] = mem[idx + _21741 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22255 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22255 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24787 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24787] = 30
                                    mem[_24787 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor14 / totalSupply:
                                        if arg1 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor14 / totalSupply)
                                    _25764 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25764 + 68] = mem[idx + _24787 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25764 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25764 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21242 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21242] = 30
                                mem[_21242 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21740 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21740 + 68] = mem[idx + _21242 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21740 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21740 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23854 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23854] = 30
                                mem[_23854 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _24786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24786 + 68] = mem[idx + _23854 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24786 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24786 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28193] = 30
                                mem[_28193 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29337 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29337 + 68] = mem[idx + _28193 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29337 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29337 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21241] = 30
                                mem[_21241 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21739 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21739 + 68] = mem[idx + _21241 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21739 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21739 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23852 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23852] = 30
                                mem[_23852 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24785 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24785 + 68] = mem[idx + _23852 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24785 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24785 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28191] = 30
                                mem[_28191 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29336 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29336 + 68] = mem[idx + _28191 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29336 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29336 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22963 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22963] = 30
                            mem[_22963 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23851 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23851 + 68] = mem[idx + _22963 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23851 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23851 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26913 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26913] = 30
                            mem[_26913 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _28190 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28190 + 68] = mem[idx + _26913 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28190 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28190 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31773] = 30
                            mem[_31773 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32914 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32914 + 68] = mem[idx + _31773 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32914 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32914 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21240 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21240] = 30
                                mem[_21240 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21738 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21738 + 68] = mem[idx + _21240 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21738 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21738 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23849 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23849] = 30
                                mem[_23849 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    _24784 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24784 + 68] = mem[idx + _23849 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24784 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24784 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _28188 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28188] = 30
                                mem[_28188 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29335 + 68] = mem[idx + _28188 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29335 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29335 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22962 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22962] = 30
                            mem[_22962 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23848 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23848 + 68] = mem[idx + _22962 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23848 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23848 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26911 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26911] = 30
                            mem[_26911 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _28187 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28187 + 68] = mem[idx + _26911 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28187 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28187 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31771] = 30
                            mem[_31771 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32912 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32912 + 68] = mem[idx + _31771 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32912 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32912 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _22961 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22961] = 30
                            mem[_22961 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23847 + 68] = mem[idx + _22961 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23847 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23847 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26909 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26909] = 30
                            mem[_26909 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _28186 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28186 + 68] = mem[idx + _26909 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28186 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28186 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31769 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31769] = 30
                            mem[_31769 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32911 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32911 + 68] = mem[idx + _31769 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32911 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32911 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25763] = 30
                        mem[_25763 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26908 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26908 + 68] = mem[idx + _25763 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26908 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26908 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30450 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30450] = 30
                        mem[_30450 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _31768 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31768 + 68] = mem[idx + _30450 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31768 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31768 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34701] = 30
                        mem[_34701 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35558 + 68] = mem[idx + _34701 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35558 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35558 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19255 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19255] = 30
                        mem[_19255 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19345 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19345 + 68] = mem[idx + _19255 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19345 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19345 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19683 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19683] = 30
                        mem[_19683 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19735 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19735 + 68] = mem[idx + _19683 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19735 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19735 + -mem[64] + 100
                    _19297 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19297] = 26
                    mem[_19297 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19380 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19380 + 68] = mem[idx + _19297 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19380 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19380 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20680 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20680] = 30
                                mem[_20680 + 32] = 'SafeMath: subtraction overflow'
                                _22270 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22270] = 30
                                mem[_22270 + 32] = 'SafeMath: subtraction overflow'
                                _25781 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25781] = 30
                                mem[_25781 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26921 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26921 + 68] = mem[idx + _25781 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26921 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26921 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20679 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20679] = 30
                                mem[_20679 + 32] = 'SafeMath: subtraction overflow'
                                _22269 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22269] = 30
                                mem[_22269 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22970 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22970 + 68] = mem[idx + _22269 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22970 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22970 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25779 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25779] = 30
                                mem[_25779 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26920 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26920 + 68] = mem[idx + _25779 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26920 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26920 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21755 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21755] = 30
                            mem[_21755 + 32] = 'SafeMath: subtraction overflow'
                            _24811 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24811] = 30
                            mem[_24811 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _25778 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25778 + 68] = mem[idx + _24811 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25778 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25778 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29359 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29359] = 30
                            mem[_29359 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30459 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30459 + 68] = mem[idx + _29359 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30459 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30459 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20678 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20678] = 30
                                mem[_20678 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20851 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20851 + 68] = mem[idx + _20678 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20851 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20851 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22267 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22267] = 30
                                mem[_22267 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    _22969 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22969 + 68] = mem[idx + _22267 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22969 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22969 + -mem[64] + 100
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25776] = 30
                                mem[_25776 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26919 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26919 + 68] = mem[idx + _25776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26919 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26919 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21754 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21754] = 30
                            mem[_21754 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22266 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22266 + 68] = mem[idx + _21754 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22266 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22266 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24809 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24809] = 30
                            mem[_24809 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25775 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25775 + 68] = mem[idx + _24809 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25775 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25775 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29357 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29357] = 30
                            mem[_29357 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30457 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30457 + 68] = mem[idx + _29357 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30457 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30457 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21753 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21753] = 30
                            mem[_21753 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _22265 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22265 + 68] = mem[idx + _21753 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22265 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22265 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24807] = 30
                            mem[_24807 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                _25774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25774 + 68] = mem[idx + _24807 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25774 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25774 + -mem[64] + 100
                            if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29355] = 30
                            mem[_29355 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30456 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30456 + 68] = mem[idx + _29355 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30456 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30456 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23865 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23865] = 30
                        mem[_23865 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                            _24806 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24806 + 68] = mem[idx + _23865 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24806 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24806 + -mem[64] + 100
                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28210 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28210] = 30
                        mem[_28210 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                            _29354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29354 + 68] = mem[idx + _28210 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29354 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29354 + -mem[64] + 100
                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32929 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32929] = 30
                        mem[_32929 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33662 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33662 + 68] = mem[idx + _32929 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33662 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33662 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20676 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20676] = 30
                                mem[_20676 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20850 + 68] = mem[idx + _20676 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20850 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20850 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _22263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22263] = 30
                                mem[_22263 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22967 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22967 + 68] = mem[idx + _22263 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22967 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22967 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25772] = 30
                                mem[_25772 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _26918 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26918 + 68] = mem[idx + _25772 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26918 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26918 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21752 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21752] = 30
                            mem[_21752 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22262 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22262 + 68] = mem[idx + _21752 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22262 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22262 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24804 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24804] = 30
                            mem[_24804 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _25771 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25771 + 68] = mem[idx + _24804 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25771 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25771 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29352 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29352] = 30
                            mem[_29352 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30454 + 68] = mem[idx + _29352 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30454 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30454 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21751] = 30
                            mem[_21751 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22261 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22261 + 68] = mem[idx + _21751 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22261 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22261 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24802 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24802] = 30
                            mem[_24802 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25770 + 68] = mem[idx + _24802 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25770 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25770 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29350] = 30
                            mem[_29350 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30453 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30453 + 68] = mem[idx + _29350 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30453 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30453 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23864 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23864] = 30
                        mem[_23864 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24801 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24801 + 68] = mem[idx + _23864 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24801 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24801 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _28208 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28208] = 30
                        mem[_28208 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29349 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29349 + 68] = mem[idx + _28208 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29349 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29349 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32926 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32926] = 30
                        mem[_32926 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33659 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33659 + 68] = mem[idx + _32926 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33659 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33659 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21750] = 30
                            mem[_21750 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22260 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22260 + 68] = mem[idx + _21750 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22260 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22260 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24799] = 30
                            mem[_24799 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                _25769 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25769 + 68] = mem[idx + _24799 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25769 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25769 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29347] = 30
                            mem[_29347 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30452 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30452 + 68] = mem[idx + _29347 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30452 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30452 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23863 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23863] = 30
                        mem[_23863 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24798 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24798 + 68] = mem[idx + _23863 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24798 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24798 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28206 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28206] = 30
                        mem[_28206 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29346 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29346 + 68] = mem[idx + _28206 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29346 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29346 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _32924 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32924] = 30
                        mem[_32924 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33657 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33657 + 68] = mem[idx + _32924 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33657 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33657 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _23862 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23862] = 30
                        mem[_23862 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24797 + 68] = mem[idx + _23862 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24797 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28204 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28204] = 30
                        mem[_28204 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            _29345 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29345 + 68] = mem[idx + _28204 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29345 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29345 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32922 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32922] = 30
                        mem[_32922 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33656 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33656 + 68] = mem[idx + _32922 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33656 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33656 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26917 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26917] = 30
                    mem[_26917 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28203 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28203 + 68] = mem[idx + _26917 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28203 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28203 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31781 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31781] = 30
                    mem[_31781 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        _32921 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32921 + 68] = mem[idx + _31781 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32921 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32921 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35563 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35563] = 30
                    mem[_35563 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35914 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35914 + 68] = mem[idx + _35563 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35914 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35914 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
    else:
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor12:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19224] = 26
                        mem[_19224 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19293 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19293 + 68] = mem[idx + _19224 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19293 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19293 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    _20432 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20432] = 30
                                    mem[_20432 + 32] = 'SafeMath: subtraction overflow'
                                    _21726 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21726] = 30
                                    mem[_21726 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22237 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22237 + 68] = mem[idx + _21726 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22237 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22237 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24757 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24757] = 30
                                    mem[_24757 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25743 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25743 + 68] = mem[idx + _24757 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25743 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25743 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21225 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21225] = 30
                                mem[_21225 + 32] = 'SafeMath: subtraction overflow'
                                _23821 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23821] = 30
                                mem[_23821 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24756 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24756 + 68] = mem[idx + _23821 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24756 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24756 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28148 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28148] = 30
                                mem[_28148 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29311 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29311 + 68] = mem[idx + _28148 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29311 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29311 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20431] = 30
                                mem[_20431 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20665 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20665 + 68] = mem[idx + _20431 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20665 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20665 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _21724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21724] = 30
                                mem[_21724 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _22236 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22236 + 68] = mem[idx + _21724 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22236 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22236 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24754] = 30
                                mem[_24754 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25742 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25742 + 68] = mem[idx + _24754 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25742 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25742 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21224] = 30
                                mem[_21224 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21723 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21723 + 68] = mem[idx + _21224 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21723 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21723 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23819] = 30
                                mem[_23819 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24753 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24753 + 68] = mem[idx + _23819 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24753 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24753 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28146 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28146] = 30
                                mem[_28146 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29309 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29309 + 68] = mem[idx + _28146 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29309 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29309 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22940 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22940] = 30
                            mem[_22940 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _23818 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23818 + 68] = mem[idx + _22940 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23818 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23818 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26872 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26872] = 30
                            mem[_26872 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _28145 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28145 + 68] = mem[idx + _26872 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28145 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28145 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31728] = 30
                            mem[_31728 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32878 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32878 + 68] = mem[idx + _31728 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32878 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32878 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20429 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20429] = 30
                                mem[_20429 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20664 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20664 + 68] = mem[idx + _20429 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20664 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20664 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _21721 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21721] = 30
                                mem[_21721 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22234 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22234 + 68] = mem[idx + _21721 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22234 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22234 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _24751 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24751] = 30
                                mem[_24751 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _25741 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25741 + 68] = mem[idx + _24751 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25741 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25741 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21223] = 30
                                mem[_21223 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21720 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21720 + 68] = mem[idx + _21223 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21720 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21720 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23816] = 30
                                mem[_23816 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24750 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24750 + 68] = mem[idx + _23816 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24750 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24750 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28143] = 30
                                mem[_28143 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29307 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29307 + 68] = mem[idx + _28143 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29307 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29307 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22939 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22939] = 30
                            mem[_22939 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23815 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23815 + 68] = mem[idx + _22939 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23815 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23815 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26870] = 30
                            mem[_26870 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _28142 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28142 + 68] = mem[idx + _26870 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28142 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28142 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31725 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31725] = 30
                            mem[_31725 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32876 + 68] = mem[idx + _31725 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32876 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32876 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21222 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21222] = 30
                            mem[_21222 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _21719 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21719 + 68] = mem[idx + _21222 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21719 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21719 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _23813 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23813] = 30
                            mem[_23813 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _24749 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24749 + 68] = mem[idx + _23813 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24749 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24749 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _28140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28140] = 30
                            mem[_28140 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _29306 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29306 + 68] = mem[idx + _28140 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29306 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29306 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _22938 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22938] = 30
                            mem[_22938 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23812 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23812 + 68] = mem[idx + _22938 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23812 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23812 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26868] = 30
                            mem[_26868 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _28139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28139 + 68] = mem[idx + _26868 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28139 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28139 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31723 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31723] = 30
                            mem[_31723 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32874 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32874 + 68] = mem[idx + _31723 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32874 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32874 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25740 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25740] = 30
                        mem[_25740 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26867 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26867 + 68] = mem[idx + _25740 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26867 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26867 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30423 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30423] = 30
                        mem[_30423 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _31722 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31722 + 68] = mem[idx + _30423 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31722 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31722 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34669] = 30
                        mem[_34669 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35528 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35528 + 68] = mem[idx + _34669 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35528 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35528 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19254] = 30
                        mem[_19254 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19342 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19342 + 68] = mem[idx + _19254 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19342 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19342 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19681 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19681] = 30
                        mem[_19681 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19734 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19734 + 68] = mem[idx + _19681 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19734 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19734 + -mem[64] + 100
                    _19294 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19294] = 26
                    mem[_19294 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19378 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19378 + 68] = mem[idx + _19294 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19378 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19378 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                return 0
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20671 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20671] = 30
                                mem[_20671 + 32] = 'SafeMath: subtraction overflow'
                                _22246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22246] = 30
                                mem[_22246 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22945 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22945 + 68] = mem[idx + _22246 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22945 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22945 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25753 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25753] = 30
                                mem[_25753 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26877 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26877 + 68] = mem[idx + _25753 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26877 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26877 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21731] = 30
                            mem[_21731 + 32] = 'SafeMath: subtraction overflow'
                            _24768 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24768] = 30
                            mem[_24768 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _25752 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25752 + 68] = mem[idx + _24768 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25752 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25752 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29322 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29322] = 30
                            mem[_29322 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30430 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30430 + 68] = mem[idx + _29322 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30430 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30430 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _20670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20670] = 30
                            mem[_20670 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _20843 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20843 + 68] = mem[idx + _20670 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20843 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20843 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _22244 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22244] = 30
                            mem[_22244 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _22944 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22944 + 68] = mem[idx + _22244 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22944 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22944 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25750] = 30
                            mem[_25750 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26876 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26876 + 68] = mem[idx + _25750 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26876 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26876 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21730 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21730] = 30
                            mem[_21730 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22243 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22243 + 68] = mem[idx + _21730 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22243 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22243 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24766 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24766] = 30
                            mem[_24766 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25749 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25749 + 68] = mem[idx + _24766 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25749 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25749 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29320 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29320] = 30
                            mem[_29320 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30428 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30428 + 68] = mem[idx + _29320 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30428 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30428 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23824 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23824] = 30
                        mem[_23824 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _24765 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24765 + 68] = mem[idx + _23824 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24765 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24765 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28156] = 30
                        mem[_28156 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _29319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29319 + 68] = mem[idx + _28156 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29319 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29319 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32887 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32887] = 30
                        mem[_32887 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33649 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33649 + 68] = mem[idx + _32887 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33649 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33649 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _20668 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20668] = 30
                            mem[_20668 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _20842 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20842 + 68] = mem[idx + _20668 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20842 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20842 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _22241 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22241] = 30
                            mem[_22241 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22942 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22942 + 68] = mem[idx + _22241 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22942 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22942 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _25747 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25747] = 30
                            mem[_25747 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _26875 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26875 + 68] = mem[idx + _25747 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26875 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26875 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21729] = 30
                            mem[_21729 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22240 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22240 + 68] = mem[idx + _21729 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22240 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22240 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24763 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24763] = 30
                            mem[_24763 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25746 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25746 + 68] = mem[idx + _24763 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25746 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25746 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29317 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29317] = 30
                            mem[_29317 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30426 + 68] = mem[idx + _29317 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30426 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30426 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23823 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23823] = 30
                        mem[_23823 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24762 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24762 + 68] = mem[idx + _23823 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24762 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24762 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _28154 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28154] = 30
                        mem[_28154 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29316 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29316 + 68] = mem[idx + _28154 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29316 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29316 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32884 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32884] = 30
                        mem[_32884 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33647 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33647 + 68] = mem[idx + _32884 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33647 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33647 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _21728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21728] = 30
                        mem[_21728 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _22239 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22239 + 68] = mem[idx + _21728 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22239 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22239 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _24760 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24760] = 30
                        mem[_24760 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _25745 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25745 + 68] = mem[idx + _24760 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25745 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25745 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _29314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29314] = 30
                        mem[_29314 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _30425 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30425 + 68] = mem[idx + _29314 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30425 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30425 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _23822 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23822] = 30
                        mem[_23822 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24759 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24759 + 68] = mem[idx + _23822 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24759 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24759 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28152 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28152] = 30
                        mem[_28152 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29313 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29313 + 68] = mem[idx + _28152 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29313 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29313 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32882 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32882] = 30
                        mem[_32882 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33645 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33645 + 68] = mem[idx + _32882 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33645 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33645 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26874 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26874] = 30
                    mem[_26874 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28151 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28151 + 68] = mem[idx + _26874 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28151 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28151 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31732 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31732] = 30
                    mem[_31732 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _32881 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32881 + 68] = mem[idx + _31732 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32881 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32881 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35532 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35532] = 30
                    mem[_35532 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35910 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35910 + 68] = mem[idx + _35532 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35910 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35910 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if 0 / stor12 / 100:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if 0 / stor12 / 100:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (0 / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19220 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19220] = 26
                        mem[_19220 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19290 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19290 + 68] = mem[idx + _19220 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19290 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19290 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20420] = 30
                                    mem[_20420 + 32] = 'SafeMath: subtraction overflow'
                                    _21705 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21705] = 30
                                    mem[_21705 + 32] = 'SafeMath: subtraction overflow'
                                    _24720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24720] = 30
                                    mem[_24720 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25719 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25719 + 68] = mem[idx + _24720 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25719 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25719 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20419 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20419] = 30
                                    mem[_20419 + 32] = 'SafeMath: subtraction overflow'
                                    _21704 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21704] = 30
                                    mem[_21704 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22218 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22218 + 68] = mem[idx + _21704 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22218 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22218 + -mem[64] + 100
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24718 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24718] = 30
                                    mem[_24718 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25718 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25718 + 68] = mem[idx + _24718 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25718 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25718 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21207] = 30
                                mem[_21207 + 32] = 'SafeMath: subtraction overflow'
                                _23791 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23791] = 30
                                mem[_23791 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24717 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24717 + 68] = mem[idx + _23791 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24717 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24717 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28105] = 30
                                mem[_28105 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29278 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29278 + 68] = mem[idx + _28105 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29278 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29278 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20418 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20418] = 30
                                    mem[_20418 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20656 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20656 + 68] = mem[idx + _20418 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20656 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20656 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21702] = 30
                                    mem[_21702 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        _22217 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22217 + 68] = mem[idx + _21702 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22217 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22217 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24715 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24715] = 30
                                    mem[_24715 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25717 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25717 + 68] = mem[idx + _24715 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25717 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25717 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21206] = 30
                                mem[_21206 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21701 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21701 + 68] = mem[idx + _21206 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21701 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21701 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23789 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23789] = 30
                                mem[_23789 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24714 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24714 + 68] = mem[idx + _23789 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24714 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24714 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28103 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28103] = 30
                                mem[_28103 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29276 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29276 + 68] = mem[idx + _28103 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29276 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29276 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21205 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21205] = 30
                                mem[_21205 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21700 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21700 + 68] = mem[idx + _21205 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21700 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21700 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23787 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23787] = 30
                                mem[_23787 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24713 + 68] = mem[idx + _23787 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24713 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24713 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28101 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28101] = 30
                                mem[_28101 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29275 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29275 + 68] = mem[idx + _28101 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29275 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29275 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22920 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22920] = 30
                            mem[_22920 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _23786 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23786 + 68] = mem[idx + _22920 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23786 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23786 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26840 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26840] = 30
                            mem[_26840 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _28100 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28100 + 68] = mem[idx + _26840 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28100 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28100 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31691 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31691] = 30
                            mem[_31691 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32843 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32843 + 68] = mem[idx + _31691 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32843 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32843 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20416 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20416] = 30
                                    mem[_20416 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _20655 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20655 + 68] = mem[idx + _20416 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20655 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20655 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _21698 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21698] = 30
                                    mem[_21698 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _22215 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22215 + 68] = mem[idx + _21698 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22215 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22215 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24711 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24711] = 30
                                    mem[_24711 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor14 / totalSupply:
                                        if arg1 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor14 / totalSupply)
                                    _25716 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25716 + 68] = mem[idx + _24711 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25716 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25716 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21204 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21204] = 30
                                mem[_21204 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21697 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21697 + 68] = mem[idx + _21204 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21697 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21697 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23784 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23784] = 30
                                mem[_23784 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _24710 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24710 + 68] = mem[idx + _23784 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24710 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24710 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28098 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28098] = 30
                                mem[_28098 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29273 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29273 + 68] = mem[idx + _28098 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29273 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29273 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21203 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21203] = 30
                                mem[_21203 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21696 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21696 + 68] = mem[idx + _21203 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21696 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21696 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23782 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23782] = 30
                                mem[_23782 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24709 + 68] = mem[idx + _23782 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24709 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24709 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28096 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28096] = 30
                                mem[_28096 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29272 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29272 + 68] = mem[idx + _28096 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29272 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29272 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22919 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22919] = 30
                            mem[_22919 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23781 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23781 + 68] = mem[idx + _22919 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23781 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23781 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26838] = 30
                            mem[_26838 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _28095 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28095 + 68] = mem[idx + _26838 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28095 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28095 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31688] = 30
                            mem[_31688 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32840 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32840 + 68] = mem[idx + _31688 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32840 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32840 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21202] = 30
                                mem[_21202 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21695 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21695 + 68] = mem[idx + _21202 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21695 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21695 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23779 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23779] = 30
                                mem[_23779 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                    _24708 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24708 + 68] = mem[idx + _23779 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24708 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24708 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _28093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28093] = 30
                                mem[_28093 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29271 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29271 + 68] = mem[idx + _28093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29271 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29271 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22918 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22918] = 30
                            mem[_22918 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23778 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23778 + 68] = mem[idx + _22918 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23778 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23778 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26836 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26836] = 30
                            mem[_26836 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _28092 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28092 + 68] = mem[idx + _26836 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28092 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28092 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31686 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31686] = 30
                            mem[_31686 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32838 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32838 + 68] = mem[idx + _31686 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32838 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32838 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _22917 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22917] = 30
                            mem[_22917 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23777 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23777 + 68] = mem[idx + _22917 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23777 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23777 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26834 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26834] = 30
                            mem[_26834 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _28091 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28091 + 68] = mem[idx + _26834 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28091 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28091 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31684 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31684] = 30
                            mem[_31684 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32837 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32837 + 68] = mem[idx + _31684 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32837 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32837 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25715 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25715] = 30
                        mem[_25715 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26833 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26833 + 68] = mem[idx + _25715 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26833 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26833 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30397] = 30
                        mem[_30397 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _31683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31683 + 68] = mem[idx + _30397 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31683 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31683 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34641 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34641] = 30
                        mem[_34641 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35501 + 68] = mem[idx + _34641 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35501 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35501 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19253 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19253] = 30
                        mem[_19253 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19339 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19339 + 68] = mem[idx + _19253 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19339 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19339 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19679 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19679] = 30
                        mem[_19679 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19733 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19733 + 68] = mem[idx + _19679 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19733 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19733 + -mem[64] + 100
                    _19291 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19291] = 26
                    mem[_19291 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19376 + 68] = mem[idx + _19291 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19376 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19376 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20663 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20663] = 30
                                mem[_20663 + 32] = 'SafeMath: subtraction overflow'
                                _22230 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22230] = 30
                                mem[_22230 + 32] = 'SafeMath: subtraction overflow'
                                _25733 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25733] = 30
                                mem[_25733 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26846 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26846 + 68] = mem[idx + _25733 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26846 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26846 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20662 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20662] = 30
                                mem[_20662 + 32] = 'SafeMath: subtraction overflow'
                                _22229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22229] = 30
                                mem[_22229 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22926 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22926 + 68] = mem[idx + _22229 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22926 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22926 + -mem[64] + 100
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25731 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25731] = 30
                                mem[_25731 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26845 + 68] = mem[idx + _25731 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26845 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21712 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21712] = 30
                            mem[_21712 + 32] = 'SafeMath: subtraction overflow'
                            _24735 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24735] = 30
                            mem[_24735 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                _25730 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25730 + 68] = mem[idx + _24735 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25730 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25730 + -mem[64] + 100
                            if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29295 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29295] = 30
                            mem[_29295 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30406 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30406 + 68] = mem[idx + _29295 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30406 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30406 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20661 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20661] = 30
                                mem[_20661 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20839 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20839 + 68] = mem[idx + _20661 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20839 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20839 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22227 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22227] = 30
                                mem[_22227 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _22925 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22925 + 68] = mem[idx + _22227 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22925 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22925 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25728] = 30
                                mem[_25728 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26844 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26844 + 68] = mem[idx + _25728 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26844 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26844 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21711] = 30
                            mem[_21711 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22226 + 68] = mem[idx + _21711 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22226 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22226 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24733] = 30
                            mem[_24733 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25727 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25727 + 68] = mem[idx + _24733 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25727 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25727 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29293 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29293] = 30
                            mem[_29293 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30404 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30404 + 68] = mem[idx + _29293 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30404 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30404 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21710 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21710] = 30
                            mem[_21710 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22225 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22225 + 68] = mem[idx + _21710 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22225 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22225 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24731] = 30
                            mem[_24731 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25726 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25726 + 68] = mem[idx + _24731 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25726 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25726 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29291 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29291] = 30
                            mem[_29291 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30403 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30403 + 68] = mem[idx + _29291 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30403 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30403 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23795 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23795] = 30
                        mem[_23795 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _24730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24730 + 68] = mem[idx + _23795 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24730 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24730 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28115 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28115] = 30
                        mem[_28115 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _29290 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29290 + 68] = mem[idx + _28115 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29290 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29290 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32855 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32855] = 30
                        mem[_32855 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33637 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33637 + 68] = mem[idx + _32855 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33637 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33637 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20659 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20659] = 30
                                mem[_20659 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20838 + 68] = mem[idx + _20659 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20838 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20838 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _22223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22223] = 30
                                mem[_22223 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22923 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22923 + 68] = mem[idx + _22223 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22923 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22923 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25724] = 30
                                mem[_25724 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _26843 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26843 + 68] = mem[idx + _25724 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26843 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26843 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21709 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21709] = 30
                            mem[_21709 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22222 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22222 + 68] = mem[idx + _21709 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22222 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22222 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24728] = 30
                            mem[_24728 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _25723 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25723 + 68] = mem[idx + _24728 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25723 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25723 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29288] = 30
                            mem[_29288 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30401 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30401 + 68] = mem[idx + _29288 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30401 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30401 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21708] = 30
                            mem[_21708 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22221 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22221 + 68] = mem[idx + _21708 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22221 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22221 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24726] = 30
                            mem[_24726 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25722 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25722 + 68] = mem[idx + _24726 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25722 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25722 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29286 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29286] = 30
                            mem[_29286 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30400 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30400 + 68] = mem[idx + _29286 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30400 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30400 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23794 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23794] = 30
                        mem[_23794 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24725 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24725 + 68] = mem[idx + _23794 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24725 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24725 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _28113 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28113] = 30
                        mem[_28113 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29285 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29285 + 68] = mem[idx + _28113 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29285 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29285 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32852 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32852] = 30
                        mem[_32852 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33634 + 68] = mem[idx + _32852 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33634 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33634 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21707] = 30
                            mem[_21707 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22220 + 68] = mem[idx + _21707 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22220 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22220 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24723 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24723] = 30
                            mem[_24723 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _25721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25721 + 68] = mem[idx + _24723 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25721 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29283 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29283] = 30
                            mem[_29283 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30399 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30399 + 68] = mem[idx + _29283 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30399 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30399 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23793 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23793] = 30
                        mem[_23793 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24722 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24722 + 68] = mem[idx + _23793 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24722 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24722 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28111 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28111] = 30
                        mem[_28111 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29282 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29282 + 68] = mem[idx + _28111 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29282 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29282 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _32850 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32850] = 30
                        mem[_32850 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33632 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33632 + 68] = mem[idx + _32850 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33632 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33632 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _23792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23792] = 30
                        mem[_23792 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24721 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24721 + 68] = mem[idx + _23792 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24721 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24721 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28109 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28109] = 30
                        mem[_28109 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29281 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29281 + 68] = mem[idx + _28109 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29281 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29281 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32848 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32848] = 30
                        mem[_32848 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33631 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33631 + 68] = mem[idx + _32848 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33631 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33631 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26842 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26842] = 30
                    mem[_26842 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28108 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28108 + 68] = mem[idx + _26842 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28108 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28108 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31696 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31696] = 30
                    mem[_31696 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _32847 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32847 + 68] = mem[idx + _31696 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32847 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32847 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35506 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35506] = 30
                    mem[_35506 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35905 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35905 + 68] = mem[idx + _35506 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35905 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35905 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * 0 / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (0 / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (0 / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor12:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < 0 / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19216 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19216] = 26
                        mem[_19216 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19287 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19287 + 68] = mem[idx + _19216 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19287 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19287 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    if not 0 / stor12 / 100:
                                        return 0
                                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20407] = 30
                                    mem[_20407 + 32] = 'SafeMath: subtraction overflow'
                                    _21681 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21681] = 30
                                    mem[_21681 + 32] = 'SafeMath: subtraction overflow'
                                    _24677 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24677] = 30
                                    mem[_24677 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                        if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25692 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25692 + 68] = mem[idx + _24677 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25692 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25692 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    _20406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20406] = 30
                                    mem[_20406 + 32] = 'SafeMath: subtraction overflow'
                                    _21680 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21680] = 30
                                    mem[_21680 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22194 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22194 + 68] = mem[idx + _21680 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22194 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22194 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24675 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24675] = 30
                                    mem[_24675 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25691 + 68] = mem[idx + _24675 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25691 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25691 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21185] = 30
                                mem[_21185 + 32] = 'SafeMath: subtraction overflow'
                                _23750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23750] = 30
                                mem[_23750 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24674 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24674 + 68] = mem[idx + _23750 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24674 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24674 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28051] = 30
                                mem[_28051 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29241 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29241 + 68] = mem[idx + _28051 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29241 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29241 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    _20405 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20405] = 30
                                    mem[_20405 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20647 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20647 + 68] = mem[idx + _20405 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20647 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20647 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21678] = 30
                                    mem[_21678 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        _22193 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22193 + 68] = mem[idx + _21678 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22193 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22193 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24672] = 30
                                    mem[_24672 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25690 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25690 + 68] = mem[idx + _24672 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25690 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25690 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21184 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21184] = 30
                                mem[_21184 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21677 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21677 + 68] = mem[idx + _21184 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21677 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21677 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23748] = 30
                                mem[_23748 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24671 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24671 + 68] = mem[idx + _23748 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24671 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24671 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28049 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28049] = 30
                                mem[_28049 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29239 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29239 + 68] = mem[idx + _28049 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29239 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29239 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21183 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21183] = 30
                                mem[_21183 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21676 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21676 + 68] = mem[idx + _21183 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21676 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21676 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23746] = 30
                                mem[_23746 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24670 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24670 + 68] = mem[idx + _23746 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24670 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24670 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28047 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28047] = 30
                                mem[_28047 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29238 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29238 + 68] = mem[idx + _28047 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29238 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29238 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22895 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22895] = 30
                            mem[_22895 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _23745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23745 + 68] = mem[idx + _22895 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23745 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23745 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26796] = 30
                            mem[_26796 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _28046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28046 + 68] = mem[idx + _26796 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28046 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28046 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31642] = 30
                            mem[_31642 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32800 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32800 + 68] = mem[idx + _31642 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32800 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32800 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    _20403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20403] = 30
                                    mem[_20403 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _20646 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20646 + 68] = mem[idx + _20403 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20646 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20646 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _21674 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21674] = 30
                                    mem[_21674 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _22191 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22191 + 68] = mem[idx + _21674 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22191 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22191 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24668] = 30
                                    mem[_24668 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor14 / totalSupply:
                                        if arg1 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor14 / totalSupply)
                                    _25689 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25689 + 68] = mem[idx + _24668 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25689 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25689 + -mem[64] + 100
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21182 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21182] = 30
                                mem[_21182 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21673 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21673 + 68] = mem[idx + _21182 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21673 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21673 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23743 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23743] = 30
                                mem[_23743 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _24667 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24667 + 68] = mem[idx + _23743 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24667 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24667 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _28044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28044] = 30
                                mem[_28044 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29236 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29236 + 68] = mem[idx + _28044 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29236 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29236 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _21181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21181] = 30
                                mem[_21181 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21672 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21672 + 68] = mem[idx + _21181 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21672 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21672 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23741 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23741] = 30
                                mem[_23741 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24666 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24666 + 68] = mem[idx + _23741 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24666 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24666 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _28042 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28042] = 30
                                mem[_28042 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29235 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29235 + 68] = mem[idx + _28042 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29235 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29235 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22894 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22894] = 30
                            mem[_22894 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23740 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23740 + 68] = mem[idx + _22894 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23740 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23740 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26794 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26794] = 30
                            mem[_26794 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _28041 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28041 + 68] = mem[idx + _26794 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28041 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28041 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31639] = 30
                            mem[_31639 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32797 + 68] = mem[idx + _31639 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32797 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _21180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21180] = 30
                                mem[_21180 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21671 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21671 + 68] = mem[idx + _21180 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21671 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21671 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23738 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23738] = 30
                                mem[_23738 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                    _24665 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24665 + 68] = mem[idx + _23738 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24665 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24665 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _28039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28039] = 30
                                mem[_28039 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29234 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29234 + 68] = mem[idx + _28039 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29234 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29234 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22893] = 30
                            mem[_22893 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23737 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23737 + 68] = mem[idx + _22893 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23737 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23737 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26792 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26792] = 30
                            mem[_26792 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _28038 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28038 + 68] = mem[idx + _26792 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28038 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28038 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31637 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31637] = 30
                            mem[_31637 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32795 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32795 + 68] = mem[idx + _31637 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32795 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32795 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _22892 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22892] = 30
                            mem[_22892 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23736 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23736 + 68] = mem[idx + _22892 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23736 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23736 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26790] = 30
                            mem[_26790 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _28037 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28037 + 68] = mem[idx + _26790 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28037 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28037 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31635] = 30
                            mem[_31635 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32794 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32794 + 68] = mem[idx + _31635 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32794 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32794 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25688 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25688] = 30
                        mem[_25688 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26789 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26789 + 68] = mem[idx + _25688 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26789 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26789 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30367] = 30
                        mem[_30367 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _31634 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31634 + 68] = mem[idx + _30367 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31634 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31634 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34607] = 30
                        mem[_34607 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35468 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35468 + 68] = mem[idx + _34607 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35468 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35468 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19252 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19252] = 30
                        mem[_19252 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19336 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19336 + 68] = mem[idx + _19252 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19336 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19336 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19677 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19677] = 30
                        mem[_19677 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19732 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19732 + 68] = mem[idx + _19677 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19732 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19732 + -mem[64] + 100
                    _19288 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19288] = 26
                    mem[_19288 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19374 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19374 + 68] = mem[idx + _19288 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19374 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19374 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    return 0
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20654] = 30
                                mem[_20654 + 32] = 'SafeMath: subtraction overflow'
                                _22206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22206] = 30
                                mem[_22206 + 32] = 'SafeMath: subtraction overflow'
                                _25706 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25706] = 30
                                mem[_25706 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26802 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26802 + 68] = mem[idx + _25706 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26802 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26802 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                _20653 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20653] = 30
                                mem[_20653 + 32] = 'SafeMath: subtraction overflow'
                                _22205 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22205] = 30
                                mem[_22205 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22901 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22901 + 68] = mem[idx + _22205 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22901 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22901 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25704 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25704] = 30
                                mem[_25704 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26801 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26801 + 68] = mem[idx + _25704 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26801 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26801 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21688] = 30
                            mem[_21688 + 32] = 'SafeMath: subtraction overflow'
                            _24692 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24692] = 30
                            mem[_24692 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _25703 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25703 + 68] = mem[idx + _24692 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25703 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25703 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29258 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29258] = 30
                            mem[_29258 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30376 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30376 + 68] = mem[idx + _29258 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30376 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30376 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20652 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20652] = 30
                                mem[_20652 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20831 + 68] = mem[idx + _20652 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20831 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20831 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22203 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22203] = 30
                                mem[_22203 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _22900 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22900 + 68] = mem[idx + _22203 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22900 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22900 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25701 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25701] = 30
                                mem[_25701 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26800 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26800 + 68] = mem[idx + _25701 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26800 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26800 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21687] = 30
                            mem[_21687 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22202 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22202 + 68] = mem[idx + _21687 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22202 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22202 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24690] = 30
                            mem[_24690 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25700 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25700 + 68] = mem[idx + _24690 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25700 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25700 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29256 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29256] = 30
                            mem[_29256 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30374 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30374 + 68] = mem[idx + _29256 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30374 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30374 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21686 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21686] = 30
                            mem[_21686 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22201 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22201 + 68] = mem[idx + _21686 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22201 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22201 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24688] = 30
                            mem[_24688 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25699 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25699 + 68] = mem[idx + _24688 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25699 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25699 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29254 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29254] = 30
                            mem[_29254 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30373 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30373 + 68] = mem[idx + _29254 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30373 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30373 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23754 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23754] = 30
                        mem[_23754 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _24687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24687 + 68] = mem[idx + _23754 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24687 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24687 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28061 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28061] = 30
                        mem[_28061 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _29253 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29253 + 68] = mem[idx + _28061 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29253 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29253 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32812 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32812] = 30
                        mem[_32812 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33623 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33623 + 68] = mem[idx + _32812 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33623 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33623 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                _20650 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20650] = 30
                                mem[_20650 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20830 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20830 + 68] = mem[idx + _20650 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20830 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20830 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _22199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22199] = 30
                                mem[_22199 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22898 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22898 + 68] = mem[idx + _22199 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22898 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22898 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25697] = 30
                                mem[_25697 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _26799 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26799 + 68] = mem[idx + _25697 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26799 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26799 + -mem[64] + 100
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21685 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21685] = 30
                            mem[_21685 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22198 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22198 + 68] = mem[idx + _21685 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22198 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22198 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24685 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24685] = 30
                            mem[_24685 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _25696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25696 + 68] = mem[idx + _24685 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25696 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25696 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29251 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29251] = 30
                            mem[_29251 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30371 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30371 + 68] = mem[idx + _29251 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30371 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30371 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            _21684 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21684] = 30
                            mem[_21684 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22197 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22197 + 68] = mem[idx + _21684 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22197 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22197 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24683] = 30
                            mem[_24683 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25695 + 68] = mem[idx + _24683 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25695 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29249 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29249] = 30
                            mem[_29249 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30370 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30370 + 68] = mem[idx + _29249 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30370 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30370 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23753 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23753] = 30
                        mem[_23753 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24682 + 68] = mem[idx + _23753 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24682 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _28059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28059] = 30
                        mem[_28059 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29248 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29248 + 68] = mem[idx + _28059 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29248 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29248 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32809 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32809] = 30
                        mem[_32809 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33620 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33620 + 68] = mem[idx + _32809 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33620 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33620 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            _21683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21683] = 30
                            mem[_21683 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22196 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22196 + 68] = mem[idx + _21683 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22196 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22196 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24680] = 30
                            mem[_24680 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _25694 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25694 + 68] = mem[idx + _24680 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25694 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25694 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29246 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29246] = 30
                            mem[_29246 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30369 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30369 + 68] = mem[idx + _29246 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30369 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30369 + -mem[64] + 100
                        if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                            revert with 0, 17
                        if not 0 / stor12 / 100:
                            revert with 0, 18
                        if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23752 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23752] = 30
                        mem[_23752 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24679 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24679 + 68] = mem[idx + _23752 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24679 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24679 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28057 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28057] = 30
                        mem[_28057 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29245 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29245 + 68] = mem[idx + _28057 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29245 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29245 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _32807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32807] = 30
                        mem[_32807 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33618 + 68] = mem[idx + _32807 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33618 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33618 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor12 / 100:
                        _23751 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23751] = 30
                        mem[_23751 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24678 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24678 + 68] = mem[idx + _23751 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24678 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24678 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28055 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28055] = 30
                        mem[_28055 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29244 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29244 + 68] = mem[idx + _28055 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29244 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29244 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32805] = 30
                        mem[_32805 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33617 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33617 + 68] = mem[idx + _32805 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33617 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33617 + -mem[64] + 100
                    if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                        revert with 0, 17
                    if not 0 / stor12 / 100:
                        revert with 0, 18
                    if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26798 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26798] = 30
                    mem[_26798 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28054 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28054 + 68] = mem[idx + _26798 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28054 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28054 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31647 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31647] = 30
                    mem[_31647 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _32804 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32804 + 68] = mem[idx + _31647 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32804 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32804 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35473 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35473] = 30
                    mem[_35473 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35900 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35900 + 68] = mem[idx + _35473 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35900 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35900 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if 0 / stor12 / 100:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not 0 / stor12 / 100:
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor12 / 100:
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                        revert with 0, 17
                                    if not 0 / stor12 / 100:
                                        revert with 0, 18
                                    if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and t / s > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * t / s / 0 / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0 / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if 0 / stor12 / 100:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not 0 / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                    revert with 0, 17
                                if not 0 / stor12 / 100:
                                    revert with 0, 18
                                if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor12 / 100 and stor14 / totalSupply > -1 / 0 / stor12 / 100:
                                revert with 0, 17
                            if not 0 / stor12 / 100:
                                revert with 0, 18
                            if 0 / stor12 / 100 * stor14 / totalSupply / 0 / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0 / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor12:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor12 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor12 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) < arg1 * _BURN_FEE / stor12 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor12 / 100 > arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor12 / 100) - (arg1 * _BURN_FEE / stor12 / 100) < arg1 * _CHARITY_FEE / stor12 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor14
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _19212 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19212] = 26
                        mem[_19212 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19284 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19284 + 68] = mem[idx + _19212 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19284 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19284 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20394 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20394] = 30
                                    mem[_20394 + 32] = 'SafeMath: subtraction overflow'
                                    _21657 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21657] = 30
                                    mem[_21657 + 32] = 'SafeMath: subtraction overflow'
                                    _24634 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24634] = 30
                                    mem[_24634 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25665 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25665 + 68] = mem[idx + _24634 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25665 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25665 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20393] = 30
                                    mem[_20393 + 32] = 'SafeMath: subtraction overflow'
                                    _21656 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21656] = 30
                                    mem[_21656 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _22170 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22170 + 68] = mem[idx + _21656 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22170 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22170 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _24632 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24632] = 30
                                    mem[_24632 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25664 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25664 + 68] = mem[idx + _24632 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25664 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25664 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21163] = 30
                                mem[_21163 + 32] = 'SafeMath: subtraction overflow'
                                _23709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23709] = 30
                                mem[_23709 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _24631 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24631 + 68] = mem[idx + _23709 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24631 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24631 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27997 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27997] = 30
                                mem[_27997 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29204 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29204 + 68] = mem[idx + _27997 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29204 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29204 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20392] = 30
                                    mem[_20392 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                        _20638 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20638 + 68] = mem[idx + _20392 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20638 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20638 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    _21654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21654] = 30
                                    mem[_21654 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        _22169 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22169 + 68] = mem[idx + _21654 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22169 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22169 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24629 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24629] = 30
                                    mem[_24629 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25663 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25663 + 68] = mem[idx + _24629 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25663 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25663 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21162 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21162] = 30
                                mem[_21162 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21653 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21653 + 68] = mem[idx + _21162 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21653 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21653 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23707 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23707] = 30
                                mem[_23707 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24628 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24628 + 68] = mem[idx + _23707 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24628 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24628 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _27995 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27995] = 30
                                mem[_27995 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29202 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29202 + 68] = mem[idx + _27995 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29202 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29202 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21161] = 30
                                mem[_21161 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _21652 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21652 + 68] = mem[idx + _21161 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21652 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21652 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23705 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23705] = 30
                                mem[_23705 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _24627 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24627 + 68] = mem[idx + _23705 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24627 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24627 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27993 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27993] = 30
                                mem[_27993 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29201 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29201 + 68] = mem[idx + _27993 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29201 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29201 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22870] = 30
                            mem[_22870 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _23704 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23704 + 68] = mem[idx + _22870 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23704 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23704 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26752 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26752] = 30
                            mem[_26752 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _27992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27992 + 68] = mem[idx + _26752 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27992 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27992 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31593 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31593] = 30
                            mem[_31593 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32757 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32757 + 68] = mem[idx + _31593 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32757 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32757 + -mem[64] + 100
                        if arg1 and stor14 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    _20390 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20390] = 30
                                    mem[_20390 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _20637 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20637 + 68] = mem[idx + _20390 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20637 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20637 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _21650 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21650] = 30
                                    mem[_21650 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor14 / totalSupply:
                                        _22167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22167 + 68] = mem[idx + _21650 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22167 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22167 + -mem[64] + 100
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    _24625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24625] = 30
                                    mem[_24625 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor14 / totalSupply:
                                        if arg1 * stor14 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor14 / totalSupply)
                                    _25662 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25662 + 68] = mem[idx + _24625 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25662 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25662 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21160 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21160] = 30
                                mem[_21160 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21649 + 68] = mem[idx + _21160 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21649 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21649 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23702 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23702] = 30
                                mem[_23702 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _24624 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24624 + 68] = mem[idx + _23702 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24624 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24624 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _27990 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27990] = 30
                                mem[_27990 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29199 + 68] = mem[idx + _27990 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29199 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21159] = 30
                                mem[_21159 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _21648 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21648 + 68] = mem[idx + _21159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21648 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21648 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _23700 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23700] = 30
                                mem[_23700 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _24623 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24623 + 68] = mem[idx + _23700 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24623 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24623 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _27988 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27988] = 30
                                mem[_27988 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29198 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29198 + 68] = mem[idx + _27988 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29198 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29198 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22869 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22869] = 30
                            mem[_22869 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _23699 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23699 + 68] = mem[idx + _22869 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23699 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23699 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _26750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26750] = 30
                            mem[_26750 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _27987 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27987 + 68] = mem[idx + _26750 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27987 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27987 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31590 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31590] = 30
                            mem[_31590 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32754 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32754 + 68] = mem[idx + _31590 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32754 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32754 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _21158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21158] = 30
                                mem[_21158 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                    _21647 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21647 + 68] = mem[idx + _21158 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21647 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21647 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _23697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23697] = 30
                                mem[_23697 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                    _24622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24622 + 68] = mem[idx + _23697 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24622 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24622 + -mem[64] + 100
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                _27985 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27985] = 30
                                mem[_27985 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _29197 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29197 + 68] = mem[idx + _27985 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29197 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29197 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22868] = 30
                            mem[_22868 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23696 + 68] = mem[idx + _22868 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23696 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23696 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26748] = 30
                            mem[_26748 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _27984 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27984 + 68] = mem[idx + _26748 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27984 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27984 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _31588 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31588] = 30
                            mem[_31588 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32752 + 68] = mem[idx + _31588 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32752 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32752 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _22867 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22867] = 30
                            mem[_22867 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _23695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23695 + 68] = mem[idx + _22867 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23695 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _26746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26746] = 30
                            mem[_26746 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _27983 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27983 + 68] = mem[idx + _26746 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27983 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27983 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _31586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31586] = 30
                            mem[_31586 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _32751 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32751 + 68] = mem[idx + _31586 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32751 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32751 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25661] = 30
                        mem[_25661 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _26745 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26745 + 68] = mem[idx + _25661 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26745 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26745 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _30337 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30337] = 30
                        mem[_30337 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _31585 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31585 + 68] = mem[idx + _30337 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31585 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31585 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _34573 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34573] = 30
                        mem[_34573 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _35435 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35435 + 68] = mem[idx + _34573 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35435 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35435 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _19251 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19251] = 30
                        mem[_19251 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _19333 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19333 + 68] = mem[idx + _19251 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19333 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19333 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _19675 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19675] = 30
                        mem[_19675 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _19731 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19731 + 68] = mem[idx + _19675 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19731 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19731 + -mem[64] + 100
                    _19285 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19285] = 26
                    mem[_19285 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19372 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19372 + 68] = mem[idx + _19285 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19372 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19372 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20645 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20645] = 30
                                mem[_20645 + 32] = 'SafeMath: subtraction overflow'
                                _22182 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22182] = 30
                                mem[_22182 + 32] = 'SafeMath: subtraction overflow'
                                _25679 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25679] = 30
                                mem[_25679 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26758 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26758 + 68] = mem[idx + _25679 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26758 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26758 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20644] = 30
                                mem[_20644 + 32] = 'SafeMath: subtraction overflow'
                                _22181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22181] = 30
                                mem[_22181 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _22876 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22876 + 68] = mem[idx + _22181 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22876 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22876 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _25677 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25677] = 30
                                mem[_25677 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26757 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26757 + 68] = mem[idx + _25677 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26757 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26757 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21664 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21664] = 30
                            mem[_21664 + 32] = 'SafeMath: subtraction overflow'
                            _24649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24649] = 30
                            mem[_24649 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _25676 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25676 + 68] = mem[idx + _24649 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25676 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25676 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29221 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29221] = 30
                            mem[_29221 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30346 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30346 + 68] = mem[idx + _29221 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30346 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30346 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20643 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20643] = 30
                                mem[_20643 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    _20823 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20823 + 68] = mem[idx + _20643 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20823 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20823 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                _22179 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22179] = 30
                                mem[_22179 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    _22875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22875 + 68] = mem[idx + _22179 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22875 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22875 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25674 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25674] = 30
                                mem[_25674 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26756 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26756 + 68] = mem[idx + _25674 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26756 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26756 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21663] = 30
                            mem[_21663 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22178 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22178 + 68] = mem[idx + _21663 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22178 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22178 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24647 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24647] = 30
                            mem[_24647 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25673 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25673 + 68] = mem[idx + _24647 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25673 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25673 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29219 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29219] = 30
                            mem[_29219 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30344 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30344 + 68] = mem[idx + _29219 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30344 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30344 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21662] = 30
                            mem[_21662 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                _22177 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22177 + 68] = mem[idx + _21662 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22177 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22177 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24645 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24645] = 30
                            mem[_24645 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                _25672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25672 + 68] = mem[idx + _24645 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25672 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25672 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29217] = 30
                            mem[_29217 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30343 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30343 + 68] = mem[idx + _29217 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30343 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30343 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23713] = 30
                        mem[_23713 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                            _24644 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24644 + 68] = mem[idx + _23713 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24644 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24644 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28007 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28007] = 30
                        mem[_28007 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            _29216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29216 + 68] = mem[idx + _28007 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29216 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29216 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32769] = 30
                        mem[_32769 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33609 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33609 + 68] = mem[idx + _32769 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33609 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33609 + -mem[64] + 100
                    if arg1 and stor14 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                _20641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20641] = 30
                                mem[_20641 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _20822 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20822 + 68] = mem[idx + _20641 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20822 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20822 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _22175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22175] = 30
                                mem[_22175 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor14 / totalSupply:
                                    _22873 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22873 + 68] = mem[idx + _22175 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22873 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22873 + -mem[64] + 100
                                if arg1 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                _25670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25670] = 30
                                mem[_25670 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor14 / totalSupply:
                                    if arg1 * stor14 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor14 / totalSupply)
                                _26755 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26755 + 68] = mem[idx + _25670 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26755 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26755 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21661] = 30
                            mem[_21661 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22174 + 68] = mem[idx + _21661 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22174 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22174 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24642] = 30
                            mem[_24642 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _25669 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25669 + 68] = mem[idx + _24642 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25669 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25669 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _29214 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29214] = 30
                            mem[_29214 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= arg1 * stor14 / totalSupply:
                                if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30341 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30341 + 68] = mem[idx + _29214 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30341 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30341 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21660 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21660] = 30
                            mem[_21660 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                _22173 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22173 + 68] = mem[idx + _21660 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22173 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22173 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            _24640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24640] = 30
                            mem[_24640 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _25668 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25668 + 68] = mem[idx + _24640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25668 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25668 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _29212 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29212] = 30
                            mem[_29212 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30340 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30340 + 68] = mem[idx + _29212 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30340 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30340 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23712 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23712] = 30
                        mem[_23712 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor14 / totalSupply:
                            _24639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24639 + 68] = mem[idx + _23712 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24639 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24639 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < 0:
                            revert with 0, 17
                        _28005 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28005] = 30
                        mem[_28005 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _29211 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29211 + 68] = mem[idx + _28005 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29211 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29211 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32766 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32766] = 30
                        mem[_32766 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33606 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33606 + 68] = mem[idx + _32766 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33606 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33606 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            _21659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21659] = 30
                            mem[_21659 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                _22172 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22172 + 68] = mem[idx + _21659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22172 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22172 + -mem[64] + 100
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            _24637 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24637] = 30
                            mem[_24637 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                _25667 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25667 + 68] = mem[idx + _24637 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25667 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25667 + -mem[64] + 100
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            _29209 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29209] = 30
                            mem[_29209 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor14 / totalSupply)
                            _30339 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30339 + 68] = mem[idx + _29209 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30339 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30339 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23711 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23711] = 30
                        mem[_23711 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24636 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24636 + 68] = mem[idx + _23711 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24636 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24636 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28003 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28003] = 30
                        mem[_28003 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29208 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29208 + 68] = mem[idx + _28003 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29208 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29208 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                            revert with 0, 17
                        _32764 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32764] = 30
                        mem[_32764 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33604 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33604 + 68] = mem[idx + _32764 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33604 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33604 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        _23710 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23710] = 30
                        mem[_23710 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                            _24635 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24635 + 68] = mem[idx + _23710 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24635 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24635 + -mem[64] + 100
                        if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _28001 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28001] = 30
                        mem[_28001 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                            _29207 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29207 + 68] = mem[idx + _28001 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29207 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29207 + -mem[64] + 100
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        _32762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32762] = 30
                        mem[_32762 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor14 / totalSupply)
                        _33603 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33603 + 68] = mem[idx + _32762 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33603 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33603 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26754 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26754] = 30
                    mem[_26754 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                        _28000 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28000 + 68] = mem[idx + _26754 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28000 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28000 + -mem[64] + 100
                    if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _31598 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31598] = 30
                    mem[_31598 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                        _32761 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32761 + 68] = mem[idx + _31598 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32761 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32761 + -mem[64] + 100
                    if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                        revert with 0, 17
                    _35440 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35440] = 30
                    mem[_35440 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply <= (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                        if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor14 / totalSupply)
                    _35895 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35895 + 68] = mem[idx + _35440 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35895 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35895 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor14 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor12 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor12 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor12 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor12 / 100 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * t / s / arg1 * _TAX_FEE / stor12 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * t / s / arg1 * _BURN_FEE / stor12 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s / arg1 * _CHARITY_FEE / stor12 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) < arg1 * _BURN_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor12 / 100 * t / s) - (arg1 * _BURN_FEE / stor12 / 100 * t / s) < arg1 * _CHARITY_FEE / stor12 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor12 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor14 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor14 / totalSupply / arg1 != stor14 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor12 / 100:
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor12 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _TAX_FEE / stor12 / 100 != stor14 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor12 / 100:
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor12 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _BURN_FEE / stor12 / 100 != stor14 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor12 / 100:
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor12 / 100 and stor14 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor12 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply / arg1 * _CHARITY_FEE / stor12 / 100 != stor14 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply > arg1 * stor14 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor14 / totalSupply < arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply > (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor14 / totalSupply) - (arg1 * _TAX_FEE / stor12 / 100 * stor14 / totalSupply) - (arg1 * _BURN_FEE / stor12 / 100 * stor14 / totalSupply) < arg1 * _CHARITY_FEE / stor12 / 100 * stor14 / totalSupply:
                                revert with 0, 17
    return (arg1 * stor14 / totalSupply)
}



}
